{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/img/WeChat.jpg","path":"img/WeChat.jpg","modified":0,"renderable":0},{"_id":"source/img/wallhaven-l8yl6q_1920x1080.png","path":"img/wallhaven-l8yl6q_1920x1080.png","modified":0,"renderable":0},{"_id":"source/css/iconfont.ttf","path":"css/iconfont.ttf","modified":0,"renderable":0},{"_id":"source/img/java-keypoints/List.svg","path":"img/java-keypoints/List.svg","modified":0,"renderable":0},{"_id":"source/img/remove-redundant-and-compact-string/dump-2.png","path":"img/remove-redundant-and-compact-string/dump-2.png","modified":0,"renderable":0},{"_id":"source/img/remove-redundant-and-compact-string/dump-1.png","path":"img/remove-redundant-and-compact-string/dump-1.png","modified":0,"renderable":0},{"_id":"source/img/remove-redundant-and-compact-string/catalog-tree.svg","path":"img/remove-redundant-and-compact-string/catalog-tree.svg","modified":0,"renderable":0},{"_id":"source/img/remove-redundant-and-compact-string/model.svg","path":"img/remove-redundant-and-compact-string/model.svg","modified":0,"renderable":0},{"_id":"source/img/remove-redundant-and-compact-string/repeated-string.png","path":"img/remove-redundant-and-compact-string/repeated-string.png","modified":0,"renderable":0},{"_id":"source/img/remove-redundant-and-compact-string/repeated-string-2.png","path":"img/remove-redundant-and-compact-string/repeated-string-2.png","modified":0,"renderable":0},{"_id":"source/img/design-patterns/reactor.svg","path":"img/design-patterns/reactor.svg","modified":0,"renderable":0},{"_id":"source/img/design-patterns/gof.svg","path":"img/design-patterns/gof.svg","modified":0,"renderable":0},{"_id":"source/img/spring-boot-start.jpg","path":"img/spring-boot-start.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"06e2db44b6aca326f9cd1740cd951c93f1eacac8","modified":1687467901751},{"_id":"source/_posts/remove-redundant-and-compact-string.md","hash":"f122dad1e13edf31e798ad5545052d7f1d252f12","modified":1716127814894},{"_id":"source/about/index.md","hash":"0a38529a6b4e9b923cc60ae554e005312ff4f52b","modified":1716127814904},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1687284685229},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1687284685449},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"088788e149051fc0a3c6096ba95e35a8344de04b","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"30e3f4ccfef8474c05cf0b1eb02e91bd0a152807","modified":1687284685449},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"db000a6a0cec19d32a6e7e94cd4c478500d9c5ac","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1687284685419},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1687284685419},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1687284685419},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1687284685449},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1687284685409},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1687284685409},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1687284685419},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1687284685459},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1687284685409},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1687284685409},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1687284685419},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1687284685419},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1687284685449},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"870db75e4e403a840c4463dfeed2c9114846e7cc","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"e3713fa78e0fc14a239360b020068d8513573ae4","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"e49506e9895e255e0e53f34a11d325f83109c1b0","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1687284685239},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"9d13392cea94b66d86422ad17c66e5ae67ce1d32","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1687284685249},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1687284685259},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1687284685419},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1687284685429},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1687284685439},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1687284685939},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1687284685949},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1687284685939},{"_id":"source/img/avatar.jpg","hash":"c2bf46012b06fa9ddd633cfc202ec1f89835f8c3","modified":1687511376098},{"_id":"source/img/WeChat.jpg","hash":"fa08d8e421f78b6af4f2edfd2d115039903af920","modified":1687511387368},{"_id":"source/img/wallhaven-l8yl6q_1920x1080.png","hash":"15844e0ec24334cbb48a390f501922ad24923a46","modified":1687517212409},{"_id":"source/css/iconfont-leetcode.css","hash":"0c553a8a7f3c27d60c4ee87b865cedabd31965b1","modified":1716127814904},{"_id":"source/_posts/gc-review-1.md","hash":"6e8fad56526ea71fdf3dbea65e57dcb2ce923b67","modified":1718049847207},{"_id":"source/css/iconfont.ttf","hash":"a6af266a0f2645394d5377a4ca7ea66295092d93","modified":1716127814904},{"_id":"source/_posts/go-downloader-0.md","hash":"5187b2bbc5a80cd1e199b399dda8dc6cc9be4c1a","modified":1716127814894},{"_id":"source/_posts/state-management-in-react.md","hash":"d15b80fd7f0df428cee1a449e2dd5d5f093f8a30","modified":1716127814894},{"_id":"source/_posts/go-downloader-1.md","hash":"098bbfda41b6d09fecead090596c28f3b16a5e97","modified":1716127814894},{"_id":"source/_posts/unix-philosophy.md","hash":"47678dfba3aba7eb768562a5447185652ffd78f8","modified":1716127814904},{"_id":"source/img/java-keypoints/List.svg","hash":"ea5176e5308cc9c7f46fd88954f6fe90701a7cf2","modified":1718052214872},{"_id":"source/_posts/2024/java-list-keypoints.md","hash":"2533db419317f15e56753712a19060062c533420","modified":1718447915366},{"_id":"source/img/remove-redundant-and-compact-string/catalog-tree.svg","hash":"70c057529fd080a94f6e6341b8dea21b44c0a6d9","modified":1716127814905},{"_id":"source/img/remove-redundant-and-compact-string/model.svg","hash":"a29fb2e6fcc3b0cd7823c1c448127f0d1f9b1680","modified":1716127814906},{"_id":"source/img/remove-redundant-and-compact-string/dump-1.png","hash":"99d422bd9c04b6c3b9dd3678581c1cb5b1f1f845","modified":1716127814906},{"_id":"source/img/remove-redundant-and-compact-string/dump-2.png","hash":"a835532dac2d94d95310067258b761f893952261","modified":1716127814906},{"_id":"source/img/remove-redundant-and-compact-string/repeated-string.png","hash":"6c2867656c2a0018c04295455f73fe8d09fac40d","modified":1716127814907},{"_id":"source/img/remove-redundant-and-compact-string/repeated-string-2.png","hash":"ae9577ebebdffcc4bd674bdf34a875e50e8f6ccd","modified":1716127814907},{"_id":"source/_posts/2024/desgin-patterns-2.md","hash":"020e8456b5ced24232544d80e1e0a87f7491d57b","modified":1718383665859},{"_id":"source/_posts/2024/desgin-patterns-1.md","hash":"311e27f1590fcca818d0091a6681df2696653f98","modified":1718218740613},{"_id":"source/_posts/2024/deep-in-spring-boot-start.md","hash":"87eb2e126c84d94dc58107a245a2153f3b12b973","modified":1727837202173},{"_id":"source/img/design-patterns/gof.svg","hash":"21160a186128b58cc283a1c5e5495660b4178ce7","modified":1718218583963},{"_id":"source/img/design-patterns/reactor.svg","hash":"e02123de968d71bedf0fd2a16ef1d2a4116a7b3e","modified":1718218583979},{"_id":"source/img/Spring-boot-start.png","hash":"45eae069a0e4c5ae6817c99e34a67b7636d93ad4","modified":1719163511546},{"_id":"source/img/spring-boot-start.jpg","hash":"f43af50fe5dbbab51a411941569cc2e89443547b","modified":1719164877696},{"_id":"source/_posts/2025/why-netty-prefer-bytebuf-than-bytebuffer.md","hash":"77aeb84072224368c7336a22dc85ab3eca9657eb","modified":1740751867590},{"_id":"source/_posts/2025/how-to-build-high-performance-fifo-queue.md","hash":"d8a894a0d30e95fc2f5c699fd90bf700752ee4ce","modified":1740823411860},{"_id":"source/_posts/2025/why-netty-prefer-bytebuf-to-bytebuffer.md","hash":"2d6f142f65fb3d82d19657fcc2817192382dadcb","modified":1740759158427}],"Category":[],"Data":[],"Page":[{"title":"联系我","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 联系我\nlayout: about\n---\n","date":"2024-05-19T14:10:14.904Z","updated":"2024-05-19T14:10:14.904Z","path":"about/index.html","_id":"clj7jcutz0000jno0b4ohg2n2","comments":1,"content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"@font-face {\n  font-family: \"iconfont\"; /* Project id  */\n  src: url('iconfont.ttf?t=1689089626877') format('truetype');\n}\n\n.iconfont {\n  font-family: \"iconfont\" !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.icon-leetcode:before {\n  content: \"\\ebf2\";\n}\n\n","source":"css/iconfont-leetcode.css","raw":"@font-face {\n  font-family: \"iconfont\"; /* Project id  */\n  src: url('iconfont.ttf?t=1689089626877') format('truetype');\n}\n\n.iconfont {\n  font-family: \"iconfont\" !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.icon-leetcode:before {\n  content: \"\\ebf2\";\n}\n\n","date":"2024-05-19T14:10:14.904Z","updated":"2024-05-19T14:10:14.904Z","path":"css/iconfont-leetcode.css","layout":"false","title":"","comments":1,"_id":"clx9h4k2s0001cotg59nb56hm","content":"@font-face {\n  font-family: \"iconfont\"; /* Project id  */\n  src: url('iconfont.ttf?t=1689089626877') format('truetype');\n}\n\n.iconfont {\n  font-family: \"iconfont\" !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.icon-leetcode:before {\n  content: \"\\ebf2\";\n}\n\n","site":{"data":{}},"excerpt":"","more":"@font-face {\n  font-family: \"iconfont\"; /* Project id  */\n  src: url('iconfont.ttf?t=1689089626877') format('truetype');\n}\n\n.iconfont {\n  font-family: \"iconfont\" !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.icon-leetcode:before {\n  content: \"\\ebf2\";\n}\n\n"}],"Post":[{"title":"移除重复字符串和字符串压缩","date":"2023-06-19T16:00:00.000Z","_content":"> *请注意：案例中关键信息已经被匿名化处理*\n\n## 背景\n\n上一轮质量改进分析内存堆栈发现，运行时堆内存会驻留大量重复字符串。一段长度20个ASCII字符的设备编码，在系统中最多可能出现m个内容相同的字符串实例（m是系统最大管理设备数量，量级：百万）。这造成堆内存空间极大浪费，大量的冗余数据将本该用于支撑业务运行的空间占用，导致系统的设备管理规格上不去，成本下不来，对友商的竞争力降低。\n\n> 以下数据为场景模拟，不包含产品代码，也不是生产环境上获取的dump，仅用于现象说明\n\n![200万设备500万字符串](/img/remove-redundant-and-compact-string/dump-1.png)\n![示例设备对象模型](/img/remove-redundant-and-compact-string/model.svg)\n可以看到，String实例数量达到设备实例数量的2.5倍。\n![原理模拟，非生产环境数据](/img/remove-redundant-and-compact-string/repeated-string.png)\n通过jprofile分析，明显发现大量编码重复。\n\n## 问题分析\n\n### 为什么有重复\n\n由于模块负责GB28181协议中目录树功能，有大量层次化数据，即目录和目录下的设备。这些数据会驻留在内存中共查询和修改，数据之间的关系通过`ParentID`以及`externalDomainID`来表示。下面是个多层目录的示意图：\n![行政区划-业务分组设备树示意图](/img/remove-redundant-and-compact-string/catalog-tree.svg)\n可以很明显看出，每个节点都会持有一个指向父节点和指向根节点的指针。这个指针实际使用以对应元素的id来表示并用String来保存。由于每次反序列化时都是创建一个新的String对象，所以堆内存中有多少个设备对象，就会有多少个重复的指向根节点的id，以及指向不同父节点的id。\n\n### 还有没有其他问题\n\n编码用String保存，还有没有优化空间呢？查看JDK8的源码，String对象内部使用char[]保存数据，而单个char使用16bit Unicode保存。[^1]\n> char: The char data type is a single 16-bit Unicode character. It has a minimum value of `\\u0000` (or 0) and a maximum value of `\\uffff` (or 65,535 inclusive).\n\n可是，按照**GB28181-2022附录E 统一编码规则**[^2]的描述，编码仅会使用0到9的数字。即编码中单个字符仅需要4bit, 即`\\u0`到`\\uf`，就可以表示。所以使用String保存编码，实际上会造成大量空间浪费，利用率只有25%。我们需要一种新的方法来存储编码。\n\n## 解决方案\n\n### 在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用\n\n首先，我们要确立初步目标：\n\n1. 不再使用String保存设备编码，采用自定义类型；\n2. 新实现使用byte[]保存设备编码，采用的字符集编码单个字符占用空间应小于16bit。\n\n现在让我们看看类似的情况，别人都做了哪些工作：\n\n#### JEP 254: Compact Strings[^3]\n\n实际上，早在JDK9，Java就实装了一项增强。JEP 254，压缩字符串，简单说来就是想办法用更节省空间的办法来表示字符串。参考原文描述\n\n> We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.\n>\n>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM's intrinsic string operations.\n>\n>This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.\n>\n>The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.\n>\n>For further detail, see:\n>\n> - [State of String Density Performance](http://cr.openjdk.java.net/~shade/density/state-of-string-density-v1.txt)\n> - [String Density Impact on SPECjbb2005 on SPARC](http://cr.openjdk.java.net/~huntch/string-density/reports/String-Density-SPARC-jbb2005-Report.pdf)\n\n从JDK9开始，String的内部实现会判断要表示的字符串能否用Latin-1编码，如果可以则使用Latin-1编码[^4]。Latin-1会占用8bit，刚好是UTF-16的一半。根据介绍，采用新的实现后证实内存使用量减少，GC活动大幅减少，以及某些极端情况下的性能轻微下降。\n\n#### Netty: AsciiString\n\n类似JEP254，其实高性能网络框架也对String有类似的改进。参考Netty对AsciiString类的注释：\n\n> A string which has been encoded into a character encoding whose character always takes a single byte, similarly to ASCII. It internally keeps its content in a byte array unlike `String`, which uses a character array, for reduced memory footprint and faster data transfer from/to byte-based data structures such as a byte array and `ByteBuffer`. It is often used in conjunction with Headers that require a `CharSequence`.\n>\n> This class was designed to provide an immutable array of bytes, and caches some internal state based upon the value of this array. However underlying access to this byte array is provided via not copying the array on construction or `array()`. If any changes are made to the underlying byte array it is the user's responsibility to call `arrayChanged()` so the state of this class can be reset.\n\n这里的AsciiString通常被用在Netty内部表示请求的报文头这一类只会使用英文字符，数字，一些常见标点符号如“*”、“/”等场景。使用ASCII编码可以减少内存占用，同时利用byte存储，还能在拷贝数据的时候减少操作，提高性能。\n\n#### 我们怎么办?\n\n看过别人的解决方案之后，我们认识到：使用`byte[]`代替`char[]`是正确的方向，但是我们需要关注如何编码`byte[]`的问题。\n\n**为此，需要先确认一个字符可能出现多少种信息？** 参考GB28181的设计以及实际运行中的dump分析结果，再结合netty的实践，我们可以得出结论：使用新的设计表示设备编码、各种命令、报文头信息收益最大，因为这些场景的字符仅限于a-z，A-Z，0-9和一些常见字符，可能得取值不会超过80种。\n\n**然后我们需要寻找一个合适的编码方式。** 一个字符有80种可能性，则基于公式：\n\n{% katex '{\"displayMode\": true}'%}\nS = \\log_{2}N\n{% endkatex %}\n\n将N=80带入后可知，S≈6.32，即需要至少7个bit才能表示这个字符的所有可能性。但为了方便通过下标找到对应的字符，所以使用一个byte（即8bit）表示。此时我们既可以学JEP5254，使用Latin-1，也可以学Netty用ASCII编码。因为在我们的输入条件下，最终都会被编码成一个byte。实际实现中，为了简化编码，直接在byte中保存char。\n\n参考代码如下：\n\n```java\nclass DeviceID {\n\n    private final byte[] value;\n\n    private DeviceID(String id) {\n        this.value = parse(id);\n    }\n\n    private static byte[] parse(String id) {\n        byte[] value = new byte[id.length()];\n        for (int i = 0; i < id.length(); i++) {\n            char c = id.charAt(i);\n            if (!Character.isLetterOrDigit(c)) {\n                throw new IllegalArgumentException(\"unsupported id: \" + id);\n            }\n            value[i] = (byte) c;\n        }\n        return value;\n    }\n}\n```\n\n### 借鉴领域驱动的概念解决大量重复问题\n\n熟悉DDD（领域驱动设计）的朋友们肯定知道一个概念，**实体对象（EntityObject）**。实体对象在系统内是唯一的，不论属性如何变化。而在GB28181的体系内，设备的id类似身份证号，是设备的唯一标识。设备的属性如在线状态可能变化，但是只要设备不被替换，其id不能改变。所以如果我们重写模块中的反序列化组件，让相同编码都指向一个对象引用，就可以保证系统内部不再出现重复的编码对象。\n\n这里我们对前面定义的DeviceID进行改造，内部新增一个缓存，用于记录系统内当前已有的DeviceID对象。当我们需要创建一个新的DeviceID时，先在缓存中查找是否已经创建值相同的DeviceID对象，如果有就返回已创建对象的引用，没有就创建个新的然后返回新创建对象的引用。\n\n```java\nfinal class DeviceID {\n    private static final Map<String, DeviceID> referenceCache = new HashMap<>();\n    \n    private final byte[] value;\n\n    private DeviceID(String id) {\n        this.value = parse(id);\n    }\n\n    public static DeviceID of(String id) {\n        return referenceCache.computeIfAbsent(id, new DeviceID(id));\n    }\n}\n```\n\n但这样设计存在几个问题：\n\n1. 如前所述，String做key，空间利用太低，削弱了优化效果；\n2. 当DeviceID对应的设备从系统中移除的时候，如何将DeviceID从缓存中驱逐；\n3. HashMap实现不是线程安全的，并发调用getOrDefault的时候方法可能会空转不返回。\n4. 由于DeviceID会作为key，每次进行比对都会求一遍哈希值，对性能有负面影响\n\n**问题1**，使用DeviceID替代String作为key是个不错的选择。这里我们本身就要返回DeviceID，那么key只存放对象引用显然划算的多。同时还能利用重写的hashcode与equals方法找到重复的对象。\n\n**问题2**，可以采用两种办法：1）使用引用计数器，要求开发人员在不使用某个DeviceID的时候显式调用release方法，定时扫描引用计数器，为0的时候从缓存中移除对应DeviceID对象；2）参考ThreadLocal的设计，利用**弱引用**的机制，在GC的时候自动完成对应数据的清理动作。\n\n这里采用弱引用机制完成自动的数据清理动作。原因有3：\n\n1. 引用计数器虽然逻辑简单，但是使用者必须在编写代码时记得释放，否则就会有泄露风险。旧代码改造变更太多，非常容易引入问题，也不利于代码检视。\n2. ThreadLocal的泄露风险在此案例中不存在\n3. 可以直接使用WeakHashMap，不需要额外代码\n\n**问题3**，虽然换用了WeakHashMap，但它也是线程不安全的，这里可以利用Collections.synchronizedMap简单创建一个同步的map来解决问题。\n\n**问题4**，因为DeviceID对象本身设计为不可变对象，所以可以提前计算哈希值并保存，重写hashcode方法，令其返回保存的哈希值即可解决。\n\n完成修改后的参考代码如下：\n\n```java\nfinal class DeviceID implements CharSequence {\n    private static final Map<DeviceID, WeakReference<DeviceID>> cache =\n            Collections.synchronizedMap(new WeakHashMap<>());\n\n    private final byte[] value;\n    private final int hash;\n\n    private DeviceID(String id) {\n        this.value = parse(id);\n        this.hash = hash(this.value);\n    }\n\n    private static byte[] parse(String id) {\n        byte[] value = new byte[id.length()];\n        for (int i = 0; i < id.length(); i++) {\n            char c = id.charAt(i);\n            if (!Character.isLetterOrDigit(c)) {\n                throw new IllegalArgumentException(\"unsupported id: \" + id);\n            }\n            value[i] = (byte) c;\n        }\n        return value;\n    }\n\n    private static int hash(byte[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    public static DeviceID of(String id) {\n        DeviceID obj = new DeviceID(id);\n        return cache.computeIfAbsent(obj, k -> new WeakReference<>(obj)).get();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof DeviceID deviceID)) return false;\n        return Arrays.equals(value, deviceID.value);\n    }\n\n    @Override\n    public int hashCode() {\n        return hash;\n    }\n\n    @Override\n    public int length() {\n        return this.value.length;\n    }\n\n    @Override\n    public char charAt(int index) {\n        return (char) this.value[index];\n    }\n\n    @Override\n    public String subSequence(int start, int end) {\n        return toString(start, end);\n    }\n\n    @Override\n    public String toString() {\n        return toString(0, length());\n    }\n\n    private String toString(int start, int end) {\n        if (start < 0 || end > length() || start > end) {\n            throw new IndexOutOfBoundsException();\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = start; i < end; i++) {\n            sb.append((char) this.value[i]);\n        }\n        return sb.toString();\n    }\n}\n```\n\n## 实际效果\n\n### 测试用例\n\n下面将通过测试用例验证字符串压缩和缓存自动回收的结果。\n\n```java\n/**\n * 不GC，多次将值相同但不是同实例的字符串传入DeviceID.of方法，获得的DeviceID实例相同\n * */\n@Test\nvoid should_return_same_instance_after_create() {\n    String code1 = \"01010020002001234567\";\n    String code2 = new String(code1);\n    assertNotEquals(System.identityHashCode(code1), System.identityHashCode(code2));\n    DeviceID id = DeviceID.of(code1);\n    int first = System.identityHashCode(id);\n    id = DeviceID.of(code2);\n    int second = System.identityHashCode(id);\n    assertEquals(first, second);\n}\n\n/**\n * 一段字符串实例，创建DeviceID对象后移除强引用，然后GC，再次使用该字符串创建DeviceID对象，两次得到的DeviceID对象是不同实例\n * */\n@Test\nvoid should_return_new_instance_after_gc() {\n    String code = \"01010020002001234567\";\n    DeviceID id = DeviceID.of(code);\n    int first = System.identityHashCode(id);\n    id = null;\n    System.gc();\n    id = DeviceID.of(code);\n    int second = System.identityHashCode(id);\n    assertNotEquals(first, second);\n}\n\n@Test\nvoid should_be_thread_safe_when_create_in_multi_thread() {\n    Callable<List<DeviceID>> callable = () -> Stream.generate(UUID::randomUUID)\n            .map(UUID::toString)\n            .distinct()\n            .limit(100)\n            .map(DeviceID::of)\n            .toList();\n    ExecutorService executor = Executors.newFixedThreadPool(10);\n    List<Callable<List<DeviceID>>> tasks = Stream.generate(() -> callable).limit(10).toList();\n    await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> {\n        List<Future<List<DeviceID>>> futures = executor.invokeAll(tasks);\n        futures.forEach(future -> assertTrue(future.isDone()));\n    });\n    executor.shutdown();\n}\n```\n\n特殊的：下面这个用例只有在未包含JEP254的jdk8及老版本才能执行成功\n\n```java\n@Test\nvoid size_should_less_than_string() {\n    String code = \"01010020002001234567\";\n    DeviceID id = DeviceID.of(code);\n    System.out.println(GraphLayout.parseInstance(code).toFootprint());\n    System.out.println(GraphLayout.parseInstance(id).toFootprint());\n    assertTrue(GraphLayout.parseInstance(code).totalSize() > GraphLayout.parseInstance(id).totalSize());\n}\n```\n\n在JDK8中会有如下输出，可以看到对20位编码，一个实例下新类可以降低20%的总内存占用\n\n```console\njava.lang.String@4f638935d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        56        56   [C\n         1        24        24   java.lang.String\n         2                  80   (total)\n\n\nio.firestige.iris.DeviceID@7c417213d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        40        40   [B\n         1        24        24   io.firestige.iris.DeviceID\n         2                  64   (total)\n```\n\n当code的长度变为40时（实际使用中有时会将设备编码和域编码拼接），新的类可以节省33.33%内存空间\n\n```console\njava.lang.String@4f638935d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        96        96   [C\n         1        24        24   java.lang.String\n         2                 120   (total)\n\n\nio.firestige.iris.DeviceID@7880cdf3d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        56        56   [B\n         1        24        24   io.firestige.iris.DeviceID\n         2                  80   (total)\n```\n\n即随着字符串越来越长，对象头占用空间对实例占用内存的贡献降低，新类的压缩率会逐渐上升，最终可以节省接近50%内存空间。\n\n### dump对比\n\n通过dump的分析结果，我们可以很明显的看到总的内存占用降低，重复字符串的消失。\n\n||改动前|改动后|\n|---|---|---|\n|重复字符串分析|![重复字符串分析](/img/remove-redundant-and-compact-string/repeated-string.png)|![重复字符串分析](/img/remove-redundant-and-compact-string/repeated-string-2.png)|\n|老年代总量对比|![老年代总量对比](/img/remove-redundant-and-compact-string/dump-1.png)|![老年代总量对比](/img/remove-redundant-and-compact-string/dump-2.png)|\n\n## Reference\n\n[^1]: [The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html#:~:text=char%3A%20The%20char%20data%20type,'%20(or%2065%2C535%20inclusive)).\n[^2]: [GB/T 28181-2022, 公共安全视频监控联网系统信息传输、交换、控制技术要求](https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=8BBC2475624A6C31DC34A28052B3923D)\n[^3]: [JEP 254: Compact Strings](https://openjdk.org/jeps/254)\n[^4]: [ISO/IEC 8859-1/Latin-1](https://en.wikipedia.org/wiki/ISO/IEC_8859-1)\n","source":"_posts/remove-redundant-and-compact-string.md","raw":"---\ntitle: 移除重复字符串和字符串压缩\ndate: 2023-6-20\ntags:\n- 字符串优化\n- 内存优化\n- Java\n---\n> *请注意：案例中关键信息已经被匿名化处理*\n\n## 背景\n\n上一轮质量改进分析内存堆栈发现，运行时堆内存会驻留大量重复字符串。一段长度20个ASCII字符的设备编码，在系统中最多可能出现m个内容相同的字符串实例（m是系统最大管理设备数量，量级：百万）。这造成堆内存空间极大浪费，大量的冗余数据将本该用于支撑业务运行的空间占用，导致系统的设备管理规格上不去，成本下不来，对友商的竞争力降低。\n\n> 以下数据为场景模拟，不包含产品代码，也不是生产环境上获取的dump，仅用于现象说明\n\n![200万设备500万字符串](/img/remove-redundant-and-compact-string/dump-1.png)\n![示例设备对象模型](/img/remove-redundant-and-compact-string/model.svg)\n可以看到，String实例数量达到设备实例数量的2.5倍。\n![原理模拟，非生产环境数据](/img/remove-redundant-and-compact-string/repeated-string.png)\n通过jprofile分析，明显发现大量编码重复。\n\n## 问题分析\n\n### 为什么有重复\n\n由于模块负责GB28181协议中目录树功能，有大量层次化数据，即目录和目录下的设备。这些数据会驻留在内存中共查询和修改，数据之间的关系通过`ParentID`以及`externalDomainID`来表示。下面是个多层目录的示意图：\n![行政区划-业务分组设备树示意图](/img/remove-redundant-and-compact-string/catalog-tree.svg)\n可以很明显看出，每个节点都会持有一个指向父节点和指向根节点的指针。这个指针实际使用以对应元素的id来表示并用String来保存。由于每次反序列化时都是创建一个新的String对象，所以堆内存中有多少个设备对象，就会有多少个重复的指向根节点的id，以及指向不同父节点的id。\n\n### 还有没有其他问题\n\n编码用String保存，还有没有优化空间呢？查看JDK8的源码，String对象内部使用char[]保存数据，而单个char使用16bit Unicode保存。[^1]\n> char: The char data type is a single 16-bit Unicode character. It has a minimum value of `\\u0000` (or 0) and a maximum value of `\\uffff` (or 65,535 inclusive).\n\n可是，按照**GB28181-2022附录E 统一编码规则**[^2]的描述，编码仅会使用0到9的数字。即编码中单个字符仅需要4bit, 即`\\u0`到`\\uf`，就可以表示。所以使用String保存编码，实际上会造成大量空间浪费，利用率只有25%。我们需要一种新的方法来存储编码。\n\n## 解决方案\n\n### 在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用\n\n首先，我们要确立初步目标：\n\n1. 不再使用String保存设备编码，采用自定义类型；\n2. 新实现使用byte[]保存设备编码，采用的字符集编码单个字符占用空间应小于16bit。\n\n现在让我们看看类似的情况，别人都做了哪些工作：\n\n#### JEP 254: Compact Strings[^3]\n\n实际上，早在JDK9，Java就实装了一项增强。JEP 254，压缩字符串，简单说来就是想办法用更节省空间的办法来表示字符串。参考原文描述\n\n> We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.\n>\n>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM's intrinsic string operations.\n>\n>This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.\n>\n>The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.\n>\n>For further detail, see:\n>\n> - [State of String Density Performance](http://cr.openjdk.java.net/~shade/density/state-of-string-density-v1.txt)\n> - [String Density Impact on SPECjbb2005 on SPARC](http://cr.openjdk.java.net/~huntch/string-density/reports/String-Density-SPARC-jbb2005-Report.pdf)\n\n从JDK9开始，String的内部实现会判断要表示的字符串能否用Latin-1编码，如果可以则使用Latin-1编码[^4]。Latin-1会占用8bit，刚好是UTF-16的一半。根据介绍，采用新的实现后证实内存使用量减少，GC活动大幅减少，以及某些极端情况下的性能轻微下降。\n\n#### Netty: AsciiString\n\n类似JEP254，其实高性能网络框架也对String有类似的改进。参考Netty对AsciiString类的注释：\n\n> A string which has been encoded into a character encoding whose character always takes a single byte, similarly to ASCII. It internally keeps its content in a byte array unlike `String`, which uses a character array, for reduced memory footprint and faster data transfer from/to byte-based data structures such as a byte array and `ByteBuffer`. It is often used in conjunction with Headers that require a `CharSequence`.\n>\n> This class was designed to provide an immutable array of bytes, and caches some internal state based upon the value of this array. However underlying access to this byte array is provided via not copying the array on construction or `array()`. If any changes are made to the underlying byte array it is the user's responsibility to call `arrayChanged()` so the state of this class can be reset.\n\n这里的AsciiString通常被用在Netty内部表示请求的报文头这一类只会使用英文字符，数字，一些常见标点符号如“*”、“/”等场景。使用ASCII编码可以减少内存占用，同时利用byte存储，还能在拷贝数据的时候减少操作，提高性能。\n\n#### 我们怎么办?\n\n看过别人的解决方案之后，我们认识到：使用`byte[]`代替`char[]`是正确的方向，但是我们需要关注如何编码`byte[]`的问题。\n\n**为此，需要先确认一个字符可能出现多少种信息？** 参考GB28181的设计以及实际运行中的dump分析结果，再结合netty的实践，我们可以得出结论：使用新的设计表示设备编码、各种命令、报文头信息收益最大，因为这些场景的字符仅限于a-z，A-Z，0-9和一些常见字符，可能得取值不会超过80种。\n\n**然后我们需要寻找一个合适的编码方式。** 一个字符有80种可能性，则基于公式：\n\n{% katex '{\"displayMode\": true}'%}\nS = \\log_{2}N\n{% endkatex %}\n\n将N=80带入后可知，S≈6.32，即需要至少7个bit才能表示这个字符的所有可能性。但为了方便通过下标找到对应的字符，所以使用一个byte（即8bit）表示。此时我们既可以学JEP5254，使用Latin-1，也可以学Netty用ASCII编码。因为在我们的输入条件下，最终都会被编码成一个byte。实际实现中，为了简化编码，直接在byte中保存char。\n\n参考代码如下：\n\n```java\nclass DeviceID {\n\n    private final byte[] value;\n\n    private DeviceID(String id) {\n        this.value = parse(id);\n    }\n\n    private static byte[] parse(String id) {\n        byte[] value = new byte[id.length()];\n        for (int i = 0; i < id.length(); i++) {\n            char c = id.charAt(i);\n            if (!Character.isLetterOrDigit(c)) {\n                throw new IllegalArgumentException(\"unsupported id: \" + id);\n            }\n            value[i] = (byte) c;\n        }\n        return value;\n    }\n}\n```\n\n### 借鉴领域驱动的概念解决大量重复问题\n\n熟悉DDD（领域驱动设计）的朋友们肯定知道一个概念，**实体对象（EntityObject）**。实体对象在系统内是唯一的，不论属性如何变化。而在GB28181的体系内，设备的id类似身份证号，是设备的唯一标识。设备的属性如在线状态可能变化，但是只要设备不被替换，其id不能改变。所以如果我们重写模块中的反序列化组件，让相同编码都指向一个对象引用，就可以保证系统内部不再出现重复的编码对象。\n\n这里我们对前面定义的DeviceID进行改造，内部新增一个缓存，用于记录系统内当前已有的DeviceID对象。当我们需要创建一个新的DeviceID时，先在缓存中查找是否已经创建值相同的DeviceID对象，如果有就返回已创建对象的引用，没有就创建个新的然后返回新创建对象的引用。\n\n```java\nfinal class DeviceID {\n    private static final Map<String, DeviceID> referenceCache = new HashMap<>();\n    \n    private final byte[] value;\n\n    private DeviceID(String id) {\n        this.value = parse(id);\n    }\n\n    public static DeviceID of(String id) {\n        return referenceCache.computeIfAbsent(id, new DeviceID(id));\n    }\n}\n```\n\n但这样设计存在几个问题：\n\n1. 如前所述，String做key，空间利用太低，削弱了优化效果；\n2. 当DeviceID对应的设备从系统中移除的时候，如何将DeviceID从缓存中驱逐；\n3. HashMap实现不是线程安全的，并发调用getOrDefault的时候方法可能会空转不返回。\n4. 由于DeviceID会作为key，每次进行比对都会求一遍哈希值，对性能有负面影响\n\n**问题1**，使用DeviceID替代String作为key是个不错的选择。这里我们本身就要返回DeviceID，那么key只存放对象引用显然划算的多。同时还能利用重写的hashcode与equals方法找到重复的对象。\n\n**问题2**，可以采用两种办法：1）使用引用计数器，要求开发人员在不使用某个DeviceID的时候显式调用release方法，定时扫描引用计数器，为0的时候从缓存中移除对应DeviceID对象；2）参考ThreadLocal的设计，利用**弱引用**的机制，在GC的时候自动完成对应数据的清理动作。\n\n这里采用弱引用机制完成自动的数据清理动作。原因有3：\n\n1. 引用计数器虽然逻辑简单，但是使用者必须在编写代码时记得释放，否则就会有泄露风险。旧代码改造变更太多，非常容易引入问题，也不利于代码检视。\n2. ThreadLocal的泄露风险在此案例中不存在\n3. 可以直接使用WeakHashMap，不需要额外代码\n\n**问题3**，虽然换用了WeakHashMap，但它也是线程不安全的，这里可以利用Collections.synchronizedMap简单创建一个同步的map来解决问题。\n\n**问题4**，因为DeviceID对象本身设计为不可变对象，所以可以提前计算哈希值并保存，重写hashcode方法，令其返回保存的哈希值即可解决。\n\n完成修改后的参考代码如下：\n\n```java\nfinal class DeviceID implements CharSequence {\n    private static final Map<DeviceID, WeakReference<DeviceID>> cache =\n            Collections.synchronizedMap(new WeakHashMap<>());\n\n    private final byte[] value;\n    private final int hash;\n\n    private DeviceID(String id) {\n        this.value = parse(id);\n        this.hash = hash(this.value);\n    }\n\n    private static byte[] parse(String id) {\n        byte[] value = new byte[id.length()];\n        for (int i = 0; i < id.length(); i++) {\n            char c = id.charAt(i);\n            if (!Character.isLetterOrDigit(c)) {\n                throw new IllegalArgumentException(\"unsupported id: \" + id);\n            }\n            value[i] = (byte) c;\n        }\n        return value;\n    }\n\n    private static int hash(byte[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    public static DeviceID of(String id) {\n        DeviceID obj = new DeviceID(id);\n        return cache.computeIfAbsent(obj, k -> new WeakReference<>(obj)).get();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof DeviceID deviceID)) return false;\n        return Arrays.equals(value, deviceID.value);\n    }\n\n    @Override\n    public int hashCode() {\n        return hash;\n    }\n\n    @Override\n    public int length() {\n        return this.value.length;\n    }\n\n    @Override\n    public char charAt(int index) {\n        return (char) this.value[index];\n    }\n\n    @Override\n    public String subSequence(int start, int end) {\n        return toString(start, end);\n    }\n\n    @Override\n    public String toString() {\n        return toString(0, length());\n    }\n\n    private String toString(int start, int end) {\n        if (start < 0 || end > length() || start > end) {\n            throw new IndexOutOfBoundsException();\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = start; i < end; i++) {\n            sb.append((char) this.value[i]);\n        }\n        return sb.toString();\n    }\n}\n```\n\n## 实际效果\n\n### 测试用例\n\n下面将通过测试用例验证字符串压缩和缓存自动回收的结果。\n\n```java\n/**\n * 不GC，多次将值相同但不是同实例的字符串传入DeviceID.of方法，获得的DeviceID实例相同\n * */\n@Test\nvoid should_return_same_instance_after_create() {\n    String code1 = \"01010020002001234567\";\n    String code2 = new String(code1);\n    assertNotEquals(System.identityHashCode(code1), System.identityHashCode(code2));\n    DeviceID id = DeviceID.of(code1);\n    int first = System.identityHashCode(id);\n    id = DeviceID.of(code2);\n    int second = System.identityHashCode(id);\n    assertEquals(first, second);\n}\n\n/**\n * 一段字符串实例，创建DeviceID对象后移除强引用，然后GC，再次使用该字符串创建DeviceID对象，两次得到的DeviceID对象是不同实例\n * */\n@Test\nvoid should_return_new_instance_after_gc() {\n    String code = \"01010020002001234567\";\n    DeviceID id = DeviceID.of(code);\n    int first = System.identityHashCode(id);\n    id = null;\n    System.gc();\n    id = DeviceID.of(code);\n    int second = System.identityHashCode(id);\n    assertNotEquals(first, second);\n}\n\n@Test\nvoid should_be_thread_safe_when_create_in_multi_thread() {\n    Callable<List<DeviceID>> callable = () -> Stream.generate(UUID::randomUUID)\n            .map(UUID::toString)\n            .distinct()\n            .limit(100)\n            .map(DeviceID::of)\n            .toList();\n    ExecutorService executor = Executors.newFixedThreadPool(10);\n    List<Callable<List<DeviceID>>> tasks = Stream.generate(() -> callable).limit(10).toList();\n    await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> {\n        List<Future<List<DeviceID>>> futures = executor.invokeAll(tasks);\n        futures.forEach(future -> assertTrue(future.isDone()));\n    });\n    executor.shutdown();\n}\n```\n\n特殊的：下面这个用例只有在未包含JEP254的jdk8及老版本才能执行成功\n\n```java\n@Test\nvoid size_should_less_than_string() {\n    String code = \"01010020002001234567\";\n    DeviceID id = DeviceID.of(code);\n    System.out.println(GraphLayout.parseInstance(code).toFootprint());\n    System.out.println(GraphLayout.parseInstance(id).toFootprint());\n    assertTrue(GraphLayout.parseInstance(code).totalSize() > GraphLayout.parseInstance(id).totalSize());\n}\n```\n\n在JDK8中会有如下输出，可以看到对20位编码，一个实例下新类可以降低20%的总内存占用\n\n```console\njava.lang.String@4f638935d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        56        56   [C\n         1        24        24   java.lang.String\n         2                  80   (total)\n\n\nio.firestige.iris.DeviceID@7c417213d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        40        40   [B\n         1        24        24   io.firestige.iris.DeviceID\n         2                  64   (total)\n```\n\n当code的长度变为40时（实际使用中有时会将设备编码和域编码拼接），新的类可以节省33.33%内存空间\n\n```console\njava.lang.String@4f638935d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        96        96   [C\n         1        24        24   java.lang.String\n         2                 120   (total)\n\n\nio.firestige.iris.DeviceID@7880cdf3d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        56        56   [B\n         1        24        24   io.firestige.iris.DeviceID\n         2                  80   (total)\n```\n\n即随着字符串越来越长，对象头占用空间对实例占用内存的贡献降低，新类的压缩率会逐渐上升，最终可以节省接近50%内存空间。\n\n### dump对比\n\n通过dump的分析结果，我们可以很明显的看到总的内存占用降低，重复字符串的消失。\n\n||改动前|改动后|\n|---|---|---|\n|重复字符串分析|![重复字符串分析](/img/remove-redundant-and-compact-string/repeated-string.png)|![重复字符串分析](/img/remove-redundant-and-compact-string/repeated-string-2.png)|\n|老年代总量对比|![老年代总量对比](/img/remove-redundant-and-compact-string/dump-1.png)|![老年代总量对比](/img/remove-redundant-and-compact-string/dump-2.png)|\n\n## Reference\n\n[^1]: [The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html#:~:text=char%3A%20The%20char%20data%20type,'%20(or%2065%2C535%20inclusive)).\n[^2]: [GB/T 28181-2022, 公共安全视频监控联网系统信息传输、交换、控制技术要求](https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=8BBC2475624A6C31DC34A28052B3923D)\n[^3]: [JEP 254: Compact Strings](https://openjdk.org/jeps/254)\n[^4]: [ISO/IEC 8859-1/Latin-1](https://en.wikipedia.org/wiki/ISO/IEC_8859-1)\n","slug":"remove-redundant-and-compact-string","published":1,"updated":"2024-05-19T14:10:14.894Z","_id":"clj7jcuu20002jno05smogabl","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><em>请注意：案例中关键信息已经被匿名化处理</em></p>\n</blockquote>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>上一轮质量改进分析内存堆栈发现，运行时堆内存会驻留大量重复字符串。一段长度20个ASCII字符的设备编码，在系统中最多可能出现m个内容相同的字符串实例（m是系统最大管理设备数量，量级：百万）。这造成堆内存空间极大浪费，大量的冗余数据将本该用于支撑业务运行的空间占用，导致系统的设备管理规格上不去，成本下不来，对友商的竞争力降低。</p>\n<blockquote>\n<p>以下数据为场景模拟，不包含产品代码，也不是生产环境上获取的dump，仅用于现象说明</p>\n</blockquote>\n<p><img src=\"/img/remove-redundant-and-compact-string/dump-1.png\" alt=\"200万设备500万字符串\"><br><img src=\"/img/remove-redundant-and-compact-string/model.svg\" alt=\"示例设备对象模型\"><br>可以看到，String实例数量达到设备实例数量的2.5倍。<br><img src=\"/img/remove-redundant-and-compact-string/repeated-string.png\" alt=\"原理模拟，非生产环境数据\"><br>通过jprofile分析，明显发现大量编码重复。</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><h3 id=\"为什么有重复\"><a href=\"#为什么有重复\" class=\"headerlink\" title=\"为什么有重复\"></a>为什么有重复</h3><p>由于模块负责GB28181协议中目录树功能，有大量层次化数据，即目录和目录下的设备。这些数据会驻留在内存中共查询和修改，数据之间的关系通过<code>ParentID</code>以及<code>externalDomainID</code>来表示。下面是个多层目录的示意图：<br><img src=\"/img/remove-redundant-and-compact-string/catalog-tree.svg\" alt=\"行政区划-业务分组设备树示意图\"><br>可以很明显看出，每个节点都会持有一个指向父节点和指向根节点的指针。这个指针实际使用以对应元素的id来表示并用String来保存。由于每次反序列化时都是创建一个新的String对象，所以堆内存中有多少个设备对象，就会有多少个重复的指向根节点的id，以及指向不同父节点的id。</p>\n<h3 id=\"还有没有其他问题\"><a href=\"#还有没有其他问题\" class=\"headerlink\" title=\"还有没有其他问题\"></a>还有没有其他问题</h3><p>编码用String保存，还有没有优化空间呢？查看JDK8的源码，String对象内部使用char[]保存数据，而单个char使用16bit Unicode保存。<sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html#:~:text=char%3A%20The%20char%20data%20type,'%20(or%2065%2C535%20inclusive)).\">[1]</span></a></sup></p>\n<blockquote>\n<p>char: The char data type is a single 16-bit Unicode character. It has a minimum value of <code>\\u0000</code> (or 0) and a maximum value of <code>\\uffff</code> (or 65,535 inclusive).</p>\n</blockquote>\n<p>可是，按照<strong>GB28181-2022附录E 统一编码规则</strong><sup id=\"fnref:2\" class=\"footnote-ref\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"[GB/T 28181-2022, 公共安全视频监控联网系统信息传输、交换、控制技术要求](https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=8BBC2475624A6C31DC34A28052B3923D)\">[2]</span></a></sup>的描述，编码仅会使用0到9的数字。即编码中单个字符仅需要4bit, 即<code>\\u0</code>到<code>\\uf</code>，就可以表示。所以使用String保存编码，实际上会造成大量空间浪费，利用率只有25%。我们需要一种新的方法来存储编码。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用\"><a href=\"#在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用\" class=\"headerlink\" title=\"在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用\"></a>在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用</h3><p>首先，我们要确立初步目标：</p>\n<ol>\n<li>不再使用String保存设备编码，采用自定义类型；</li>\n<li>新实现使用byte[]保存设备编码，采用的字符集编码单个字符占用空间应小于16bit。</li>\n</ol>\n<p>现在让我们看看类似的情况，别人都做了哪些工作：</p>\n<h4 id=\"JEP-254-Compact-Strings-3\"><a href=\"#JEP-254-Compact-Strings-3\" class=\"headerlink\" title=\"JEP 254: Compact Strings[3]\"></a>JEP 254: Compact Strings<sup id=\"fnref:3\" class=\"footnote-ref\"><a href=\"#fn:3\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"[JEP 254: Compact Strings](https://openjdk.org/jeps/254)\">[3]</span></a></sup></h4><p>实际上，早在JDK9，Java就实装了一项增强。JEP 254，压缩字符串，简单说来就是想办法用更节省空间的办法来表示字符串。参考原文描述</p>\n<blockquote>\n<p>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1&#x2F;Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p>\n<p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>\n<p>This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.</p>\n<p>The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.</p>\n<p>For further detail, see:</p>\n<ul>\n<li><a href=\"http://cr.openjdk.java.net/~shade/density/state-of-string-density-v1.txt\">State of String Density Performance</a></li>\n<li><a href=\"http://cr.openjdk.java.net/~huntch/string-density/reports/String-Density-SPARC-jbb2005-Report.pdf\">String Density Impact on SPECjbb2005 on SPARC</a></li>\n</ul>\n</blockquote>\n<p>从JDK9开始，String的内部实现会判断要表示的字符串能否用Latin-1编码，如果可以则使用Latin-1编码<sup id=\"fnref:4\" class=\"footnote-ref\"><a href=\"#fn:4\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"[ISO/IEC 8859-1/Latin-1](https://en.wikipedia.org/wiki/ISO/IEC_8859-1)\">[4]</span></a></sup>。Latin-1会占用8bit，刚好是UTF-16的一半。根据介绍，采用新的实现后证实内存使用量减少，GC活动大幅减少，以及某些极端情况下的性能轻微下降。</p>\n<h4 id=\"Netty-AsciiString\"><a href=\"#Netty-AsciiString\" class=\"headerlink\" title=\"Netty: AsciiString\"></a>Netty: AsciiString</h4><p>类似JEP254，其实高性能网络框架也对String有类似的改进。参考Netty对AsciiString类的注释：</p>\n<blockquote>\n<p>A string which has been encoded into a character encoding whose character always takes a single byte, similarly to ASCII. It internally keeps its content in a byte array unlike <code>String</code>, which uses a character array, for reduced memory footprint and faster data transfer from&#x2F;to byte-based data structures such as a byte array and <code>ByteBuffer</code>. It is often used in conjunction with Headers that require a <code>CharSequence</code>.</p>\n<p>This class was designed to provide an immutable array of bytes, and caches some internal state based upon the value of this array. However underlying access to this byte array is provided via not copying the array on construction or <code>array()</code>. If any changes are made to the underlying byte array it is the user’s responsibility to call <code>arrayChanged()</code> so the state of this class can be reset.</p>\n</blockquote>\n<p>这里的AsciiString通常被用在Netty内部表示请求的报文头这一类只会使用英文字符，数字，一些常见标点符号如“*”、“&#x2F;”等场景。使用ASCII编码可以减少内存占用，同时利用byte存储，还能在拷贝数据的时候减少操作，提高性能。</p>\n<h4 id=\"我们怎么办\"><a href=\"#我们怎么办\" class=\"headerlink\" title=\"我们怎么办?\"></a>我们怎么办?</h4><p>看过别人的解决方案之后，我们认识到：使用<code>byte[]</code>代替<code>char[]</code>是正确的方向，但是我们需要关注如何编码<code>byte[]</code>的问题。</p>\n<p><strong>为此，需要先确认一个字符可能出现多少种信息？</strong> 参考GB28181的设计以及实际运行中的dump分析结果，再结合netty的实践，我们可以得出结论：使用新的设计表示设备编码、各种命令、报文头信息收益最大，因为这些场景的字符仅限于a-z，A-Z，0-9和一些常见字符，可能得取值不会超过80种。</p>\n<p><strong>然后我们需要寻找一个合适的编码方式。</strong> 一个字符有80种可能性，则基于公式：</p>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">S = \\log_{2}N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.93858em;vertical-align:-0.24414em;\"></span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20696799999999996em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>\n\n<p>将N&#x3D;80带入后可知，S≈6.32，即需要至少7个bit才能表示这个字符的所有可能性。但为了方便通过下标找到对应的字符，所以使用一个byte（即8bit）表示。此时我们既可以学JEP5254，使用Latin-1，也可以学Netty用ASCII编码。因为在我们的输入条件下，最终都会被编码成一个byte。实际实现中，为了简化编码，直接在byte中保存char。</p>\n<p>参考代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceID</span> &#123;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">byte</span>[] value;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">DeviceID</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.value = parse(id);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">byte</span>[] parse(String id) &#123;<br>        <span class=\"hljs-type\">byte</span>[] value = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[id.length()];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; id.length(); i++) &#123;<br>            <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> id.charAt(i);<br>            <span class=\"hljs-keyword\">if</span> (!Character.isLetterOrDigit(c)) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;unsupported id: &quot;</span> + id);<br>            &#125;<br>            value[i] = (<span class=\"hljs-type\">byte</span>) c;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"借鉴领域驱动的概念解决大量重复问题\"><a href=\"#借鉴领域驱动的概念解决大量重复问题\" class=\"headerlink\" title=\"借鉴领域驱动的概念解决大量重复问题\"></a>借鉴领域驱动的概念解决大量重复问题</h3><p>熟悉DDD（领域驱动设计）的朋友们肯定知道一个概念，<strong>实体对象（EntityObject）</strong>。实体对象在系统内是唯一的，不论属性如何变化。而在GB28181的体系内，设备的id类似身份证号，是设备的唯一标识。设备的属性如在线状态可能变化，但是只要设备不被替换，其id不能改变。所以如果我们重写模块中的反序列化组件，让相同编码都指向一个对象引用，就可以保证系统内部不再出现重复的编码对象。</p>\n<p>这里我们对前面定义的DeviceID进行改造，内部新增一个缓存，用于记录系统内当前已有的DeviceID对象。当我们需要创建一个新的DeviceID时，先在缓存中查找是否已经创建值相同的DeviceID对象，如果有就返回已创建对象的引用，没有就创建个新的然后返回新创建对象的引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceID</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Map&lt;String, DeviceID&gt; referenceCache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>    <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">byte</span>[] value;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">DeviceID</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.value = parse(id);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> DeviceID <span class=\"hljs-title function_\">of</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> referenceCache.computeIfAbsent(id, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeviceID</span>(id));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>但这样设计存在几个问题：</p>\n<ol>\n<li>如前所述，String做key，空间利用太低，削弱了优化效果；</li>\n<li>当DeviceID对应的设备从系统中移除的时候，如何将DeviceID从缓存中驱逐；</li>\n<li>HashMap实现不是线程安全的，并发调用getOrDefault的时候方法可能会空转不返回。</li>\n<li>由于DeviceID会作为key，每次进行比对都会求一遍哈希值，对性能有负面影响</li>\n</ol>\n<p><strong>问题1</strong>，使用DeviceID替代String作为key是个不错的选择。这里我们本身就要返回DeviceID，那么key只存放对象引用显然划算的多。同时还能利用重写的hashcode与equals方法找到重复的对象。</p>\n<p><strong>问题2</strong>，可以采用两种办法：1）使用引用计数器，要求开发人员在不使用某个DeviceID的时候显式调用release方法，定时扫描引用计数器，为0的时候从缓存中移除对应DeviceID对象；2）参考ThreadLocal的设计，利用<strong>弱引用</strong>的机制，在GC的时候自动完成对应数据的清理动作。</p>\n<p>这里采用弱引用机制完成自动的数据清理动作。原因有3：</p>\n<ol>\n<li>引用计数器虽然逻辑简单，但是使用者必须在编写代码时记得释放，否则就会有泄露风险。旧代码改造变更太多，非常容易引入问题，也不利于代码检视。</li>\n<li>ThreadLocal的泄露风险在此案例中不存在</li>\n<li>可以直接使用WeakHashMap，不需要额外代码</li>\n</ol>\n<p><strong>问题3</strong>，虽然换用了WeakHashMap，但它也是线程不安全的，这里可以利用Collections.synchronizedMap简单创建一个同步的map来解决问题。</p>\n<p><strong>问题4</strong>，因为DeviceID对象本身设计为不可变对象，所以可以提前计算哈希值并保存，重写hashcode方法，令其返回保存的哈希值即可解决。</p>\n<p>完成修改后的参考代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceID</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">CharSequence</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Map&lt;DeviceID, WeakReference&lt;DeviceID&gt;&gt; cache =<br>            Collections.synchronizedMap(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakHashMap</span>&lt;&gt;());<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">byte</span>[] value;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> hash;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">DeviceID</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.value = parse(id);<br>        <span class=\"hljs-built_in\">this</span>.hash = hash(<span class=\"hljs-built_in\">this</span>.value);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">byte</span>[] parse(String id) &#123;<br>        <span class=\"hljs-type\">byte</span>[] value = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[id.length()];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; id.length(); i++) &#123;<br>            <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> id.charAt(i);<br>            <span class=\"hljs-keyword\">if</span> (!Character.isLetterOrDigit(c)) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;unsupported id: &quot;</span> + id);<br>            &#125;<br>            value[i] = (<span class=\"hljs-type\">byte</span>) c;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">hash</span><span class=\"hljs-params\">(<span class=\"hljs-type\">byte</span>[] value)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> Arrays.hashCode(value);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> DeviceID <span class=\"hljs-title function_\">of</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-type\">DeviceID</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeviceID</span>(id);<br>        <span class=\"hljs-keyword\">return</span> cache.computeIfAbsent(obj, k -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakReference</span>&lt;&gt;(obj)).get();<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">equals</span><span class=\"hljs-params\">(Object o)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span> == o) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">if</span> (!(o <span class=\"hljs-keyword\">instanceof</span> DeviceID deviceID)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">return</span> Arrays.equals(value, deviceID.value);<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">hashCode</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> hash;<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">length</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.value.length;<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">char</span> <span class=\"hljs-title function_\">charAt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">char</span>) <span class=\"hljs-built_in\">this</span>.value[index];<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">subSequence</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> start, <span class=\"hljs-type\">int</span> end)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> toString(start, end);<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> toString(<span class=\"hljs-number\">0</span>, length());<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> start, <span class=\"hljs-type\">int</span> end)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (start &lt; <span class=\"hljs-number\">0</span> || end &gt; length() || start &gt; end) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IndexOutOfBoundsException</span>();<br>        &#125;<br>        <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> start; i &lt; end; i++) &#123;<br>            sb.append((<span class=\"hljs-type\">char</span>) <span class=\"hljs-built_in\">this</span>.value[i]);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"实际效果\"><a href=\"#实际效果\" class=\"headerlink\" title=\"实际效果\"></a>实际效果</h2><h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><p>下面将通过测试用例验证字符串压缩和缓存自动回收的结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 不GC，多次将值相同但不是同实例的字符串传入DeviceID.of方法，获得的DeviceID实例相同</span><br><span class=\"hljs-comment\"> * */</span><br><span class=\"hljs-meta\">@Test</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">should_return_same_instance_after_create</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">code1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;01010020002001234567&quot;</span>;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">code2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(code1);<br>    assertNotEquals(System.identityHashCode(code1), System.identityHashCode(code2));<br>    <span class=\"hljs-type\">DeviceID</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> DeviceID.of(code1);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> System.identityHashCode(id);<br>    id = DeviceID.of(code2);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">second</span> <span class=\"hljs-operator\">=</span> System.identityHashCode(id);<br>    assertEquals(first, second);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 一段字符串实例，创建DeviceID对象后移除强引用，然后GC，再次使用该字符串创建DeviceID对象，两次得到的DeviceID对象是不同实例</span><br><span class=\"hljs-comment\"> * */</span><br><span class=\"hljs-meta\">@Test</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">should_return_new_instance_after_gc</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">code</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;01010020002001234567&quot;</span>;<br>    <span class=\"hljs-type\">DeviceID</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> DeviceID.of(code);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> System.identityHashCode(id);<br>    id = <span class=\"hljs-literal\">null</span>;<br>    System.gc();<br>    id = DeviceID.of(code);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">second</span> <span class=\"hljs-operator\">=</span> System.identityHashCode(id);<br>    assertNotEquals(first, second);<br>&#125;<br><br><span class=\"hljs-meta\">@Test</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">should_be_thread_safe_when_create_in_multi_thread</span><span class=\"hljs-params\">()</span> &#123;<br>    Callable&lt;List&lt;DeviceID&gt;&gt; callable = () -&gt; Stream.generate(UUID::randomUUID)<br>            .map(UUID::toString)<br>            .distinct()<br>            .limit(<span class=\"hljs-number\">100</span>)<br>            .map(DeviceID::of)<br>            .toList();<br>    <span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">10</span>);<br>    List&lt;Callable&lt;List&lt;DeviceID&gt;&gt;&gt; tasks = Stream.generate(() -&gt; callable).limit(<span class=\"hljs-number\">10</span>).toList();<br>    await().atMost(Duration.ofSeconds(<span class=\"hljs-number\">2</span>)).untilAsserted(() -&gt; &#123;<br>        List&lt;Future&lt;List&lt;DeviceID&gt;&gt;&gt; futures = executor.invokeAll(tasks);<br>        futures.forEach(future -&gt; assertTrue(future.isDone()));<br>    &#125;);<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>特殊的：下面这个用例只有在未包含JEP254的jdk8及老版本才能执行成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Test</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">size_should_less_than_string</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">code</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;01010020002001234567&quot;</span>;<br>    <span class=\"hljs-type\">DeviceID</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> DeviceID.of(code);<br>    System.out.println(GraphLayout.parseInstance(code).toFootprint());<br>    System.out.println(GraphLayout.parseInstance(id).toFootprint());<br>    assertTrue(GraphLayout.parseInstance(code).totalSize() &gt; GraphLayout.parseInstance(id).totalSize());<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在JDK8中会有如下输出，可以看到对20位编码，一个实例下新类可以降低20%的总内存占用</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs console\">java.lang.String@4f638935d footprint:<br>     COUNT       AVG       SUM   DESCRIPTION<br>         1        56        56   [C<br>         1        24        24   java.lang.String<br>         2                  80   (total)<br><br><br>io.firestige.iris.DeviceID@7c417213d footprint:<br>     COUNT       AVG       SUM   DESCRIPTION<br>         1        40        40   [B<br>         1        24        24   io.firestige.iris.DeviceID<br>         2                  64   (total)<br></code></pre></td></tr></table></figure>\n\n<p>当code的长度变为40时（实际使用中有时会将设备编码和域编码拼接），新的类可以节省33.33%内存空间</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs console\">java.lang.String@4f638935d footprint:<br>     COUNT       AVG       SUM   DESCRIPTION<br>         1        96        96   [C<br>         1        24        24   java.lang.String<br>         2                 120   (total)<br><br><br>io.firestige.iris.DeviceID@7880cdf3d footprint:<br>     COUNT       AVG       SUM   DESCRIPTION<br>         1        56        56   [B<br>         1        24        24   io.firestige.iris.DeviceID<br>         2                  80   (total)<br></code></pre></td></tr></table></figure>\n\n<p>即随着字符串越来越长，对象头占用空间对实例占用内存的贡献降低，新类的压缩率会逐渐上升，最终可以节省接近50%内存空间。</p>\n<h3 id=\"dump对比\"><a href=\"#dump对比\" class=\"headerlink\" title=\"dump对比\"></a>dump对比</h3><p>通过dump的分析结果，我们可以很明显的看到总的内存占用降低，重复字符串的消失。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>改动前</th>\n<th>改动后</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>重复字符串分析</td>\n<td><img src=\"/img/remove-redundant-and-compact-string/repeated-string.png\" alt=\"重复字符串分析\"></td>\n<td><img src=\"/img/remove-redundant-and-compact-string/repeated-string-2.png\" alt=\"重复字符串分析\"></td>\n</tr>\n<tr>\n<td>老年代总量对比</td>\n<td><img src=\"/img/remove-redundant-and-compact-string/dump-1.png\" alt=\"老年代总量对比\"></td>\n<td><img src=\"/img/remove-redundant-and-compact-string/dump-2.png\" alt=\"老年代总量对比\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><section class=\"footnotes\"><div class=\"footnote-list\"><ol><li><span id=\"fn:1\" class=\"footnote-text\"><span><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html#:~:text=char%3A%20The%20char%20data%20type,'%20(or%2065%2C535%20inclusive)\">The Java™ Tutorials</a>.\n<a href=\"#fnref:1\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:2\" class=\"footnote-text\"><span><a href=\"https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=8BBC2475624A6C31DC34A28052B3923D\">GB&#x2F;T 28181-2022, 公共安全视频监控联网系统信息传输、交换、控制技术要求</a>\n<a href=\"#fnref:2\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:3\" class=\"footnote-text\"><span><a href=\"https://openjdk.org/jeps/254\">JEP 254: Compact Strings</a>\n<a href=\"#fnref:3\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:4\" class=\"footnote-text\"><span><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">ISO&#x2F;IEC 8859-1&#x2F;Latin-1</a>\n<a href=\"#fnref:4\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li></ol></div></section>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><em>请注意：案例中关键信息已经被匿名化处理</em></p>\n</blockquote>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>上一轮质量改进分析内存堆栈发现，运行时堆内存会驻留大量重复字符串。一段长度20个ASCII字符的设备编码，在系统中最多可能出现m个内容相同的字符串实例（m是系统最大管理设备数量，量级：百万）。这造成堆内存空间极大浪费，大量的冗余数据将本该用于支撑业务运行的空间占用，导致系统的设备管理规格上不去，成本下不来，对友商的竞争力降低。</p>\n<blockquote>\n<p>以下数据为场景模拟，不包含产品代码，也不是生产环境上获取的dump，仅用于现象说明</p>\n</blockquote>\n<p><img src=\"/img/remove-redundant-and-compact-string/dump-1.png\" alt=\"200万设备500万字符串\"><br><img src=\"/img/remove-redundant-and-compact-string/model.svg\" alt=\"示例设备对象模型\"><br>可以看到，String实例数量达到设备实例数量的2.5倍。<br><img src=\"/img/remove-redundant-and-compact-string/repeated-string.png\" alt=\"原理模拟，非生产环境数据\"><br>通过jprofile分析，明显发现大量编码重复。</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><h3 id=\"为什么有重复\"><a href=\"#为什么有重复\" class=\"headerlink\" title=\"为什么有重复\"></a>为什么有重复</h3><p>由于模块负责GB28181协议中目录树功能，有大量层次化数据，即目录和目录下的设备。这些数据会驻留在内存中共查询和修改，数据之间的关系通过<code>ParentID</code>以及<code>externalDomainID</code>来表示。下面是个多层目录的示意图：<br><img src=\"/img/remove-redundant-and-compact-string/catalog-tree.svg\" alt=\"行政区划-业务分组设备树示意图\"><br>可以很明显看出，每个节点都会持有一个指向父节点和指向根节点的指针。这个指针实际使用以对应元素的id来表示并用String来保存。由于每次反序列化时都是创建一个新的String对象，所以堆内存中有多少个设备对象，就会有多少个重复的指向根节点的id，以及指向不同父节点的id。</p>\n<h3 id=\"还有没有其他问题\"><a href=\"#还有没有其他问题\" class=\"headerlink\" title=\"还有没有其他问题\"></a>还有没有其他问题</h3><p>编码用String保存，还有没有优化空间呢？查看JDK8的源码，String对象内部使用char[]保存数据，而单个char使用16bit Unicode保存。<sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html#:~:text=char%3A%20The%20char%20data%20type,'%20(or%2065%2C535%20inclusive)).\">[1]</span></a></sup></p>\n<blockquote>\n<p>char: The char data type is a single 16-bit Unicode character. It has a minimum value of <code>\\u0000</code> (or 0) and a maximum value of <code>\\uffff</code> (or 65,535 inclusive).</p>\n</blockquote>\n<p>可是，按照<strong>GB28181-2022附录E 统一编码规则</strong><sup id=\"fnref:2\" class=\"footnote-ref\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"[GB/T 28181-2022, 公共安全视频监控联网系统信息传输、交换、控制技术要求](https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=8BBC2475624A6C31DC34A28052B3923D)\">[2]</span></a></sup>的描述，编码仅会使用0到9的数字。即编码中单个字符仅需要4bit, 即<code>\\u0</code>到<code>\\uf</code>，就可以表示。所以使用String保存编码，实际上会造成大量空间浪费，利用率只有25%。我们需要一种新的方法来存储编码。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用\"><a href=\"#在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用\" class=\"headerlink\" title=\"在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用\"></a>在JDK8的环境下，提供一种新的实现，降低设备编码在系统中内存占用</h3><p>首先，我们要确立初步目标：</p>\n<ol>\n<li>不再使用String保存设备编码，采用自定义类型；</li>\n<li>新实现使用byte[]保存设备编码，采用的字符集编码单个字符占用空间应小于16bit。</li>\n</ol>\n<p>现在让我们看看类似的情况，别人都做了哪些工作：</p>\n<h4 id=\"JEP-254-Compact-Strings-3\"><a href=\"#JEP-254-Compact-Strings-3\" class=\"headerlink\" title=\"JEP 254: Compact Strings[3]\"></a>JEP 254: Compact Strings<sup id=\"fnref:3\" class=\"footnote-ref\"><a href=\"#fn:3\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"[JEP 254: Compact Strings](https://openjdk.org/jeps/254)\">[3]</span></a></sup></h4><p>实际上，早在JDK9，Java就实装了一项增强。JEP 254，压缩字符串，简单说来就是想办法用更节省空间的办法来表示字符串。参考原文描述</p>\n<blockquote>\n<p>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1&#x2F;Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p>\n<p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>\n<p>This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.</p>\n<p>The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.</p>\n<p>For further detail, see:</p>\n<ul>\n<li><a href=\"http://cr.openjdk.java.net/~shade/density/state-of-string-density-v1.txt\">State of String Density Performance</a></li>\n<li><a href=\"http://cr.openjdk.java.net/~huntch/string-density/reports/String-Density-SPARC-jbb2005-Report.pdf\">String Density Impact on SPECjbb2005 on SPARC</a></li>\n</ul>\n</blockquote>\n<p>从JDK9开始，String的内部实现会判断要表示的字符串能否用Latin-1编码，如果可以则使用Latin-1编码<sup id=\"fnref:4\" class=\"footnote-ref\"><a href=\"#fn:4\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"[ISO/IEC 8859-1/Latin-1](https://en.wikipedia.org/wiki/ISO/IEC_8859-1)\">[4]</span></a></sup>。Latin-1会占用8bit，刚好是UTF-16的一半。根据介绍，采用新的实现后证实内存使用量减少，GC活动大幅减少，以及某些极端情况下的性能轻微下降。</p>\n<h4 id=\"Netty-AsciiString\"><a href=\"#Netty-AsciiString\" class=\"headerlink\" title=\"Netty: AsciiString\"></a>Netty: AsciiString</h4><p>类似JEP254，其实高性能网络框架也对String有类似的改进。参考Netty对AsciiString类的注释：</p>\n<blockquote>\n<p>A string which has been encoded into a character encoding whose character always takes a single byte, similarly to ASCII. It internally keeps its content in a byte array unlike <code>String</code>, which uses a character array, for reduced memory footprint and faster data transfer from&#x2F;to byte-based data structures such as a byte array and <code>ByteBuffer</code>. It is often used in conjunction with Headers that require a <code>CharSequence</code>.</p>\n<p>This class was designed to provide an immutable array of bytes, and caches some internal state based upon the value of this array. However underlying access to this byte array is provided via not copying the array on construction or <code>array()</code>. If any changes are made to the underlying byte array it is the user’s responsibility to call <code>arrayChanged()</code> so the state of this class can be reset.</p>\n</blockquote>\n<p>这里的AsciiString通常被用在Netty内部表示请求的报文头这一类只会使用英文字符，数字，一些常见标点符号如“*”、“&#x2F;”等场景。使用ASCII编码可以减少内存占用，同时利用byte存储，还能在拷贝数据的时候减少操作，提高性能。</p>\n<h4 id=\"我们怎么办\"><a href=\"#我们怎么办\" class=\"headerlink\" title=\"我们怎么办?\"></a>我们怎么办?</h4><p>看过别人的解决方案之后，我们认识到：使用<code>byte[]</code>代替<code>char[]</code>是正确的方向，但是我们需要关注如何编码<code>byte[]</code>的问题。</p>\n<p><strong>为此，需要先确认一个字符可能出现多少种信息？</strong> 参考GB28181的设计以及实际运行中的dump分析结果，再结合netty的实践，我们可以得出结论：使用新的设计表示设备编码、各种命令、报文头信息收益最大，因为这些场景的字符仅限于a-z，A-Z，0-9和一些常见字符，可能得取值不会超过80种。</p>\n<p><strong>然后我们需要寻找一个合适的编码方式。</strong> 一个字符有80种可能性，则基于公式：</p>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">S = \\log_{2}N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.93858em;vertical-align:-0.24414em;\"></span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20696799999999996em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>\n\n<p>将N&#x3D;80带入后可知，S≈6.32，即需要至少7个bit才能表示这个字符的所有可能性。但为了方便通过下标找到对应的字符，所以使用一个byte（即8bit）表示。此时我们既可以学JEP5254，使用Latin-1，也可以学Netty用ASCII编码。因为在我们的输入条件下，最终都会被编码成一个byte。实际实现中，为了简化编码，直接在byte中保存char。</p>\n<p>参考代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceID</span> &#123;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">byte</span>[] value;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">DeviceID</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.value = parse(id);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">byte</span>[] parse(String id) &#123;<br>        <span class=\"hljs-type\">byte</span>[] value = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[id.length()];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; id.length(); i++) &#123;<br>            <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> id.charAt(i);<br>            <span class=\"hljs-keyword\">if</span> (!Character.isLetterOrDigit(c)) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;unsupported id: &quot;</span> + id);<br>            &#125;<br>            value[i] = (<span class=\"hljs-type\">byte</span>) c;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"借鉴领域驱动的概念解决大量重复问题\"><a href=\"#借鉴领域驱动的概念解决大量重复问题\" class=\"headerlink\" title=\"借鉴领域驱动的概念解决大量重复问题\"></a>借鉴领域驱动的概念解决大量重复问题</h3><p>熟悉DDD（领域驱动设计）的朋友们肯定知道一个概念，<strong>实体对象（EntityObject）</strong>。实体对象在系统内是唯一的，不论属性如何变化。而在GB28181的体系内，设备的id类似身份证号，是设备的唯一标识。设备的属性如在线状态可能变化，但是只要设备不被替换，其id不能改变。所以如果我们重写模块中的反序列化组件，让相同编码都指向一个对象引用，就可以保证系统内部不再出现重复的编码对象。</p>\n<p>这里我们对前面定义的DeviceID进行改造，内部新增一个缓存，用于记录系统内当前已有的DeviceID对象。当我们需要创建一个新的DeviceID时，先在缓存中查找是否已经创建值相同的DeviceID对象，如果有就返回已创建对象的引用，没有就创建个新的然后返回新创建对象的引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceID</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Map&lt;String, DeviceID&gt; referenceCache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>    <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">byte</span>[] value;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">DeviceID</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.value = parse(id);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> DeviceID <span class=\"hljs-title function_\">of</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> referenceCache.computeIfAbsent(id, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeviceID</span>(id));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>但这样设计存在几个问题：</p>\n<ol>\n<li>如前所述，String做key，空间利用太低，削弱了优化效果；</li>\n<li>当DeviceID对应的设备从系统中移除的时候，如何将DeviceID从缓存中驱逐；</li>\n<li>HashMap实现不是线程安全的，并发调用getOrDefault的时候方法可能会空转不返回。</li>\n<li>由于DeviceID会作为key，每次进行比对都会求一遍哈希值，对性能有负面影响</li>\n</ol>\n<p><strong>问题1</strong>，使用DeviceID替代String作为key是个不错的选择。这里我们本身就要返回DeviceID，那么key只存放对象引用显然划算的多。同时还能利用重写的hashcode与equals方法找到重复的对象。</p>\n<p><strong>问题2</strong>，可以采用两种办法：1）使用引用计数器，要求开发人员在不使用某个DeviceID的时候显式调用release方法，定时扫描引用计数器，为0的时候从缓存中移除对应DeviceID对象；2）参考ThreadLocal的设计，利用<strong>弱引用</strong>的机制，在GC的时候自动完成对应数据的清理动作。</p>\n<p>这里采用弱引用机制完成自动的数据清理动作。原因有3：</p>\n<ol>\n<li>引用计数器虽然逻辑简单，但是使用者必须在编写代码时记得释放，否则就会有泄露风险。旧代码改造变更太多，非常容易引入问题，也不利于代码检视。</li>\n<li>ThreadLocal的泄露风险在此案例中不存在</li>\n<li>可以直接使用WeakHashMap，不需要额外代码</li>\n</ol>\n<p><strong>问题3</strong>，虽然换用了WeakHashMap，但它也是线程不安全的，这里可以利用Collections.synchronizedMap简单创建一个同步的map来解决问题。</p>\n<p><strong>问题4</strong>，因为DeviceID对象本身设计为不可变对象，所以可以提前计算哈希值并保存，重写hashcode方法，令其返回保存的哈希值即可解决。</p>\n<p>完成修改后的参考代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceID</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">CharSequence</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Map&lt;DeviceID, WeakReference&lt;DeviceID&gt;&gt; cache =<br>            Collections.synchronizedMap(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakHashMap</span>&lt;&gt;());<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">byte</span>[] value;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> hash;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">DeviceID</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.value = parse(id);<br>        <span class=\"hljs-built_in\">this</span>.hash = hash(<span class=\"hljs-built_in\">this</span>.value);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">byte</span>[] parse(String id) &#123;<br>        <span class=\"hljs-type\">byte</span>[] value = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[id.length()];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; id.length(); i++) &#123;<br>            <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> id.charAt(i);<br>            <span class=\"hljs-keyword\">if</span> (!Character.isLetterOrDigit(c)) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;unsupported id: &quot;</span> + id);<br>            &#125;<br>            value[i] = (<span class=\"hljs-type\">byte</span>) c;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">hash</span><span class=\"hljs-params\">(<span class=\"hljs-type\">byte</span>[] value)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> Arrays.hashCode(value);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> DeviceID <span class=\"hljs-title function_\">of</span><span class=\"hljs-params\">(String id)</span> &#123;<br>        <span class=\"hljs-type\">DeviceID</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeviceID</span>(id);<br>        <span class=\"hljs-keyword\">return</span> cache.computeIfAbsent(obj, k -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakReference</span>&lt;&gt;(obj)).get();<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">equals</span><span class=\"hljs-params\">(Object o)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span> == o) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">if</span> (!(o <span class=\"hljs-keyword\">instanceof</span> DeviceID deviceID)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">return</span> Arrays.equals(value, deviceID.value);<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">hashCode</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> hash;<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">length</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.value.length;<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">char</span> <span class=\"hljs-title function_\">charAt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">char</span>) <span class=\"hljs-built_in\">this</span>.value[index];<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">subSequence</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> start, <span class=\"hljs-type\">int</span> end)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> toString(start, end);<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> toString(<span class=\"hljs-number\">0</span>, length());<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> start, <span class=\"hljs-type\">int</span> end)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (start &lt; <span class=\"hljs-number\">0</span> || end &gt; length() || start &gt; end) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IndexOutOfBoundsException</span>();<br>        &#125;<br>        <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> start; i &lt; end; i++) &#123;<br>            sb.append((<span class=\"hljs-type\">char</span>) <span class=\"hljs-built_in\">this</span>.value[i]);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"实际效果\"><a href=\"#实际效果\" class=\"headerlink\" title=\"实际效果\"></a>实际效果</h2><h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><p>下面将通过测试用例验证字符串压缩和缓存自动回收的结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 不GC，多次将值相同但不是同实例的字符串传入DeviceID.of方法，获得的DeviceID实例相同</span><br><span class=\"hljs-comment\"> * */</span><br><span class=\"hljs-meta\">@Test</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">should_return_same_instance_after_create</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">code1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;01010020002001234567&quot;</span>;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">code2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(code1);<br>    assertNotEquals(System.identityHashCode(code1), System.identityHashCode(code2));<br>    <span class=\"hljs-type\">DeviceID</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> DeviceID.of(code1);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> System.identityHashCode(id);<br>    id = DeviceID.of(code2);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">second</span> <span class=\"hljs-operator\">=</span> System.identityHashCode(id);<br>    assertEquals(first, second);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 一段字符串实例，创建DeviceID对象后移除强引用，然后GC，再次使用该字符串创建DeviceID对象，两次得到的DeviceID对象是不同实例</span><br><span class=\"hljs-comment\"> * */</span><br><span class=\"hljs-meta\">@Test</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">should_return_new_instance_after_gc</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">code</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;01010020002001234567&quot;</span>;<br>    <span class=\"hljs-type\">DeviceID</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> DeviceID.of(code);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> System.identityHashCode(id);<br>    id = <span class=\"hljs-literal\">null</span>;<br>    System.gc();<br>    id = DeviceID.of(code);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">second</span> <span class=\"hljs-operator\">=</span> System.identityHashCode(id);<br>    assertNotEquals(first, second);<br>&#125;<br><br><span class=\"hljs-meta\">@Test</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">should_be_thread_safe_when_create_in_multi_thread</span><span class=\"hljs-params\">()</span> &#123;<br>    Callable&lt;List&lt;DeviceID&gt;&gt; callable = () -&gt; Stream.generate(UUID::randomUUID)<br>            .map(UUID::toString)<br>            .distinct()<br>            .limit(<span class=\"hljs-number\">100</span>)<br>            .map(DeviceID::of)<br>            .toList();<br>    <span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">10</span>);<br>    List&lt;Callable&lt;List&lt;DeviceID&gt;&gt;&gt; tasks = Stream.generate(() -&gt; callable).limit(<span class=\"hljs-number\">10</span>).toList();<br>    await().atMost(Duration.ofSeconds(<span class=\"hljs-number\">2</span>)).untilAsserted(() -&gt; &#123;<br>        List&lt;Future&lt;List&lt;DeviceID&gt;&gt;&gt; futures = executor.invokeAll(tasks);<br>        futures.forEach(future -&gt; assertTrue(future.isDone()));<br>    &#125;);<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>特殊的：下面这个用例只有在未包含JEP254的jdk8及老版本才能执行成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Test</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">size_should_less_than_string</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">code</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;01010020002001234567&quot;</span>;<br>    <span class=\"hljs-type\">DeviceID</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> DeviceID.of(code);<br>    System.out.println(GraphLayout.parseInstance(code).toFootprint());<br>    System.out.println(GraphLayout.parseInstance(id).toFootprint());<br>    assertTrue(GraphLayout.parseInstance(code).totalSize() &gt; GraphLayout.parseInstance(id).totalSize());<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在JDK8中会有如下输出，可以看到对20位编码，一个实例下新类可以降低20%的总内存占用</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs console\">java.lang.String@4f638935d footprint:<br>     COUNT       AVG       SUM   DESCRIPTION<br>         1        56        56   [C<br>         1        24        24   java.lang.String<br>         2                  80   (total)<br><br><br>io.firestige.iris.DeviceID@7c417213d footprint:<br>     COUNT       AVG       SUM   DESCRIPTION<br>         1        40        40   [B<br>         1        24        24   io.firestige.iris.DeviceID<br>         2                  64   (total)<br></code></pre></td></tr></table></figure>\n\n<p>当code的长度变为40时（实际使用中有时会将设备编码和域编码拼接），新的类可以节省33.33%内存空间</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs console\">java.lang.String@4f638935d footprint:<br>     COUNT       AVG       SUM   DESCRIPTION<br>         1        96        96   [C<br>         1        24        24   java.lang.String<br>         2                 120   (total)<br><br><br>io.firestige.iris.DeviceID@7880cdf3d footprint:<br>     COUNT       AVG       SUM   DESCRIPTION<br>         1        56        56   [B<br>         1        24        24   io.firestige.iris.DeviceID<br>         2                  80   (total)<br></code></pre></td></tr></table></figure>\n\n<p>即随着字符串越来越长，对象头占用空间对实例占用内存的贡献降低，新类的压缩率会逐渐上升，最终可以节省接近50%内存空间。</p>\n<h3 id=\"dump对比\"><a href=\"#dump对比\" class=\"headerlink\" title=\"dump对比\"></a>dump对比</h3><p>通过dump的分析结果，我们可以很明显的看到总的内存占用降低，重复字符串的消失。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>改动前</th>\n<th>改动后</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>重复字符串分析</td>\n<td><img src=\"/img/remove-redundant-and-compact-string/repeated-string.png\" alt=\"重复字符串分析\"></td>\n<td><img src=\"/img/remove-redundant-and-compact-string/repeated-string-2.png\" alt=\"重复字符串分析\"></td>\n</tr>\n<tr>\n<td>老年代总量对比</td>\n<td><img src=\"/img/remove-redundant-and-compact-string/dump-1.png\" alt=\"老年代总量对比\"></td>\n<td><img src=\"/img/remove-redundant-and-compact-string/dump-2.png\" alt=\"老年代总量对比\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><section class=\"footnotes\"><div class=\"footnote-list\"><ol><li><span id=\"fn:1\" class=\"footnote-text\"><span><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html#:~:text=char%3A%20The%20char%20data%20type,'%20(or%2065%2C535%20inclusive)\">The Java™ Tutorials</a>.\n<a href=\"#fnref:1\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:2\" class=\"footnote-text\"><span><a href=\"https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=8BBC2475624A6C31DC34A28052B3923D\">GB&#x2F;T 28181-2022, 公共安全视频监控联网系统信息传输、交换、控制技术要求</a>\n<a href=\"#fnref:2\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:3\" class=\"footnote-text\"><span><a href=\"https://openjdk.org/jeps/254\">JEP 254: Compact Strings</a>\n<a href=\"#fnref:3\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:4\" class=\"footnote-text\"><span><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">ISO&#x2F;IEC 8859-1&#x2F;Latin-1</a>\n<a href=\"#fnref:4\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li></ol></div></section>"},{"title":"从零开始的golang编程（day0）","date":"2023-09-01T16:00:00.000Z","_content":"\n## 背景\n\n虽然被部门安排去搞解决方案，转型胶片工程师，但我果然还是喜欢写代码。写了五年java，想换换口味，打算开个新坑，用一个项目完成go的入门。刚好每周都要去漫画网站还有番剧网站扫货，可是下载、归档、观赏总是要多个不同的应用衔接。尤其在归档和检索资源的时候，总需要大量人工。后续家里搞起媒体中心之后，多端观看也是问题。不如趁此机会实践一番，所以项目就这样启动啦。\n\n## 目标\n\n1. 定位家庭数据中心管理软件，负责多媒体、游戏库等数字资源的存储、归档工作。\n2. 支持图片、音乐、视频的全平台在线播放\n3. 提供steam游戏库CDN加速能力，maven库，node源等常用仓库代理缓存的能力\n4. 支持http和torrent下载\n5. 支持断点续传，支持多任务多分片同时下载\n6. 可以对图片文件进行分类，打标签\n7. 提供任务编排能力，允许配置图片，文本，torrent文件自动下载，分析归档任务\n8. 支持配置周期任务，进行重点数据的归档，压缩和冷备份\n9. 存储支持NAS或者OSS\n\n## 架构设计\n\n架构图待补\n","source":"_posts/go-downloader-0.md","raw":"---\ntitle: 从零开始的golang编程（day0）\ndate: 2023-9-2\ntag:\n  - go\n  - home-center\n  - go-downloader\n  - 编程日志\n---\n\n## 背景\n\n虽然被部门安排去搞解决方案，转型胶片工程师，但我果然还是喜欢写代码。写了五年java，想换换口味，打算开个新坑，用一个项目完成go的入门。刚好每周都要去漫画网站还有番剧网站扫货，可是下载、归档、观赏总是要多个不同的应用衔接。尤其在归档和检索资源的时候，总需要大量人工。后续家里搞起媒体中心之后，多端观看也是问题。不如趁此机会实践一番，所以项目就这样启动啦。\n\n## 目标\n\n1. 定位家庭数据中心管理软件，负责多媒体、游戏库等数字资源的存储、归档工作。\n2. 支持图片、音乐、视频的全平台在线播放\n3. 提供steam游戏库CDN加速能力，maven库，node源等常用仓库代理缓存的能力\n4. 支持http和torrent下载\n5. 支持断点续传，支持多任务多分片同时下载\n6. 可以对图片文件进行分类，打标签\n7. 提供任务编排能力，允许配置图片，文本，torrent文件自动下载，分析归档任务\n8. 支持配置周期任务，进行重点数据的归档，压缩和冷备份\n9. 存储支持NAS或者OSS\n\n## 架构设计\n\n架构图待补\n","slug":"go-downloader-0","published":1,"updated":"2024-05-19T14:10:14.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clx9h4k2r0000cotg82mm0679","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>虽然被部门安排去搞解决方案，转型胶片工程师，但我果然还是喜欢写代码。写了五年java，想换换口味，打算开个新坑，用一个项目完成go的入门。刚好每周都要去漫画网站还有番剧网站扫货，可是下载、归档、观赏总是要多个不同的应用衔接。尤其在归档和检索资源的时候，总需要大量人工。后续家里搞起媒体中心之后，多端观看也是问题。不如趁此机会实践一番，所以项目就这样启动啦。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><ol>\n<li>定位家庭数据中心管理软件，负责多媒体、游戏库等数字资源的存储、归档工作。</li>\n<li>支持图片、音乐、视频的全平台在线播放</li>\n<li>提供steam游戏库CDN加速能力，maven库，node源等常用仓库代理缓存的能力</li>\n<li>支持http和torrent下载</li>\n<li>支持断点续传，支持多任务多分片同时下载</li>\n<li>可以对图片文件进行分类，打标签</li>\n<li>提供任务编排能力，允许配置图片，文本，torrent文件自动下载，分析归档任务</li>\n<li>支持配置周期任务，进行重点数据的归档，压缩和冷备份</li>\n<li>存储支持NAS或者OSS</li>\n</ol>\n<h2 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h2><p>架构图待补</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>虽然被部门安排去搞解决方案，转型胶片工程师，但我果然还是喜欢写代码。写了五年java，想换换口味，打算开个新坑，用一个项目完成go的入门。刚好每周都要去漫画网站还有番剧网站扫货，可是下载、归档、观赏总是要多个不同的应用衔接。尤其在归档和检索资源的时候，总需要大量人工。后续家里搞起媒体中心之后，多端观看也是问题。不如趁此机会实践一番，所以项目就这样启动啦。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><ol>\n<li>定位家庭数据中心管理软件，负责多媒体、游戏库等数字资源的存储、归档工作。</li>\n<li>支持图片、音乐、视频的全平台在线播放</li>\n<li>提供steam游戏库CDN加速能力，maven库，node源等常用仓库代理缓存的能力</li>\n<li>支持http和torrent下载</li>\n<li>支持断点续传，支持多任务多分片同时下载</li>\n<li>可以对图片文件进行分类，打标签</li>\n<li>提供任务编排能力，允许配置图片，文本，torrent文件自动下载，分析归档任务</li>\n<li>支持配置周期任务，进行重点数据的归档，压缩和冷备份</li>\n<li>存储支持NAS或者OSS</li>\n</ol>\n<h2 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h2><p>架构图待补</p>\n"},{"title":"垃圾回收的算法与实现学习笔记——基本概念","date":"2023-10-11T08:41:00.000Z","_content":"## 对象\n\n- 不同于OOP，这里的对象指的是应用程序使用的数据的集合。\n- 对象配置在内存空间里。\n- 对象时GC的基本运作单位\n\n一般说来，对象由头（`Header`）和域（`Field`）构成\n\n### 头\n\n对象中保存对象本身信息的部分称为头，主要包含：\n- 对象的大小\n- 对象的种类\n\n### 域\n\n对象使用者在对象中可访问的部分称为域。\n\n> 可以将域理解为java中class的成员变量，如\n> class A {\n>   int val;\n> }\n> 若有A的实例a，则a.val就是对象a的域\n\n域的值有两种：\n- 指针\n- 非指针\n\n指针就是执行啊内存空间中某块区域的值，C语言中有明确的指针类型，java则没有。对于没有暴露指针的语言，可以将其理解为引用\n\n非指针值得是在编程过程中直接使用值本身，比如java中的int、bool等都是非指针。\n\n## 指针\n\nGC程序通过指针找到需要销毁或者保留对象，另一方面GC程序不处理非指针。\n\n有两点需要注意：\n\n- 程序是否能判别指针和非指针\n- 指针会指向对象的哪个部分\n\n## Mutator\n\n如果说GC程序负责回收垃圾，那么mutator就是负责创建对象的程序\n\nmutator实际进行的操作有以下两种：\n- 生成对象\n- 更新指针\n\n## 堆\n\n堆是用于动态存放对象的内存空间。当mutator申请存放对象时，所需内存空间会从这个堆中被分配给mutator。\n\n## 活动对象/非活动对象\n\n堆中能被mutator引用的对象称为“活动对象”；堆中不能通过遍历引用访问到的对象称为“非活动对象”。换言之，这些“非活动对象”就是“垃圾”。\n\n>需要注意，成为垃圾的对象不能活过来，因为mutator再也找不到它。\n\n## 分配\n\n当mutator需要创建新对象时，就会向allocator申请一个大小合适的空间。而allocator在堆的可用空间中寻找满足要求的连续空间，并返回给mutator。\n\n## 分块\n\n分块（chunk）在这里指的是为利用对象而事分配好的单元。\n\n初始状态下，堆被一个大的分块所占据\n\n程序会根据mutator的要求把这个分块分割成合适的大小，作为（活动）对象使用。\n\n内存里的各个区块都重复着分块-〉活动对象-〉垃圾（非活动对象）-〉分块-〉……这样的过程\n\n## 根\n\n根是指向对象的指针的“起点”部分。\n\n## 评价标准\n\n### 吞吐量\n\n一般意义上，吞吐量指的是“在单位时间内的处理能力”。\n\n即便是同一GC算法，其吞吐量也是受mutator的动作左右的。评价GC算法的吞吐量，有必要吧mutator的动作考虑在内。\n\n### 最大暂停时间\n\n最大暂停时间指的是“因执行GC而暂停执行mutator的最长时间”\n\n> 不管尝试哪种GC算法，大吞吐量和低延迟不可兼得\n\n### 堆使用率\n\n左右堆使用效率的因素有二，对象头的大小和调度堆空间的算法。\n\n> 不可能三角：堆使用效率，吞吐量和最大延迟不能兼顾\n\n### 访问的局部性\n\n根据局部性原理，把有引用关系的对象安排在堆中较近的位置可以提高读取效率，提高mutator的运行速度。\n","source":"_posts/gc-review-1.md","raw":"---\ntitle: 垃圾回收的算法与实现学习笔记——基本概念\ndate: 2023-10-11 16:41:00\ntag:\n  - GC\n  - 学习笔记\n  - 垃圾回收的算法与实现\n---\n## 对象\n\n- 不同于OOP，这里的对象指的是应用程序使用的数据的集合。\n- 对象配置在内存空间里。\n- 对象时GC的基本运作单位\n\n一般说来，对象由头（`Header`）和域（`Field`）构成\n\n### 头\n\n对象中保存对象本身信息的部分称为头，主要包含：\n- 对象的大小\n- 对象的种类\n\n### 域\n\n对象使用者在对象中可访问的部分称为域。\n\n> 可以将域理解为java中class的成员变量，如\n> class A {\n>   int val;\n> }\n> 若有A的实例a，则a.val就是对象a的域\n\n域的值有两种：\n- 指针\n- 非指针\n\n指针就是执行啊内存空间中某块区域的值，C语言中有明确的指针类型，java则没有。对于没有暴露指针的语言，可以将其理解为引用\n\n非指针值得是在编程过程中直接使用值本身，比如java中的int、bool等都是非指针。\n\n## 指针\n\nGC程序通过指针找到需要销毁或者保留对象，另一方面GC程序不处理非指针。\n\n有两点需要注意：\n\n- 程序是否能判别指针和非指针\n- 指针会指向对象的哪个部分\n\n## Mutator\n\n如果说GC程序负责回收垃圾，那么mutator就是负责创建对象的程序\n\nmutator实际进行的操作有以下两种：\n- 生成对象\n- 更新指针\n\n## 堆\n\n堆是用于动态存放对象的内存空间。当mutator申请存放对象时，所需内存空间会从这个堆中被分配给mutator。\n\n## 活动对象/非活动对象\n\n堆中能被mutator引用的对象称为“活动对象”；堆中不能通过遍历引用访问到的对象称为“非活动对象”。换言之，这些“非活动对象”就是“垃圾”。\n\n>需要注意，成为垃圾的对象不能活过来，因为mutator再也找不到它。\n\n## 分配\n\n当mutator需要创建新对象时，就会向allocator申请一个大小合适的空间。而allocator在堆的可用空间中寻找满足要求的连续空间，并返回给mutator。\n\n## 分块\n\n分块（chunk）在这里指的是为利用对象而事分配好的单元。\n\n初始状态下，堆被一个大的分块所占据\n\n程序会根据mutator的要求把这个分块分割成合适的大小，作为（活动）对象使用。\n\n内存里的各个区块都重复着分块-〉活动对象-〉垃圾（非活动对象）-〉分块-〉……这样的过程\n\n## 根\n\n根是指向对象的指针的“起点”部分。\n\n## 评价标准\n\n### 吞吐量\n\n一般意义上，吞吐量指的是“在单位时间内的处理能力”。\n\n即便是同一GC算法，其吞吐量也是受mutator的动作左右的。评价GC算法的吞吐量，有必要吧mutator的动作考虑在内。\n\n### 最大暂停时间\n\n最大暂停时间指的是“因执行GC而暂停执行mutator的最长时间”\n\n> 不管尝试哪种GC算法，大吞吐量和低延迟不可兼得\n\n### 堆使用率\n\n左右堆使用效率的因素有二，对象头的大小和调度堆空间的算法。\n\n> 不可能三角：堆使用效率，吞吐量和最大延迟不能兼顾\n\n### 访问的局部性\n\n根据局部性原理，把有引用关系的对象安排在堆中较近的位置可以提高读取效率，提高mutator的运行速度。\n","slug":"gc-review-1","published":1,"updated":"2024-06-10T20:04:07.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clx9h4k2s0002cotg6fjb9yx7","content":"<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><ul>\n<li>不同于OOP，这里的对象指的是应用程序使用的数据的集合。</li>\n<li>对象配置在内存空间里。</li>\n<li>对象时GC的基本运作单位</li>\n</ul>\n<p>一般说来，对象由头（<code>Header</code>）和域（<code>Field</code>）构成</p>\n<h3 id=\"头\"><a href=\"#头\" class=\"headerlink\" title=\"头\"></a>头</h3><p>对象中保存对象本身信息的部分称为头，主要包含：</p>\n<ul>\n<li>对象的大小</li>\n<li>对象的种类</li>\n</ul>\n<h3 id=\"域\"><a href=\"#域\" class=\"headerlink\" title=\"域\"></a>域</h3><p>对象使用者在对象中可访问的部分称为域。</p>\n<blockquote>\n<p>可以将域理解为java中class的成员变量，如<br>class A {<br>  int val;<br>}<br>若有A的实例a，则a.val就是对象a的域</p>\n</blockquote>\n<p>域的值有两种：</p>\n<ul>\n<li>指针</li>\n<li>非指针</li>\n</ul>\n<p>指针就是执行啊内存空间中某块区域的值，C语言中有明确的指针类型，java则没有。对于没有暴露指针的语言，可以将其理解为引用</p>\n<p>非指针值得是在编程过程中直接使用值本身，比如java中的int、bool等都是非指针。</p>\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><p>GC程序通过指针找到需要销毁或者保留对象，另一方面GC程序不处理非指针。</p>\n<p>有两点需要注意：</p>\n<ul>\n<li>程序是否能判别指针和非指针</li>\n<li>指针会指向对象的哪个部分</li>\n</ul>\n<h2 id=\"Mutator\"><a href=\"#Mutator\" class=\"headerlink\" title=\"Mutator\"></a>Mutator</h2><p>如果说GC程序负责回收垃圾，那么mutator就是负责创建对象的程序</p>\n<p>mutator实际进行的操作有以下两种：</p>\n<ul>\n<li>生成对象</li>\n<li>更新指针</li>\n</ul>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>堆是用于动态存放对象的内存空间。当mutator申请存放对象时，所需内存空间会从这个堆中被分配给mutator。</p>\n<h2 id=\"活动对象-x2F-非活动对象\"><a href=\"#活动对象-x2F-非活动对象\" class=\"headerlink\" title=\"活动对象&#x2F;非活动对象\"></a>活动对象&#x2F;非活动对象</h2><p>堆中能被mutator引用的对象称为“活动对象”；堆中不能通过遍历引用访问到的对象称为“非活动对象”。换言之，这些“非活动对象”就是“垃圾”。</p>\n<blockquote>\n<p>需要注意，成为垃圾的对象不能活过来，因为mutator再也找不到它。</p>\n</blockquote>\n<h2 id=\"分配\"><a href=\"#分配\" class=\"headerlink\" title=\"分配\"></a>分配</h2><p>当mutator需要创建新对象时，就会向allocator申请一个大小合适的空间。而allocator在堆的可用空间中寻找满足要求的连续空间，并返回给mutator。</p>\n<h2 id=\"分块\"><a href=\"#分块\" class=\"headerlink\" title=\"分块\"></a>分块</h2><p>分块（chunk）在这里指的是为利用对象而事分配好的单元。</p>\n<p>初始状态下，堆被一个大的分块所占据</p>\n<p>程序会根据mutator的要求把这个分块分割成合适的大小，作为（活动）对象使用。</p>\n<p>内存里的各个区块都重复着分块-〉活动对象-〉垃圾（非活动对象）-〉分块-〉……这样的过程</p>\n<h2 id=\"根\"><a href=\"#根\" class=\"headerlink\" title=\"根\"></a>根</h2><p>根是指向对象的指针的“起点”部分。</p>\n<h2 id=\"评价标准\"><a href=\"#评价标准\" class=\"headerlink\" title=\"评价标准\"></a>评价标准</h2><h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p>一般意义上，吞吐量指的是“在单位时间内的处理能力”。</p>\n<p>即便是同一GC算法，其吞吐量也是受mutator的动作左右的。评价GC算法的吞吐量，有必要吧mutator的动作考虑在内。</p>\n<h3 id=\"最大暂停时间\"><a href=\"#最大暂停时间\" class=\"headerlink\" title=\"最大暂停时间\"></a>最大暂停时间</h3><p>最大暂停时间指的是“因执行GC而暂停执行mutator的最长时间”</p>\n<blockquote>\n<p>不管尝试哪种GC算法，大吞吐量和低延迟不可兼得</p>\n</blockquote>\n<h3 id=\"堆使用率\"><a href=\"#堆使用率\" class=\"headerlink\" title=\"堆使用率\"></a>堆使用率</h3><p>左右堆使用效率的因素有二，对象头的大小和调度堆空间的算法。</p>\n<blockquote>\n<p>不可能三角：堆使用效率，吞吐量和最大延迟不能兼顾</p>\n</blockquote>\n<h3 id=\"访问的局部性\"><a href=\"#访问的局部性\" class=\"headerlink\" title=\"访问的局部性\"></a>访问的局部性</h3><p>根据局部性原理，把有引用关系的对象安排在堆中较近的位置可以提高读取效率，提高mutator的运行速度。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><ul>\n<li>不同于OOP，这里的对象指的是应用程序使用的数据的集合。</li>\n<li>对象配置在内存空间里。</li>\n<li>对象时GC的基本运作单位</li>\n</ul>\n<p>一般说来，对象由头（<code>Header</code>）和域（<code>Field</code>）构成</p>\n<h3 id=\"头\"><a href=\"#头\" class=\"headerlink\" title=\"头\"></a>头</h3><p>对象中保存对象本身信息的部分称为头，主要包含：</p>\n<ul>\n<li>对象的大小</li>\n<li>对象的种类</li>\n</ul>\n<h3 id=\"域\"><a href=\"#域\" class=\"headerlink\" title=\"域\"></a>域</h3><p>对象使用者在对象中可访问的部分称为域。</p>\n<blockquote>\n<p>可以将域理解为java中class的成员变量，如<br>class A {<br>  int val;<br>}<br>若有A的实例a，则a.val就是对象a的域</p>\n</blockquote>\n<p>域的值有两种：</p>\n<ul>\n<li>指针</li>\n<li>非指针</li>\n</ul>\n<p>指针就是执行啊内存空间中某块区域的值，C语言中有明确的指针类型，java则没有。对于没有暴露指针的语言，可以将其理解为引用</p>\n<p>非指针值得是在编程过程中直接使用值本身，比如java中的int、bool等都是非指针。</p>\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><p>GC程序通过指针找到需要销毁或者保留对象，另一方面GC程序不处理非指针。</p>\n<p>有两点需要注意：</p>\n<ul>\n<li>程序是否能判别指针和非指针</li>\n<li>指针会指向对象的哪个部分</li>\n</ul>\n<h2 id=\"Mutator\"><a href=\"#Mutator\" class=\"headerlink\" title=\"Mutator\"></a>Mutator</h2><p>如果说GC程序负责回收垃圾，那么mutator就是负责创建对象的程序</p>\n<p>mutator实际进行的操作有以下两种：</p>\n<ul>\n<li>生成对象</li>\n<li>更新指针</li>\n</ul>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>堆是用于动态存放对象的内存空间。当mutator申请存放对象时，所需内存空间会从这个堆中被分配给mutator。</p>\n<h2 id=\"活动对象-x2F-非活动对象\"><a href=\"#活动对象-x2F-非活动对象\" class=\"headerlink\" title=\"活动对象&#x2F;非活动对象\"></a>活动对象&#x2F;非活动对象</h2><p>堆中能被mutator引用的对象称为“活动对象”；堆中不能通过遍历引用访问到的对象称为“非活动对象”。换言之，这些“非活动对象”就是“垃圾”。</p>\n<blockquote>\n<p>需要注意，成为垃圾的对象不能活过来，因为mutator再也找不到它。</p>\n</blockquote>\n<h2 id=\"分配\"><a href=\"#分配\" class=\"headerlink\" title=\"分配\"></a>分配</h2><p>当mutator需要创建新对象时，就会向allocator申请一个大小合适的空间。而allocator在堆的可用空间中寻找满足要求的连续空间，并返回给mutator。</p>\n<h2 id=\"分块\"><a href=\"#分块\" class=\"headerlink\" title=\"分块\"></a>分块</h2><p>分块（chunk）在这里指的是为利用对象而事分配好的单元。</p>\n<p>初始状态下，堆被一个大的分块所占据</p>\n<p>程序会根据mutator的要求把这个分块分割成合适的大小，作为（活动）对象使用。</p>\n<p>内存里的各个区块都重复着分块-〉活动对象-〉垃圾（非活动对象）-〉分块-〉……这样的过程</p>\n<h2 id=\"根\"><a href=\"#根\" class=\"headerlink\" title=\"根\"></a>根</h2><p>根是指向对象的指针的“起点”部分。</p>\n<h2 id=\"评价标准\"><a href=\"#评价标准\" class=\"headerlink\" title=\"评价标准\"></a>评价标准</h2><h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p>一般意义上，吞吐量指的是“在单位时间内的处理能力”。</p>\n<p>即便是同一GC算法，其吞吐量也是受mutator的动作左右的。评价GC算法的吞吐量，有必要吧mutator的动作考虑在内。</p>\n<h3 id=\"最大暂停时间\"><a href=\"#最大暂停时间\" class=\"headerlink\" title=\"最大暂停时间\"></a>最大暂停时间</h3><p>最大暂停时间指的是“因执行GC而暂停执行mutator的最长时间”</p>\n<blockquote>\n<p>不管尝试哪种GC算法，大吞吐量和低延迟不可兼得</p>\n</blockquote>\n<h3 id=\"堆使用率\"><a href=\"#堆使用率\" class=\"headerlink\" title=\"堆使用率\"></a>堆使用率</h3><p>左右堆使用效率的因素有二，对象头的大小和调度堆空间的算法。</p>\n<blockquote>\n<p>不可能三角：堆使用效率，吞吐量和最大延迟不能兼顾</p>\n</blockquote>\n<h3 id=\"访问的局部性\"><a href=\"#访问的局部性\" class=\"headerlink\" title=\"访问的局部性\"></a>访问的局部性</h3><p>根据局部性原理，把有引用关系的对象安排在堆中较近的位置可以提高读取效率，提高mutator的运行速度。</p>\n"},{"title":"评Unix哲学基础","date":"2023-08-23T16:00:00.000Z","_content":"> 这本书对我而言太厚了，我曾多次翻开这本书并尝试读完它，可没有一次能完整读完。每每读到第三、四部分就意兴阑珊，草草收场，但我非常喜欢第一、二部分。或许是因为oncall太多，这里的每一条原则我都能找到共鸣。。。\n\n## 1. 模块原则：使用简洁的接口拼合简单的部件\n\n## 2. 清晰原则：清晰胜于机巧\n\n## 3. 组合原则：设计时考虑拼接组合\n\n## 4. 分离原则：策略同机制分离，接口同引擎分离\n\n## 5. 简洁原则：设计要简洁，复杂度能低则低\n\n## 6. 吝啬原则：除非却无他法，不要编写庞大的程序\n\n## 7. 透明性原则：设计要可见，以便审查和调试\n\n## 8. 健壮原则：健壮源于透明与简洁\n\n## 9. 表示原则：把知识叠入数据以求逻辑质朴而健壮\n\n## 10. 通俗原则：设计接口避免标新立异\n\n## 11. 缄默原则：如果一个程序没什么好说的，保持沉默\n\n## 12. 补救原则：出现异常时，马上退出并给出足够错误信息\n\n## 13. 经济原则：宁花机器一分，不花程序员一秒\n\n## 14. 生成原则：避免手工hack，尽量编写程序去生成程序\n\n## 15. 优化原则：雕琢前先要有原型，跑之前先学会走\n\n## 16. 多样原则：绝不相信所谓“不二法门”的断言\n\n## 17. 扩展原则：设计着眼未来，未来总比预想来得快","source":"_posts/unix-philosophy.md","raw":"---\ntitle: 评Unix哲学基础\ndate: 2023-8-24\ntags:\n- 读书笔记\n- 程序设计\n- Unix编程艺术\n---\n> 这本书对我而言太厚了，我曾多次翻开这本书并尝试读完它，可没有一次能完整读完。每每读到第三、四部分就意兴阑珊，草草收场，但我非常喜欢第一、二部分。或许是因为oncall太多，这里的每一条原则我都能找到共鸣。。。\n\n## 1. 模块原则：使用简洁的接口拼合简单的部件\n\n## 2. 清晰原则：清晰胜于机巧\n\n## 3. 组合原则：设计时考虑拼接组合\n\n## 4. 分离原则：策略同机制分离，接口同引擎分离\n\n## 5. 简洁原则：设计要简洁，复杂度能低则低\n\n## 6. 吝啬原则：除非却无他法，不要编写庞大的程序\n\n## 7. 透明性原则：设计要可见，以便审查和调试\n\n## 8. 健壮原则：健壮源于透明与简洁\n\n## 9. 表示原则：把知识叠入数据以求逻辑质朴而健壮\n\n## 10. 通俗原则：设计接口避免标新立异\n\n## 11. 缄默原则：如果一个程序没什么好说的，保持沉默\n\n## 12. 补救原则：出现异常时，马上退出并给出足够错误信息\n\n## 13. 经济原则：宁花机器一分，不花程序员一秒\n\n## 14. 生成原则：避免手工hack，尽量编写程序去生成程序\n\n## 15. 优化原则：雕琢前先要有原型，跑之前先学会走\n\n## 16. 多样原则：绝不相信所谓“不二法门”的断言\n\n## 17. 扩展原则：设计着眼未来，未来总比预想来得快","slug":"unix-philosophy","published":1,"updated":"2024-05-19T14:10:14.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clx9h4k2u0004cotgdgf0e3sr","content":"<blockquote>\n<p>这本书对我而言太厚了，我曾多次翻开这本书并尝试读完它，可没有一次能完整读完。每每读到第三、四部分就意兴阑珊，草草收场，但我非常喜欢第一、二部分。或许是因为oncall太多，这里的每一条原则我都能找到共鸣。。。</p>\n</blockquote>\n<h2 id=\"1-模块原则：使用简洁的接口拼合简单的部件\"><a href=\"#1-模块原则：使用简洁的接口拼合简单的部件\" class=\"headerlink\" title=\"1. 模块原则：使用简洁的接口拼合简单的部件\"></a>1. 模块原则：使用简洁的接口拼合简单的部件</h2><h2 id=\"2-清晰原则：清晰胜于机巧\"><a href=\"#2-清晰原则：清晰胜于机巧\" class=\"headerlink\" title=\"2. 清晰原则：清晰胜于机巧\"></a>2. 清晰原则：清晰胜于机巧</h2><h2 id=\"3-组合原则：设计时考虑拼接组合\"><a href=\"#3-组合原则：设计时考虑拼接组合\" class=\"headerlink\" title=\"3. 组合原则：设计时考虑拼接组合\"></a>3. 组合原则：设计时考虑拼接组合</h2><h2 id=\"4-分离原则：策略同机制分离，接口同引擎分离\"><a href=\"#4-分离原则：策略同机制分离，接口同引擎分离\" class=\"headerlink\" title=\"4. 分离原则：策略同机制分离，接口同引擎分离\"></a>4. 分离原则：策略同机制分离，接口同引擎分离</h2><h2 id=\"5-简洁原则：设计要简洁，复杂度能低则低\"><a href=\"#5-简洁原则：设计要简洁，复杂度能低则低\" class=\"headerlink\" title=\"5. 简洁原则：设计要简洁，复杂度能低则低\"></a>5. 简洁原则：设计要简洁，复杂度能低则低</h2><h2 id=\"6-吝啬原则：除非却无他法，不要编写庞大的程序\"><a href=\"#6-吝啬原则：除非却无他法，不要编写庞大的程序\" class=\"headerlink\" title=\"6. 吝啬原则：除非却无他法，不要编写庞大的程序\"></a>6. 吝啬原则：除非却无他法，不要编写庞大的程序</h2><h2 id=\"7-透明性原则：设计要可见，以便审查和调试\"><a href=\"#7-透明性原则：设计要可见，以便审查和调试\" class=\"headerlink\" title=\"7. 透明性原则：设计要可见，以便审查和调试\"></a>7. 透明性原则：设计要可见，以便审查和调试</h2><h2 id=\"8-健壮原则：健壮源于透明与简洁\"><a href=\"#8-健壮原则：健壮源于透明与简洁\" class=\"headerlink\" title=\"8. 健壮原则：健壮源于透明与简洁\"></a>8. 健壮原则：健壮源于透明与简洁</h2><h2 id=\"9-表示原则：把知识叠入数据以求逻辑质朴而健壮\"><a href=\"#9-表示原则：把知识叠入数据以求逻辑质朴而健壮\" class=\"headerlink\" title=\"9. 表示原则：把知识叠入数据以求逻辑质朴而健壮\"></a>9. 表示原则：把知识叠入数据以求逻辑质朴而健壮</h2><h2 id=\"10-通俗原则：设计接口避免标新立异\"><a href=\"#10-通俗原则：设计接口避免标新立异\" class=\"headerlink\" title=\"10. 通俗原则：设计接口避免标新立异\"></a>10. 通俗原则：设计接口避免标新立异</h2><h2 id=\"11-缄默原则：如果一个程序没什么好说的，保持沉默\"><a href=\"#11-缄默原则：如果一个程序没什么好说的，保持沉默\" class=\"headerlink\" title=\"11. 缄默原则：如果一个程序没什么好说的，保持沉默\"></a>11. 缄默原则：如果一个程序没什么好说的，保持沉默</h2><h2 id=\"12-补救原则：出现异常时，马上退出并给出足够错误信息\"><a href=\"#12-补救原则：出现异常时，马上退出并给出足够错误信息\" class=\"headerlink\" title=\"12. 补救原则：出现异常时，马上退出并给出足够错误信息\"></a>12. 补救原则：出现异常时，马上退出并给出足够错误信息</h2><h2 id=\"13-经济原则：宁花机器一分，不花程序员一秒\"><a href=\"#13-经济原则：宁花机器一分，不花程序员一秒\" class=\"headerlink\" title=\"13. 经济原则：宁花机器一分，不花程序员一秒\"></a>13. 经济原则：宁花机器一分，不花程序员一秒</h2><h2 id=\"14-生成原则：避免手工hack，尽量编写程序去生成程序\"><a href=\"#14-生成原则：避免手工hack，尽量编写程序去生成程序\" class=\"headerlink\" title=\"14. 生成原则：避免手工hack，尽量编写程序去生成程序\"></a>14. 生成原则：避免手工hack，尽量编写程序去生成程序</h2><h2 id=\"15-优化原则：雕琢前先要有原型，跑之前先学会走\"><a href=\"#15-优化原则：雕琢前先要有原型，跑之前先学会走\" class=\"headerlink\" title=\"15. 优化原则：雕琢前先要有原型，跑之前先学会走\"></a>15. 优化原则：雕琢前先要有原型，跑之前先学会走</h2><h2 id=\"16-多样原则：绝不相信所谓“不二法门”的断言\"><a href=\"#16-多样原则：绝不相信所谓“不二法门”的断言\" class=\"headerlink\" title=\"16. 多样原则：绝不相信所谓“不二法门”的断言\"></a>16. 多样原则：绝不相信所谓“不二法门”的断言</h2><h2 id=\"17-扩展原则：设计着眼未来，未来总比预想来得快\"><a href=\"#17-扩展原则：设计着眼未来，未来总比预想来得快\" class=\"headerlink\" title=\"17. 扩展原则：设计着眼未来，未来总比预想来得快\"></a>17. 扩展原则：设计着眼未来，未来总比预想来得快</h2>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这本书对我而言太厚了，我曾多次翻开这本书并尝试读完它，可没有一次能完整读完。每每读到第三、四部分就意兴阑珊，草草收场，但我非常喜欢第一、二部分。或许是因为oncall太多，这里的每一条原则我都能找到共鸣。。。</p>\n</blockquote>\n<h2 id=\"1-模块原则：使用简洁的接口拼合简单的部件\"><a href=\"#1-模块原则：使用简洁的接口拼合简单的部件\" class=\"headerlink\" title=\"1. 模块原则：使用简洁的接口拼合简单的部件\"></a>1. 模块原则：使用简洁的接口拼合简单的部件</h2><h2 id=\"2-清晰原则：清晰胜于机巧\"><a href=\"#2-清晰原则：清晰胜于机巧\" class=\"headerlink\" title=\"2. 清晰原则：清晰胜于机巧\"></a>2. 清晰原则：清晰胜于机巧</h2><h2 id=\"3-组合原则：设计时考虑拼接组合\"><a href=\"#3-组合原则：设计时考虑拼接组合\" class=\"headerlink\" title=\"3. 组合原则：设计时考虑拼接组合\"></a>3. 组合原则：设计时考虑拼接组合</h2><h2 id=\"4-分离原则：策略同机制分离，接口同引擎分离\"><a href=\"#4-分离原则：策略同机制分离，接口同引擎分离\" class=\"headerlink\" title=\"4. 分离原则：策略同机制分离，接口同引擎分离\"></a>4. 分离原则：策略同机制分离，接口同引擎分离</h2><h2 id=\"5-简洁原则：设计要简洁，复杂度能低则低\"><a href=\"#5-简洁原则：设计要简洁，复杂度能低则低\" class=\"headerlink\" title=\"5. 简洁原则：设计要简洁，复杂度能低则低\"></a>5. 简洁原则：设计要简洁，复杂度能低则低</h2><h2 id=\"6-吝啬原则：除非却无他法，不要编写庞大的程序\"><a href=\"#6-吝啬原则：除非却无他法，不要编写庞大的程序\" class=\"headerlink\" title=\"6. 吝啬原则：除非却无他法，不要编写庞大的程序\"></a>6. 吝啬原则：除非却无他法，不要编写庞大的程序</h2><h2 id=\"7-透明性原则：设计要可见，以便审查和调试\"><a href=\"#7-透明性原则：设计要可见，以便审查和调试\" class=\"headerlink\" title=\"7. 透明性原则：设计要可见，以便审查和调试\"></a>7. 透明性原则：设计要可见，以便审查和调试</h2><h2 id=\"8-健壮原则：健壮源于透明与简洁\"><a href=\"#8-健壮原则：健壮源于透明与简洁\" class=\"headerlink\" title=\"8. 健壮原则：健壮源于透明与简洁\"></a>8. 健壮原则：健壮源于透明与简洁</h2><h2 id=\"9-表示原则：把知识叠入数据以求逻辑质朴而健壮\"><a href=\"#9-表示原则：把知识叠入数据以求逻辑质朴而健壮\" class=\"headerlink\" title=\"9. 表示原则：把知识叠入数据以求逻辑质朴而健壮\"></a>9. 表示原则：把知识叠入数据以求逻辑质朴而健壮</h2><h2 id=\"10-通俗原则：设计接口避免标新立异\"><a href=\"#10-通俗原则：设计接口避免标新立异\" class=\"headerlink\" title=\"10. 通俗原则：设计接口避免标新立异\"></a>10. 通俗原则：设计接口避免标新立异</h2><h2 id=\"11-缄默原则：如果一个程序没什么好说的，保持沉默\"><a href=\"#11-缄默原则：如果一个程序没什么好说的，保持沉默\" class=\"headerlink\" title=\"11. 缄默原则：如果一个程序没什么好说的，保持沉默\"></a>11. 缄默原则：如果一个程序没什么好说的，保持沉默</h2><h2 id=\"12-补救原则：出现异常时，马上退出并给出足够错误信息\"><a href=\"#12-补救原则：出现异常时，马上退出并给出足够错误信息\" class=\"headerlink\" title=\"12. 补救原则：出现异常时，马上退出并给出足够错误信息\"></a>12. 补救原则：出现异常时，马上退出并给出足够错误信息</h2><h2 id=\"13-经济原则：宁花机器一分，不花程序员一秒\"><a href=\"#13-经济原则：宁花机器一分，不花程序员一秒\" class=\"headerlink\" title=\"13. 经济原则：宁花机器一分，不花程序员一秒\"></a>13. 经济原则：宁花机器一分，不花程序员一秒</h2><h2 id=\"14-生成原则：避免手工hack，尽量编写程序去生成程序\"><a href=\"#14-生成原则：避免手工hack，尽量编写程序去生成程序\" class=\"headerlink\" title=\"14. 生成原则：避免手工hack，尽量编写程序去生成程序\"></a>14. 生成原则：避免手工hack，尽量编写程序去生成程序</h2><h2 id=\"15-优化原则：雕琢前先要有原型，跑之前先学会走\"><a href=\"#15-优化原则：雕琢前先要有原型，跑之前先学会走\" class=\"headerlink\" title=\"15. 优化原则：雕琢前先要有原型，跑之前先学会走\"></a>15. 优化原则：雕琢前先要有原型，跑之前先学会走</h2><h2 id=\"16-多样原则：绝不相信所谓“不二法门”的断言\"><a href=\"#16-多样原则：绝不相信所谓“不二法门”的断言\" class=\"headerlink\" title=\"16. 多样原则：绝不相信所谓“不二法门”的断言\"></a>16. 多样原则：绝不相信所谓“不二法门”的断言</h2><h2 id=\"17-扩展原则：设计着眼未来，未来总比预想来得快\"><a href=\"#17-扩展原则：设计着眼未来，未来总比预想来得快\" class=\"headerlink\" title=\"17. 扩展原则：设计着眼未来，未来总比预想来得快\"></a>17. 扩展原则：设计着眼未来，未来总比预想来得快</h2>"},{"title":"浅谈使用hook实现React中的应用状态管理","date":"2023-10-05T16:00:00.000Z","_content":"状态管理可以说是所有应用中最难处理的一部分。这也是为什么当下存在这么多的状态管理工具，并且仍然层出不穷（有一些工具甚至建立在另一些之上，npm 中有大量 “简单版的 redux“）。然而，我认为正是由于我们经常过度设计，才导致这个问题这么难处理。\n\n我们通常把 React 组件看做乐高积木，用它们来搭建应用。我觉着听到这个说法的人，通常会隐隐地觉得这个说法遗漏了和状态相关的那一部分。我自己使用的方法的“秘密”就是：对待状态管理问题时，想想怎么把应用的状态映射到应用的树状结构上面去。\n\nredux 大获成功的原因之一就是它解决了Prop Drilling问题。通过把组件传给一些神奇的 connect 函数就可以让数据共享到应用树的任意地方的做法确实很棒。对 reducers/action creator 的使用也不错，但我仍然坚信 redux 的被普遍使用的原因是它为开发者解决了 prop drilling 所带来的痛苦。\n\n我经常看到开发者把他们所有的状态（state）都放到 redux 中。包括全局状态和本地状态。这会导致非常多的问题，其中最重要的一个是，当你在维护任何状态交互时，都将会涉及到 reducer 、action creator / types 和 dispatch 调用的交互，这最终导致我们必须打开一大堆文件，并在大脑中追溯代码实现，才能弄明白当下发生了什么，以及它对代码库的其它部分产生了什么样的影响。\n\n澄清一下，这样对于全局状态来说是没问题的，但是对于简单的状态（比如一个弹窗是否打开，或者表单中填写的值）来说就会是很大的问题。更糟糕的是，这样基本没法扩展。你的应用越大，这个问题就越难处理。当然，用不一样的 reducer 去管理应用中的不同部分是没问题的，但是通过这些 action creators 和 reducer 来间接处理的方式并不是最好的。\n\n就算没有使用 redux ，把应用中的所有状态全放在一个对象上还是会导致其他问题。当 React <Context.Provider> 获取到一个新的值，所有消费它的组件都会被更新且必须被渲染，哪怕它是一个只关心其中部分数据的函数组件。这就会带来潜在的性能问题（React-Redux v6 尝试使用这个办法，然后发现它不能和 hook 一起工作，这导致他们在 v7 中需要用其他办法来处理）。我的重点在于，如果把状态从逻辑上分隔开并且放在 React 树上对应合适的位置，那你就不用担心这些问题了。\n\n","source":"_posts/state-management-in-react.md","raw":"---\ntitle: 浅谈使用hook实现React中的应用状态管理\ndate: 2023-10-6\ntag:\n  - js\n  - react\n  - 状态管理\n  - 前端\n---\n状态管理可以说是所有应用中最难处理的一部分。这也是为什么当下存在这么多的状态管理工具，并且仍然层出不穷（有一些工具甚至建立在另一些之上，npm 中有大量 “简单版的 redux“）。然而，我认为正是由于我们经常过度设计，才导致这个问题这么难处理。\n\n我们通常把 React 组件看做乐高积木，用它们来搭建应用。我觉着听到这个说法的人，通常会隐隐地觉得这个说法遗漏了和状态相关的那一部分。我自己使用的方法的“秘密”就是：对待状态管理问题时，想想怎么把应用的状态映射到应用的树状结构上面去。\n\nredux 大获成功的原因之一就是它解决了Prop Drilling问题。通过把组件传给一些神奇的 connect 函数就可以让数据共享到应用树的任意地方的做法确实很棒。对 reducers/action creator 的使用也不错，但我仍然坚信 redux 的被普遍使用的原因是它为开发者解决了 prop drilling 所带来的痛苦。\n\n我经常看到开发者把他们所有的状态（state）都放到 redux 中。包括全局状态和本地状态。这会导致非常多的问题，其中最重要的一个是，当你在维护任何状态交互时，都将会涉及到 reducer 、action creator / types 和 dispatch 调用的交互，这最终导致我们必须打开一大堆文件，并在大脑中追溯代码实现，才能弄明白当下发生了什么，以及它对代码库的其它部分产生了什么样的影响。\n\n澄清一下，这样对于全局状态来说是没问题的，但是对于简单的状态（比如一个弹窗是否打开，或者表单中填写的值）来说就会是很大的问题。更糟糕的是，这样基本没法扩展。你的应用越大，这个问题就越难处理。当然，用不一样的 reducer 去管理应用中的不同部分是没问题的，但是通过这些 action creators 和 reducer 来间接处理的方式并不是最好的。\n\n就算没有使用 redux ，把应用中的所有状态全放在一个对象上还是会导致其他问题。当 React <Context.Provider> 获取到一个新的值，所有消费它的组件都会被更新且必须被渲染，哪怕它是一个只关心其中部分数据的函数组件。这就会带来潜在的性能问题（React-Redux v6 尝试使用这个办法，然后发现它不能和 hook 一起工作，这导致他们在 v7 中需要用其他办法来处理）。我的重点在于，如果把状态从逻辑上分隔开并且放在 React 树上对应合适的位置，那你就不用担心这些问题了。\n\n","slug":"state-management-in-react","published":1,"updated":"2024-05-19T14:10:14.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clx9h4k2v0005cotg2n4ge1yi","content":"<p>状态管理可以说是所有应用中最难处理的一部分。这也是为什么当下存在这么多的状态管理工具，并且仍然层出不穷（有一些工具甚至建立在另一些之上，npm 中有大量 “简单版的 redux“）。然而，我认为正是由于我们经常过度设计，才导致这个问题这么难处理。</p>\n<p>我们通常把 React 组件看做乐高积木，用它们来搭建应用。我觉着听到这个说法的人，通常会隐隐地觉得这个说法遗漏了和状态相关的那一部分。我自己使用的方法的“秘密”就是：对待状态管理问题时，想想怎么把应用的状态映射到应用的树状结构上面去。</p>\n<p>redux 大获成功的原因之一就是它解决了Prop Drilling问题。通过把组件传给一些神奇的 connect 函数就可以让数据共享到应用树的任意地方的做法确实很棒。对 reducers&#x2F;action creator 的使用也不错，但我仍然坚信 redux 的被普遍使用的原因是它为开发者解决了 prop drilling 所带来的痛苦。</p>\n<p>我经常看到开发者把他们所有的状态（state）都放到 redux 中。包括全局状态和本地状态。这会导致非常多的问题，其中最重要的一个是，当你在维护任何状态交互时，都将会涉及到 reducer 、action creator &#x2F; types 和 dispatch 调用的交互，这最终导致我们必须打开一大堆文件，并在大脑中追溯代码实现，才能弄明白当下发生了什么，以及它对代码库的其它部分产生了什么样的影响。</p>\n<p>澄清一下，这样对于全局状态来说是没问题的，但是对于简单的状态（比如一个弹窗是否打开，或者表单中填写的值）来说就会是很大的问题。更糟糕的是，这样基本没法扩展。你的应用越大，这个问题就越难处理。当然，用不一样的 reducer 去管理应用中的不同部分是没问题的，但是通过这些 action creators 和 reducer 来间接处理的方式并不是最好的。</p>\n<p>就算没有使用 redux ，把应用中的所有状态全放在一个对象上还是会导致其他问题。当 React &lt;Context.Provider&gt; 获取到一个新的值，所有消费它的组件都会被更新且必须被渲染，哪怕它是一个只关心其中部分数据的函数组件。这就会带来潜在的性能问题（React-Redux v6 尝试使用这个办法，然后发现它不能和 hook 一起工作，这导致他们在 v7 中需要用其他办法来处理）。我的重点在于，如果把状态从逻辑上分隔开并且放在 React 树上对应合适的位置，那你就不用担心这些问题了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>状态管理可以说是所有应用中最难处理的一部分。这也是为什么当下存在这么多的状态管理工具，并且仍然层出不穷（有一些工具甚至建立在另一些之上，npm 中有大量 “简单版的 redux“）。然而，我认为正是由于我们经常过度设计，才导致这个问题这么难处理。</p>\n<p>我们通常把 React 组件看做乐高积木，用它们来搭建应用。我觉着听到这个说法的人，通常会隐隐地觉得这个说法遗漏了和状态相关的那一部分。我自己使用的方法的“秘密”就是：对待状态管理问题时，想想怎么把应用的状态映射到应用的树状结构上面去。</p>\n<p>redux 大获成功的原因之一就是它解决了Prop Drilling问题。通过把组件传给一些神奇的 connect 函数就可以让数据共享到应用树的任意地方的做法确实很棒。对 reducers&#x2F;action creator 的使用也不错，但我仍然坚信 redux 的被普遍使用的原因是它为开发者解决了 prop drilling 所带来的痛苦。</p>\n<p>我经常看到开发者把他们所有的状态（state）都放到 redux 中。包括全局状态和本地状态。这会导致非常多的问题，其中最重要的一个是，当你在维护任何状态交互时，都将会涉及到 reducer 、action creator &#x2F; types 和 dispatch 调用的交互，这最终导致我们必须打开一大堆文件，并在大脑中追溯代码实现，才能弄明白当下发生了什么，以及它对代码库的其它部分产生了什么样的影响。</p>\n<p>澄清一下，这样对于全局状态来说是没问题的，但是对于简单的状态（比如一个弹窗是否打开，或者表单中填写的值）来说就会是很大的问题。更糟糕的是，这样基本没法扩展。你的应用越大，这个问题就越难处理。当然，用不一样的 reducer 去管理应用中的不同部分是没问题的，但是通过这些 action creators 和 reducer 来间接处理的方式并不是最好的。</p>\n<p>就算没有使用 redux ，把应用中的所有状态全放在一个对象上还是会导致其他问题。当 React &lt;Context.Provider&gt; 获取到一个新的值，所有消费它的组件都会被更新且必须被渲染，哪怕它是一个只关心其中部分数据的函数组件。这就会带来潜在的性能问题（React-Redux v6 尝试使用这个办法，然后发现它不能和 hook 一起工作，这导致他们在 v7 中需要用其他办法来处理）。我的重点在于，如果把状态从逻辑上分隔开并且放在 React 树上对应合适的位置，那你就不用担心这些问题了。</p>\n"},{"title":"从零开始的golang编程（day1）","date":"2023-09-02T16:00:00.000Z","_content":"\n> 第一天，完成go下载器的搭建\n\n## 原型设计\n\n首先我们要拆分问题，一个支持多任务，多分片，多协议，还能断点续传的下载器无疑是复杂的任务，一时半会儿想不出好的解决方案。所以先将问题拆分简化，刨除所有的定语，一个下载器首先要能发出请求，然后将收到的数据保存至文件，其次才是逐个完成定语对应的功能。\n\n## 如何使用go完成http协议下载？\n\n先写测试程序，目标：把baidu的首页html文件下载下来并保存到当前目录\n\n```go\n  func TestDownload(f *testing.T) {\n    // 请求baidu首页\n    resp, err := http.Get(\"http://www.baidu.com\")\n    if err != nil {\n      fmt.Println(\"error\", err)\n    }\n    // 不要忘记结束时关闭IO流\n    defer func(Body io.ReadCloser) {\n      err := Body.Close()\n      if err != nil {\n        fmt.Println(\"close error\", err)\n      }\n    }(resp.Body)\n    // 读取收到的数据\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n      fmt.Println(\"read failed\", err)\n    }\n    // 写入文件\n    err = WriteFile(\"./index.html\", body)\n    if err != nil {\n      fmt.Println(\"=======failed=======\")\n      return\n    }\n    fmt.Println(\"=======finished=======\")\n  }\n\n  func WriteFile(filePath string, content []byte) error {\n    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)\n    if err != nil {\n      fmt.Println(\"file: '\" + filePath + \"' open filed\")\n      return nil, err\n    }\n    defer func(file *os.File) {\n      err := file.Close()\n      if err != nil {\n        return nil, err\n      }\n    }(file)\n    write := bufio.NewWriter(file)\n    if _, err := write.Write(content); err != nil {\n      fmt.Println(\"file: '\" + filePath + \"' write failed\")\n      return nil, err\n    }\n    return nil\n  }\n```\n\n至此我们已经可以将baidu的首页是保存至本地。但这代码既不支持断点续传，也不能多个分片并行，不能满足我们的要求。可是通过这段代码，我们得以明白，下载器的核心就是下载数据，然后写入指定的位置接。接下来，我们要逐步完善它。\n\n## 实现断点续传\n\n为什么先说断点续传，因为分片并行下载的前提就是支持断点续传\n\n### http协议如何做到断点续传？\n\n### 如何分片写入文件?\n","source":"_posts/go-downloader-1.md","raw":"---\ntitle: 从零开始的golang编程（day1）\ndate: 2023-9-3\ntag:\n  - go\n  - home-center\n  - go-downloader\n  - 编程日志\n---\n\n> 第一天，完成go下载器的搭建\n\n## 原型设计\n\n首先我们要拆分问题，一个支持多任务，多分片，多协议，还能断点续传的下载器无疑是复杂的任务，一时半会儿想不出好的解决方案。所以先将问题拆分简化，刨除所有的定语，一个下载器首先要能发出请求，然后将收到的数据保存至文件，其次才是逐个完成定语对应的功能。\n\n## 如何使用go完成http协议下载？\n\n先写测试程序，目标：把baidu的首页html文件下载下来并保存到当前目录\n\n```go\n  func TestDownload(f *testing.T) {\n    // 请求baidu首页\n    resp, err := http.Get(\"http://www.baidu.com\")\n    if err != nil {\n      fmt.Println(\"error\", err)\n    }\n    // 不要忘记结束时关闭IO流\n    defer func(Body io.ReadCloser) {\n      err := Body.Close()\n      if err != nil {\n        fmt.Println(\"close error\", err)\n      }\n    }(resp.Body)\n    // 读取收到的数据\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n      fmt.Println(\"read failed\", err)\n    }\n    // 写入文件\n    err = WriteFile(\"./index.html\", body)\n    if err != nil {\n      fmt.Println(\"=======failed=======\")\n      return\n    }\n    fmt.Println(\"=======finished=======\")\n  }\n\n  func WriteFile(filePath string, content []byte) error {\n    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)\n    if err != nil {\n      fmt.Println(\"file: '\" + filePath + \"' open filed\")\n      return nil, err\n    }\n    defer func(file *os.File) {\n      err := file.Close()\n      if err != nil {\n        return nil, err\n      }\n    }(file)\n    write := bufio.NewWriter(file)\n    if _, err := write.Write(content); err != nil {\n      fmt.Println(\"file: '\" + filePath + \"' write failed\")\n      return nil, err\n    }\n    return nil\n  }\n```\n\n至此我们已经可以将baidu的首页是保存至本地。但这代码既不支持断点续传，也不能多个分片并行，不能满足我们的要求。可是通过这段代码，我们得以明白，下载器的核心就是下载数据，然后写入指定的位置接。接下来，我们要逐步完善它。\n\n## 实现断点续传\n\n为什么先说断点续传，因为分片并行下载的前提就是支持断点续传\n\n### http协议如何做到断点续传？\n\n### 如何分片写入文件?\n","slug":"go-downloader-1","published":1,"updated":"2024-05-19T14:10:14.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clx9h4k2v0007cotg3uazhqx2","content":"<blockquote>\n<p>第一天，完成go下载器的搭建</p>\n</blockquote>\n<h2 id=\"原型设计\"><a href=\"#原型设计\" class=\"headerlink\" title=\"原型设计\"></a>原型设计</h2><p>首先我们要拆分问题，一个支持多任务，多分片，多协议，还能断点续传的下载器无疑是复杂的任务，一时半会儿想不出好的解决方案。所以先将问题拆分简化，刨除所有的定语，一个下载器首先要能发出请求，然后将收到的数据保存至文件，其次才是逐个完成定语对应的功能。</p>\n<h2 id=\"如何使用go完成http协议下载？\"><a href=\"#如何使用go完成http协议下载？\" class=\"headerlink\" title=\"如何使用go完成http协议下载？\"></a>如何使用go完成http协议下载？</h2><p>先写测试程序，目标：把baidu的首页html文件下载下来并保存到当前目录</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestDownload</span><span class=\"hljs-params\">(f *testing.T)</span></span> &#123;<br>  <span class=\"hljs-comment\">// 请求baidu首页</span><br>  resp, err := http.Get(<span class=\"hljs-string\">&quot;http://www.baidu.com&quot;</span>)<br>  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;error&quot;</span>, err)<br>  &#125;<br>  <span class=\"hljs-comment\">// 不要忘记结束时关闭IO流</span><br>  <span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(Body io.ReadCloser)</span></span> &#123;<br>    err := Body.Close()<br>    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>      fmt.Println(<span class=\"hljs-string\">&quot;close error&quot;</span>, err)<br>    &#125;<br>  &#125;(resp.Body)<br>  <span class=\"hljs-comment\">// 读取收到的数据</span><br>  body, err := io.ReadAll(resp.Body)<br>  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;read failed&quot;</span>, err)<br>  &#125;<br>  <span class=\"hljs-comment\">// 写入文件</span><br>  err = WriteFile(<span class=\"hljs-string\">&quot;./index.html&quot;</span>, body)<br>  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;=======failed=======&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br>  fmt.Println(<span class=\"hljs-string\">&quot;=======finished=======&quot;</span>)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">WriteFile</span><span class=\"hljs-params\">(filePath <span class=\"hljs-type\">string</span>, content []<span class=\"hljs-type\">byte</span>)</span></span> <span class=\"hljs-type\">error</span> &#123;<br>  file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class=\"hljs-number\">0666</span>)<br>  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;file: &#x27;&quot;</span> + filePath + <span class=\"hljs-string\">&quot;&#x27; open filed&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err<br>  &#125;<br>  <span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(file *os.File)</span></span> &#123;<br>    err := file.Close()<br>    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err<br>    &#125;<br>  &#125;(file)<br>  write := bufio.NewWriter(file)<br>  <span class=\"hljs-keyword\">if</span> _, err := write.Write(content); err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;file: &#x27;&quot;</span> + filePath + <span class=\"hljs-string\">&quot;&#x27; write failed&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>至此我们已经可以将baidu的首页是保存至本地。但这代码既不支持断点续传，也不能多个分片并行，不能满足我们的要求。可是通过这段代码，我们得以明白，下载器的核心就是下载数据，然后写入指定的位置接。接下来，我们要逐步完善它。</p>\n<h2 id=\"实现断点续传\"><a href=\"#实现断点续传\" class=\"headerlink\" title=\"实现断点续传\"></a>实现断点续传</h2><p>为什么先说断点续传，因为分片并行下载的前提就是支持断点续传</p>\n<h3 id=\"http协议如何做到断点续传？\"><a href=\"#http协议如何做到断点续传？\" class=\"headerlink\" title=\"http协议如何做到断点续传？\"></a>http协议如何做到断点续传？</h3><h3 id=\"如何分片写入文件\"><a href=\"#如何分片写入文件\" class=\"headerlink\" title=\"如何分片写入文件?\"></a>如何分片写入文件?</h3>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第一天，完成go下载器的搭建</p>\n</blockquote>\n<h2 id=\"原型设计\"><a href=\"#原型设计\" class=\"headerlink\" title=\"原型设计\"></a>原型设计</h2><p>首先我们要拆分问题，一个支持多任务，多分片，多协议，还能断点续传的下载器无疑是复杂的任务，一时半会儿想不出好的解决方案。所以先将问题拆分简化，刨除所有的定语，一个下载器首先要能发出请求，然后将收到的数据保存至文件，其次才是逐个完成定语对应的功能。</p>\n<h2 id=\"如何使用go完成http协议下载？\"><a href=\"#如何使用go完成http协议下载？\" class=\"headerlink\" title=\"如何使用go完成http协议下载？\"></a>如何使用go完成http协议下载？</h2><p>先写测试程序，目标：把baidu的首页html文件下载下来并保存到当前目录</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestDownload</span><span class=\"hljs-params\">(f *testing.T)</span></span> &#123;<br>  <span class=\"hljs-comment\">// 请求baidu首页</span><br>  resp, err := http.Get(<span class=\"hljs-string\">&quot;http://www.baidu.com&quot;</span>)<br>  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;error&quot;</span>, err)<br>  &#125;<br>  <span class=\"hljs-comment\">// 不要忘记结束时关闭IO流</span><br>  <span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(Body io.ReadCloser)</span></span> &#123;<br>    err := Body.Close()<br>    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>      fmt.Println(<span class=\"hljs-string\">&quot;close error&quot;</span>, err)<br>    &#125;<br>  &#125;(resp.Body)<br>  <span class=\"hljs-comment\">// 读取收到的数据</span><br>  body, err := io.ReadAll(resp.Body)<br>  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;read failed&quot;</span>, err)<br>  &#125;<br>  <span class=\"hljs-comment\">// 写入文件</span><br>  err = WriteFile(<span class=\"hljs-string\">&quot;./index.html&quot;</span>, body)<br>  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;=======failed=======&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br>  fmt.Println(<span class=\"hljs-string\">&quot;=======finished=======&quot;</span>)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">WriteFile</span><span class=\"hljs-params\">(filePath <span class=\"hljs-type\">string</span>, content []<span class=\"hljs-type\">byte</span>)</span></span> <span class=\"hljs-type\">error</span> &#123;<br>  file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class=\"hljs-number\">0666</span>)<br>  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;file: &#x27;&quot;</span> + filePath + <span class=\"hljs-string\">&quot;&#x27; open filed&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err<br>  &#125;<br>  <span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(file *os.File)</span></span> &#123;<br>    err := file.Close()<br>    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err<br>    &#125;<br>  &#125;(file)<br>  write := bufio.NewWriter(file)<br>  <span class=\"hljs-keyword\">if</span> _, err := write.Write(content); err != <span class=\"hljs-literal\">nil</span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;file: &#x27;&quot;</span> + filePath + <span class=\"hljs-string\">&quot;&#x27; write failed&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>至此我们已经可以将baidu的首页是保存至本地。但这代码既不支持断点续传，也不能多个分片并行，不能满足我们的要求。可是通过这段代码，我们得以明白，下载器的核心就是下载数据，然后写入指定的位置接。接下来，我们要逐步完善它。</p>\n<h2 id=\"实现断点续传\"><a href=\"#实现断点续传\" class=\"headerlink\" title=\"实现断点续传\"></a>实现断点续传</h2><p>为什么先说断点续传，因为分片并行下载的前提就是支持断点续传</p>\n<h3 id=\"http协议如何做到断点续传？\"><a href=\"#http协议如何做到断点续传？\" class=\"headerlink\" title=\"http协议如何做到断点续传？\"></a>http协议如何做到断点续传？</h3><h3 id=\"如何分片写入文件\"><a href=\"#如何分片写入文件\" class=\"headerlink\" title=\"如何分片写入文件?\"></a>如何分片写入文件?</h3>"},{"title":"Java.util中的容器——List篇","date":"2024-06-10T08:41:00.000Z","_content":"## 1. 继承结构\n\n可以看到\n\n![类图](/img/java-keypoints/List.svg)\n\n> 为什么ArrayList、Vector、LinkedList在继承了AbstractList之后还要再次申明实现了List接口呢？这是不是一种多余的行为？\n> 就目前的结果而言确实多余，但是在util里所有的容器中，他们都采用了类似的写法。而且就我所知Josh Bloch没有解释为什么，所以这个问题可能没有官方解释。\n> 我的理解是：在类定义中再次实现接口而不是通过继承抽象类获得接口的继承关系，意味着子类和接口有着明确的关系，不因父类的变化而变化。这在业务代码中是没哟意义的，但是作为标准库使用时就变得非常有必要，这样做可以避免修改的扩散。\n\n## 2. ArrayList\n\n### 2.1. EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的关系\n\n```java\n/**\n * Shared empty array instance used for empty instances.\n */\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n/**\n * Shared empty array instance used for default sized empty instances. We\n * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n * first element is added.\n */\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n\nArrayList定义了两个全局唯一的空对象数组用于表示空列表。其中`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`仅用于使用无参构造器创建的空列表对象。其他场景下，都使用`EMPTY_ELEMENTDATA`来表示空列表。为什么要分别使用两个空数组，为何不更极致一些只用一个空数组呢？\n\n答：为了精细化控制数组扩容长度。两者的分歧点在于`grow(int)`方法，使用无参构造器创建的列表在首次扩容时至少会被赋予10的长度。而通过反序列化、有参构造器创建出来的空数组，只会使用`EMPTY_ELEMENTDATA`，此时grow不受10的制约，会按照\n\n### 2.2. 方法内联优化\n\n在阅读源码时可以看到如下内容：\n\n```java\npublic boolean add(E e) {\n    modCount++;\n    add(e, elementData, size);\n    return true;\n}\n\n/**\n * This helper method split out from add(E) to keep method\n * bytecode size under 35 (the -XX:MaxInlineSize default value),\n * which helps when add(E) is called in a C1-compiled loop.\n */\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n```\n\n这个私有的add方法仅在add(E)中出现，注释中说明这么做的目的是为了让方法体的字节码小于35从而保证激活内联优化。那么，内联优化的原理是什么？\n\n### 并发修改的判断\n\n通过方法内final标记，以及独立的modcount计数器，数组长度来判断\n","source":"_posts/2024/java-list-keypoints.md","raw":"---\ntitle: Java.util中的容器——List篇\ndate: 2024-06-10 16:41:00\ntag:\n  - 每周一篇\n  - Java\n  - 源码分析\n---\n## 1. 继承结构\n\n可以看到\n\n![类图](/img/java-keypoints/List.svg)\n\n> 为什么ArrayList、Vector、LinkedList在继承了AbstractList之后还要再次申明实现了List接口呢？这是不是一种多余的行为？\n> 就目前的结果而言确实多余，但是在util里所有的容器中，他们都采用了类似的写法。而且就我所知Josh Bloch没有解释为什么，所以这个问题可能没有官方解释。\n> 我的理解是：在类定义中再次实现接口而不是通过继承抽象类获得接口的继承关系，意味着子类和接口有着明确的关系，不因父类的变化而变化。这在业务代码中是没哟意义的，但是作为标准库使用时就变得非常有必要，这样做可以避免修改的扩散。\n\n## 2. ArrayList\n\n### 2.1. EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的关系\n\n```java\n/**\n * Shared empty array instance used for empty instances.\n */\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n/**\n * Shared empty array instance used for default sized empty instances. We\n * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n * first element is added.\n */\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n\nArrayList定义了两个全局唯一的空对象数组用于表示空列表。其中`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`仅用于使用无参构造器创建的空列表对象。其他场景下，都使用`EMPTY_ELEMENTDATA`来表示空列表。为什么要分别使用两个空数组，为何不更极致一些只用一个空数组呢？\n\n答：为了精细化控制数组扩容长度。两者的分歧点在于`grow(int)`方法，使用无参构造器创建的列表在首次扩容时至少会被赋予10的长度。而通过反序列化、有参构造器创建出来的空数组，只会使用`EMPTY_ELEMENTDATA`，此时grow不受10的制约，会按照\n\n### 2.2. 方法内联优化\n\n在阅读源码时可以看到如下内容：\n\n```java\npublic boolean add(E e) {\n    modCount++;\n    add(e, elementData, size);\n    return true;\n}\n\n/**\n * This helper method split out from add(E) to keep method\n * bytecode size under 35 (the -XX:MaxInlineSize default value),\n * which helps when add(E) is called in a C1-compiled loop.\n */\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n```\n\n这个私有的add方法仅在add(E)中出现，注释中说明这么做的目的是为了让方法体的字节码小于35从而保证激活内联优化。那么，内联优化的原理是什么？\n\n### 并发修改的判断\n\n通过方法内final标记，以及独立的modcount计数器，数组长度来判断\n","slug":"2024/java-list-keypoints","published":1,"updated":"2024-06-15T10:38:35.366Z","_id":"clx9h4k2w0008cotgda0c48pj","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-继承结构\"><a href=\"#1-继承结构\" class=\"headerlink\" title=\"1. 继承结构\"></a>1. 继承结构</h2><p>可以看到</p>\n<p><img src=\"/img/java-keypoints/List.svg\" alt=\"类图\"></p>\n<blockquote>\n<p>为什么ArrayList、Vector、LinkedList在继承了AbstractList之后还要再次申明实现了List接口呢？这是不是一种多余的行为？<br>就目前的结果而言确实多余，但是在util里所有的容器中，他们都采用了类似的写法。而且就我所知Josh Bloch没有解释为什么，所以这个问题可能没有官方解释。<br>我的理解是：在类定义中再次实现接口而不是通过继承抽象类获得接口的继承关系，意味着子类和接口有着明确的关系，不因父类的变化而变化。这在业务代码中是没哟意义的，但是作为标准库使用时就变得非常有必要，这样做可以避免修改的扩散。</p>\n</blockquote>\n<h2 id=\"2-ArrayList\"><a href=\"#2-ArrayList\" class=\"headerlink\" title=\"2. ArrayList\"></a>2. ArrayList</h2><h3 id=\"2-1-EMPTY-ELEMENTDATA和DEFAULTCAPACITY-EMPTY-ELEMENTDATA的关系\"><a href=\"#2-1-EMPTY-ELEMENTDATA和DEFAULTCAPACITY-EMPTY-ELEMENTDATA的关系\" class=\"headerlink\" title=\"2.1. EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的关系\"></a>2.1. EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的关系</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Shared empty array instance used for empty instances.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Shared empty array instance used for default sized empty instances. We</span><br><span class=\"hljs-comment\"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class=\"hljs-comment\"> * first element is added.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>ArrayList定义了两个全局唯一的空对象数组用于表示空列表。其中<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>仅用于使用无参构造器创建的空列表对象。其他场景下，都使用<code>EMPTY_ELEMENTDATA</code>来表示空列表。为什么要分别使用两个空数组，为何不更极致一些只用一个空数组呢？</p>\n<p>答：为了精细化控制数组扩容长度。两者的分歧点在于<code>grow(int)</code>方法，使用无参构造器创建的列表在首次扩容时至少会被赋予10的长度。而通过反序列化、有参构造器创建出来的空数组，只会使用<code>EMPTY_ELEMENTDATA</code>，此时grow不受10的制约，会按照</p>\n<h3 id=\"2-2-方法内联优化\"><a href=\"#2-2-方法内联优化\" class=\"headerlink\" title=\"2.2. 方法内联优化\"></a>2.2. 方法内联优化</h3><p>在阅读源码时可以看到如下内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(E e)</span> &#123;<br>    modCount++;<br>    add(e, elementData, size);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * This helper method split out from add(E) to keep method</span><br><span class=\"hljs-comment\"> * bytecode size under 35 (the -XX:MaxInlineSize default value),</span><br><span class=\"hljs-comment\"> * which helps when add(E) is called in a C1-compiled loop.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(E e, Object[] elementData, <span class=\"hljs-type\">int</span> s)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (s == elementData.length)<br>        elementData = grow();<br>    elementData[s] = e;<br>    size = s + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个私有的add方法仅在add(E)中出现，注释中说明这么做的目的是为了让方法体的字节码小于35从而保证激活内联优化。那么，内联优化的原理是什么？</p>\n<h3 id=\"并发修改的判断\"><a href=\"#并发修改的判断\" class=\"headerlink\" title=\"并发修改的判断\"></a>并发修改的判断</h3><p>通过方法内final标记，以及独立的modcount计数器，数组长度来判断</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-继承结构\"><a href=\"#1-继承结构\" class=\"headerlink\" title=\"1. 继承结构\"></a>1. 继承结构</h2><p>可以看到</p>\n<p><img src=\"/img/java-keypoints/List.svg\" alt=\"类图\"></p>\n<blockquote>\n<p>为什么ArrayList、Vector、LinkedList在继承了AbstractList之后还要再次申明实现了List接口呢？这是不是一种多余的行为？<br>就目前的结果而言确实多余，但是在util里所有的容器中，他们都采用了类似的写法。而且就我所知Josh Bloch没有解释为什么，所以这个问题可能没有官方解释。<br>我的理解是：在类定义中再次实现接口而不是通过继承抽象类获得接口的继承关系，意味着子类和接口有着明确的关系，不因父类的变化而变化。这在业务代码中是没哟意义的，但是作为标准库使用时就变得非常有必要，这样做可以避免修改的扩散。</p>\n</blockquote>\n<h2 id=\"2-ArrayList\"><a href=\"#2-ArrayList\" class=\"headerlink\" title=\"2. ArrayList\"></a>2. ArrayList</h2><h3 id=\"2-1-EMPTY-ELEMENTDATA和DEFAULTCAPACITY-EMPTY-ELEMENTDATA的关系\"><a href=\"#2-1-EMPTY-ELEMENTDATA和DEFAULTCAPACITY-EMPTY-ELEMENTDATA的关系\" class=\"headerlink\" title=\"2.1. EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的关系\"></a>2.1. EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的关系</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Shared empty array instance used for empty instances.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Shared empty array instance used for default sized empty instances. We</span><br><span class=\"hljs-comment\"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class=\"hljs-comment\"> * first element is added.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>ArrayList定义了两个全局唯一的空对象数组用于表示空列表。其中<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>仅用于使用无参构造器创建的空列表对象。其他场景下，都使用<code>EMPTY_ELEMENTDATA</code>来表示空列表。为什么要分别使用两个空数组，为何不更极致一些只用一个空数组呢？</p>\n<p>答：为了精细化控制数组扩容长度。两者的分歧点在于<code>grow(int)</code>方法，使用无参构造器创建的列表在首次扩容时至少会被赋予10的长度。而通过反序列化、有参构造器创建出来的空数组，只会使用<code>EMPTY_ELEMENTDATA</code>，此时grow不受10的制约，会按照</p>\n<h3 id=\"2-2-方法内联优化\"><a href=\"#2-2-方法内联优化\" class=\"headerlink\" title=\"2.2. 方法内联优化\"></a>2.2. 方法内联优化</h3><p>在阅读源码时可以看到如下内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(E e)</span> &#123;<br>    modCount++;<br>    add(e, elementData, size);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * This helper method split out from add(E) to keep method</span><br><span class=\"hljs-comment\"> * bytecode size under 35 (the -XX:MaxInlineSize default value),</span><br><span class=\"hljs-comment\"> * which helps when add(E) is called in a C1-compiled loop.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(E e, Object[] elementData, <span class=\"hljs-type\">int</span> s)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (s == elementData.length)<br>        elementData = grow();<br>    elementData[s] = e;<br>    size = s + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个私有的add方法仅在add(E)中出现，注释中说明这么做的目的是为了让方法体的字节码小于35从而保证激活内联优化。那么，内联优化的原理是什么？</p>\n<h3 id=\"并发修改的判断\"><a href=\"#并发修改的判断\" class=\"headerlink\" title=\"并发修改的判断\"></a>并发修改的判断</h3><p>通过方法内final标记，以及独立的modcount计数器，数组长度来判断</p>\n"},{"title":"Spring boot启动过程分析","date":"2024-06-24T04:41:00.000Z","_content":"\n调用SpringbootApplication.run()之后到底发生了什么？\nSpring是如何启动应用的？\n拓展点有很多，我该选谁？\n过程中有哪些设计可以借鉴？\n\n## 1. 观察现象\n\n让我们看一段Spring Boot应用启动日志\n\n```log\n\n02:55:58.664 [main] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer\n02:55:58.705 [restartedMain] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::                (v3.2.0)\n\n2024-06-24T02:55:58.893+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : Starting SpringDemoApplication using Java 21 with PID 1364008 (\\spring-demo\\target\\classes started by adam in \\spring-demo)\n2024-06-24T02:55:58.894+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : No active profile set, falling back to 1 default profile: \"default\"\n2024-06-24T02:55:58.926+08:00  INFO 1364008 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable\n2024-06-24T02:55:58.926+08:00  INFO 1364008 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'\n2024-06-24T02:55:59.500+08:00  INFO 1364008 --- [  restartedMain] c.e.s.a.MyAppAutoConfiguration           : MyAppAutoConfiguration built!\n2024-06-24T02:55:59.526+08:00  INFO 1364008 --- [  restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729\n2024-06-24T02:55:59.612+08:00  INFO 1364008 --- [  restartedMain] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port 8080\n2024-06-24T02:55:59.613+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent[source=org.springframework.boot.web.embedded.netty.NettyWebServer@58fb4529]\n2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent\n2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent[source=org.springframework.boot.web.embedded.netty.NettyWebServer@58fb4529]\n2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.context.event.ContextRefreshedEvent\n2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : Started SpringDemoApplication in 0.913 seconds (process running for 1.276)\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@4a35486f]\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.context.event.ApplicationStartedEvent\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@4a35486f]\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.availability.AvailabilityChangeEvent\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.GammaRunner  : GammaRunner with highest precedence invoked\n2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.AlphaRunner  : AlphaRunner without order annotation invoked\n2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.BetaRunner   : BetaRunner without order annotation invoked\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@4a35486f]\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.context.event.ApplicationReadyEvent\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@4a35486f]\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.availability.AvailabilityChangeEvent\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n\n```\n\nSpring的启动日志中，总共出现了：\n\n- MyInitializer\n- MyAppAutoConfiguration\n- DemoListener\n- EmoListener\n- GoodListener\n- AlphaRunner\n- BetaRunner\n- GammaRunner\n\n共计8个自定义类，分属四种拓展形式。我们可以看到，它们的输出有特定顺序，并且可以人为调整。接下来，让我们阅读SPringbootApplication.run()方法的源码，了解Springboot是如何启动应用的。\n\n## 2. 第一步 SpringbootApplication.run()\n\n```java\n@SpringBootApplication\npublic class SpringDemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringDemoApplication.class, args);\n    }\n\n}\n```\n\n当我们执行上面这样的代码时，spring完成了两件工作：\n\n1. 创建`SpringApplication`实例\n2. 执行`SpringApplication`的run方法\n\n### 2.1. 创建`SpringBootApplication`实例\n\n```java\n// org.springframework.boot.SpringApplication\n\n/**\n * Create a new {@link SpringApplication} instance. The application context will load\n * beans from the specified primary sources (see {@link SpringApplication class-level}\n * documentation for details). The instance can be customized before calling\n * {@link #run(String...)}.\n * @param resourceLoader the resource loader to use\n * @param primarySources the primary bean sources\n * @see #run(Class, String[])\n * @see #setSources(Set)\n */\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    this.bootstrapRegistryInitializers = new ArrayList<>(\n            getSpringFactoriesInstances(BootstrapRegistryInitializer.class));\n    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n    this.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n\n这里创建了一个SpringApplication实例，`resourceLoader`为null，`primarySources`是我们的启动类`SpringDemoApplication.class`。先通过`WebApplicationType.deduceFromClasspath()`判断应用类型；然后通过`getSpringFactoriesInstances()`访问\\*.factories文件，以类似SPI加载的方式获取服务配置；最终完成SpringApplication实例的初始化工作。\n\n### 2.2. 执行SpringApplication的run方法\n\n```java\n/**\n * Run the Spring application, creating and refreshing a new\n * {@link ApplicationContext}.\n * @param args the application arguments (usually passed from a Java main method)\n * @return a running {@link ApplicationContext}\n */\npublic ConfigurableApplicationContext run(String... args) {\n  Startup startup = Startup.create();\n  if (this.registerShutdownHook) {\n    SpringApplication.shutdownHook.enableShutdownHookAddition();\n  }\n  DefaultBootstrapContext bootstrapContext = createBootstrapContext();\n  ConfigurableApplicationContext context = null;\n  configureHeadlessProperty();\n  SpringApplicationRunListeners listeners = getRunListeners(args);\n  listeners.starting(bootstrapContext, this.mainApplicationClass);\n  try {\n    ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n    ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n    Banner printedBanner = printBanner(environment);\n    context = createApplicationContext();\n    context.setApplicationStartup(this.applicationStartup);\n    prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n    refreshContext(context);\n    afterRefresh(context, applicationArguments);\n    startup.started();\n    if (this.logStartupInfo) {\n      new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), startup);\n    }\n    listeners.started(context, startup.timeTakenToStarted());\n    callRunners(context, applicationArguments);\n  }\n  catch (Throwable ex) {\n    if (ex instanceof AbandonedRunException) {\n      throw ex;\n    }\n    handleRunFailure(context, ex, listeners);\n    throw new IllegalStateException(ex);\n  }\n  try {\n    if (context.isRunning()) {\n      listeners.ready(context, startup.ready());\n    }\n  }\n  catch (Throwable ex) {\n    if (ex instanceof AbandonedRunException) {\n      throw ex;\n    }\n    handleRunFailure(context, ex, null);\n    throw new IllegalStateException(ex);\n  }\n  return context;\n}\n```\n\nrun方法的流程可以拆分为以下三个主要阶段：\n\n1. 准备阶段\n2. 启动阶段\n3. 善后阶段\n\n#### 2.2.1. 准备阶段\n\n```java\nStartup startup = Startup.create();\nif (this.registerShutdownHook) {\n  SpringApplication.shutdownHook.enableShutdownHookAddition();\n}\nDefaultBootstrapContext bootstrapContext = createBootstrapContext();\nConfigurableApplicationContext context = null;\nconfigureHeadlessProperty();\nSpringApplicationRunListeners listeners = getRunListeners(args);\nlisteners.starting(bootstrapContext, this.mainApplicationClass);\n```\n\n准备阶段按顺序完成以下工作：\n\n1. 调用Startup.create()创建启动标志\n2. 如果有注册关闭事件的生命周期钩子，开启对应的生命周期钩子\n3. 创建启动上下文\n4. 配置无头模式\n5. 获取监听器\n6. 发布启动事件\n\n其中，下面的日志发生在第三步，创建启动上下文时。\n\n```log\n02:55:58.664 [main] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer\n02:55:58.705 [restartedMain] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer\n```\n\n```java\nprivate DefaultBootstrapContext createBootstrapContext() {\n  DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();\n  this.bootstrapRegistryInitializers.forEach((initializer) -> initializer.initialize(bootstrapContext));\n  return bootstrapContext;\n}\n\n@Slf4j\npublic class MyInitializer implements BootstrapRegistryInitializer {\n    @Override\n    public void initialize(BootstrapRegistry registry) {\n        log.info(\"Initializing MyInitializer\");\n    }\n}\n```\n\n当调用forEach方法挨个执行从spring.factories中读取的`BootstrapRegistryInitializer`接口的实现类时，便会调用initialize接口，本例中仅输出一条日志。\n\n第5步获取监听器配置是一个重要的拓展模式。请注意`SpringApplicationRunListener`的定义：\n\n```java\n/**\n * Listener for the {@link SpringApplication} {@code run} method.\n * {@link SpringApplicationRunListener}s are loaded through the\n * {@link SpringFactoriesLoader} and should declare a public constructor that accepts a\n * {@link SpringApplication} instance and a {@code String[]} of arguments. A new\n * {@link SpringApplicationRunListener} instance will be created for each run.\n *\n * @author Phillip Webb\n * @author Dave Syer\n * @author Andy Wilkinson\n * @author Chris Bono\n * @since 1.0.0\n */\npublic interface SpringApplicationRunListener {\n\n\t/**\n\t * Called immediately when the run method has first started. Can be used for very\n\t * early initialization.\n\t * @param bootstrapContext the bootstrap context\n\t */\n\tdefault void starting(ConfigurableBootstrapContext bootstrapContext) {\n\t}\n\n\t/**\n\t * Called once the environment has been prepared, but before the\n\t * {@link ApplicationContext} has been created.\n\t * @param bootstrapContext the bootstrap context\n\t * @param environment the environment\n\t */\n\tdefault void environmentPrepared(ConfigurableBootstrapContext bootstrapContext,\n\t\t\tConfigurableEnvironment environment) {\n\t}\n\n\t/**\n\t * Called once the {@link ApplicationContext} has been created and prepared, but\n\t * before sources have been loaded.\n\t * @param context the application context\n\t */\n\tdefault void contextPrepared(ConfigurableApplicationContext context) {\n\t}\n\n\t/**\n\t * Called once the application context has been loaded but before it has been\n\t * refreshed.\n\t * @param context the application context\n\t */\n\tdefault void contextLoaded(ConfigurableApplicationContext context) {\n\t}\n\n\t/**\n\t * The context has been refreshed and the application has started but\n\t * {@link CommandLineRunner CommandLineRunners} and {@link ApplicationRunner\n\t * ApplicationRunners} have not been called.\n\t * @param context the application context.\n\t * @param timeTaken the time taken to start the application or {@code null} if unknown\n\t * @since 2.6.0\n\t */\n\tdefault void started(ConfigurableApplicationContext context, Duration timeTaken) {\n\t}\n\n\t/**\n\t * Called immediately before the run method finishes, when the application context has\n\t * been refreshed and all {@link CommandLineRunner CommandLineRunners} and\n\t * {@link ApplicationRunner ApplicationRunners} have been called.\n\t * @param context the application context.\n\t * @param timeTaken the time taken for the application to be ready or {@code null} if\n\t * unknown\n\t * @since 2.6.0\n\t */\n\tdefault void ready(ConfigurableApplicationContext context, Duration timeTaken) {\n\t}\n\n\t/**\n\t * Called when a failure occurs when running the application.\n\t * @param context the application context or {@code null} if a failure occurred before\n\t * the context was created\n\t * @param exception the failure\n\t * @since 2.0.0\n\t */\n\tdefault void failed(ConfigurableApplicationContext context, Throwable exception) {\n\t}\n\n}\n```\n\n可以看到，Springboot为上下文设置了七个生命周期状态，即七个拓展点。分别是：\n\n- starting——在run方法启动时触发，可以用于执行非常早期的初始化动作。通过run方法的源码可以知道，该钩子在创建好启动上下文（`DefaultBootstrapContext`）即被调用\n- environmentPrepared\n- contextPrepared\n- contextLoaded\n- started\n- ready\n- failed\n\n我们可以通过实现SpringApplicationRunListener接口并利用spring.factories将实现类植入spring中，用于在正确的生命周期钩子处完成目标工作。作为举例我们可以观察其中一个实现类`org.springframework.boot.context.event.EventPublishingRunListener`，正是这个类实现了将上下文钩子事件广播出去的需求。\n\n#### 2.2.2. 启动阶段\n\n```java\n//1. 准备环境参数\nApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\nConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);\nBanner printedBanner = printBanner(environment);\n//2. 创建应用上下文\ncontext = createApplicationContext();\ncontext.setApplicationStartup(this.applicationStartup);\n//3. 准备应用上下文\nprepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n//4. 刷新应用上下文\nrefreshContext(context);\nafterRefresh(context, applicationArguments);\nstartup.started();\nif (this.logStartupInfo) {\n  new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), startup);\n}\n//5. 调用生命周期函数\nlisteners.started(context, startup.timeTakenToStarted());\n//6. 调用Runner\ncallRunners(context, applicationArguments);\n```\n\n正式的应用上下文（区别于启动上下文）是在上述代码中创建并且配置的。大致步骤如下:\n\n1. 准备环境参数\n2. 创建应用上下文\n3. 准备应用上下文\n4. 刷新应用上下文\n5. 调用生命周期函数\n6. 调用Runner\n\n##### 2.2.2.1. 准备环境参数\n\n这一步以打印标题为结束标志，即我们常说的Banner。\n\n```log\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::                (v3.2.0)\n```\n\n`ApplicationArguments`对象代表了命令行启动时输入的参数\n\n`ConfigurableEnvironment`对象则表示读取到的环境变量\n\n##### 2.2.2.2. 创建应用上下文\n\n通过调用`ApplicationContextFactory`的抽象工厂方法，实际通过spring.factories委派至对应的工厂实现创建应用上下文。**一般我们在需要创建定制上下文时可以在此处利用spring.factories机制拓展。**\n\n> 本例中，系统委派至`ReactiveWebServerApplicationContextFactory`实现类。注意，spring的两个web实现，`ServletWebServerApplicationContextFactory`和`ReactiveWebServerApplicationContextFactory`都在工厂内实现了aot上下文和非aot上下文的创建。\n\n```java\n\t@Override\n\tpublic ConfigurableApplicationContext create(WebApplicationType webApplicationType) {\n\t\treturn (webApplicationType != WebApplicationType.REACTIVE) ? null : createContext();\n\t}\n\n\tprivate ConfigurableApplicationContext createContext() {\n\t\tif (!AotDetector.useGeneratedArtifacts()) {\n\t\t\treturn new AnnotationConfigReactiveWebServerApplicationContext();\n\t\t}\n\t\treturn new ReactiveWebServerApplicationContext();\n\t}\n```\n\n##### 2.2.2.3. 准备应用上下文\n\n```java\n\tprivate void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,\n\t\t\tConfigurableEnvironment environment, SpringApplicationRunListeners listeners,\n\t\t\tApplicationArguments applicationArguments, Banner printedBanner) {\n\t\tcontext.setEnvironment(environment);\n\t\tpostProcessApplicationContext(context);\n\t\taddAotGeneratedInitializerIfNecessary(this.initializers);\n\t\tapplyInitializers(context);\n\t\tlisteners.contextPrepared(context);\n\t\tbootstrapContext.close(context);\n\t\tif (this.logStartupInfo) {\n\t\t\tlogStartupInfo(context.getParent() == null);\n\t\t\tlogStartupProfileInfo(context);\n\t\t}\n\t\t// Add boot specific singleton beans\n\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\t\tbeanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n\t\tif (printedBanner != null) {\n\t\t\tbeanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n\t\t}\n\t\tif (beanFactory instanceof AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) {\n\t\t\tautowireCapableBeanFactory.setAllowCircularReferences(this.allowCircularReferences);\n\t\t\tif (beanFactory instanceof DefaultListableBeanFactory listableBeanFactory) {\n\t\t\t\tlistableBeanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n\t\t\t}\n\t\t}\n\t\tif (this.lazyInitialization) {\n\t\t\tcontext.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n\t\t}\n\t\tif (this.keepAlive) {\n\t\t\tKeepAlive keepAlive = new KeepAlive();\n\t\t\tkeepAlive.start();\n\t\t\tcontext.addApplicationListener(keepAlive);\n\t\t}\n\t\tcontext.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context));\n\t\tif (!AotDetector.useGeneratedArtifacts()) {\n\t\t\t// Load the sources\n\t\t\tSet<Object> sources = getAllSources();\n\t\t\tAssert.notEmpty(sources, \"Sources must not be empty\");\n\t\t\tload(context, sources.toArray(new Object[0]));\n\t\t}\n\t\tlisteners.contextLoaded(context);\n\t}\n```\n\nspring在此处完成上下文的初始化工作，诸如：为上下文设置环境变量，初始化Bean工厂的设定，执行`ApplicationContextInitializer`对上下文进行自定义初始化，注册启动参数以及Banner的单例，配置循环引用开关，注册懒加载处理器等等\n\n其中，有如下拓展点可用于定制:\n1. 通过继承SpringApplication类，重写postProcessApplicationContext方法实现上下文的调整。如默认的SpringApplication类在该方法中完成对beanNameGenerator、resourceLoader、conversionService的初始化设定\n2. 实现`ApplicationContextInitializer`，自定义上下文的初始化。ApplicationContextInitializer的实现类需要写在spring.factories中，以便于Spring在启动时可以将其载入SpringApplication类的initializers属性中。当执行至`applyInitializers`方法时，便会遍历`getInitializers`方法返回的列表，逐个调用加载的`ApplicationContextInitializer`实现类完成自定义初始化。需要注意，`getInitializers`方法会根据实现类上的Order注解进行排序。\n\n##### 2.2.2.4. 刷新应用上下文\n\n这一步非常重要，前面的步骤中我们仅完成了上下文的创建，基础参数设置和部分初始化工作，我们书写的bean并没有被注册到上下文中。Spring正是通过refresh操作完成所有自定义bean的注册和启动工作。以webflux的启动为例，这里的调用链有些复杂，请看下图说明：\n\n\n\n\n#### 2.2.3. 善后阶段\n\n\n## 3. 总结\n\n![启动流程图](/img/spring-boot-start.jpg)\n","source":"_posts/2024/deep-in-spring-boot-start.md","raw":"---\ntitle: Spring boot启动过程分析\ndate: 2024-06-24 12:41:00\ntag:\n  - 每周一篇\n  - Java\n  - 源码分析\n  - spring boot\n---\n\n调用SpringbootApplication.run()之后到底发生了什么？\nSpring是如何启动应用的？\n拓展点有很多，我该选谁？\n过程中有哪些设计可以借鉴？\n\n## 1. 观察现象\n\n让我们看一段Spring Boot应用启动日志\n\n```log\n\n02:55:58.664 [main] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer\n02:55:58.705 [restartedMain] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::                (v3.2.0)\n\n2024-06-24T02:55:58.893+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : Starting SpringDemoApplication using Java 21 with PID 1364008 (\\spring-demo\\target\\classes started by adam in \\spring-demo)\n2024-06-24T02:55:58.894+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : No active profile set, falling back to 1 default profile: \"default\"\n2024-06-24T02:55:58.926+08:00  INFO 1364008 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable\n2024-06-24T02:55:58.926+08:00  INFO 1364008 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'\n2024-06-24T02:55:59.500+08:00  INFO 1364008 --- [  restartedMain] c.e.s.a.MyAppAutoConfiguration           : MyAppAutoConfiguration built!\n2024-06-24T02:55:59.526+08:00  INFO 1364008 --- [  restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729\n2024-06-24T02:55:59.612+08:00  INFO 1364008 --- [  restartedMain] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port 8080\n2024-06-24T02:55:59.613+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent[source=org.springframework.boot.web.embedded.netty.NettyWebServer@58fb4529]\n2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent\n2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent[source=org.springframework.boot.web.embedded.netty.NettyWebServer@58fb4529]\n2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.context.event.ContextRefreshedEvent\n2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : Started SpringDemoApplication in 0.913 seconds (process running for 1.276)\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@4a35486f]\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.context.event.ApplicationStartedEvent\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@4a35486f]\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.availability.AvailabilityChangeEvent\n2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.GammaRunner  : GammaRunner with highest precedence invoked\n2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.AlphaRunner  : AlphaRunner without order annotation invoked\n2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.BetaRunner   : BetaRunner without order annotation invoked\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@4a35486f]\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.context.event.ApplicationReadyEvent\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@4a35486f]\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.availability.AvailabilityChangeEvent\n2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]\n\n```\n\nSpring的启动日志中，总共出现了：\n\n- MyInitializer\n- MyAppAutoConfiguration\n- DemoListener\n- EmoListener\n- GoodListener\n- AlphaRunner\n- BetaRunner\n- GammaRunner\n\n共计8个自定义类，分属四种拓展形式。我们可以看到，它们的输出有特定顺序，并且可以人为调整。接下来，让我们阅读SPringbootApplication.run()方法的源码，了解Springboot是如何启动应用的。\n\n## 2. 第一步 SpringbootApplication.run()\n\n```java\n@SpringBootApplication\npublic class SpringDemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringDemoApplication.class, args);\n    }\n\n}\n```\n\n当我们执行上面这样的代码时，spring完成了两件工作：\n\n1. 创建`SpringApplication`实例\n2. 执行`SpringApplication`的run方法\n\n### 2.1. 创建`SpringBootApplication`实例\n\n```java\n// org.springframework.boot.SpringApplication\n\n/**\n * Create a new {@link SpringApplication} instance. The application context will load\n * beans from the specified primary sources (see {@link SpringApplication class-level}\n * documentation for details). The instance can be customized before calling\n * {@link #run(String...)}.\n * @param resourceLoader the resource loader to use\n * @param primarySources the primary bean sources\n * @see #run(Class, String[])\n * @see #setSources(Set)\n */\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    this.bootstrapRegistryInitializers = new ArrayList<>(\n            getSpringFactoriesInstances(BootstrapRegistryInitializer.class));\n    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n    this.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n\n这里创建了一个SpringApplication实例，`resourceLoader`为null，`primarySources`是我们的启动类`SpringDemoApplication.class`。先通过`WebApplicationType.deduceFromClasspath()`判断应用类型；然后通过`getSpringFactoriesInstances()`访问\\*.factories文件，以类似SPI加载的方式获取服务配置；最终完成SpringApplication实例的初始化工作。\n\n### 2.2. 执行SpringApplication的run方法\n\n```java\n/**\n * Run the Spring application, creating and refreshing a new\n * {@link ApplicationContext}.\n * @param args the application arguments (usually passed from a Java main method)\n * @return a running {@link ApplicationContext}\n */\npublic ConfigurableApplicationContext run(String... args) {\n  Startup startup = Startup.create();\n  if (this.registerShutdownHook) {\n    SpringApplication.shutdownHook.enableShutdownHookAddition();\n  }\n  DefaultBootstrapContext bootstrapContext = createBootstrapContext();\n  ConfigurableApplicationContext context = null;\n  configureHeadlessProperty();\n  SpringApplicationRunListeners listeners = getRunListeners(args);\n  listeners.starting(bootstrapContext, this.mainApplicationClass);\n  try {\n    ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n    ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n    Banner printedBanner = printBanner(environment);\n    context = createApplicationContext();\n    context.setApplicationStartup(this.applicationStartup);\n    prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n    refreshContext(context);\n    afterRefresh(context, applicationArguments);\n    startup.started();\n    if (this.logStartupInfo) {\n      new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), startup);\n    }\n    listeners.started(context, startup.timeTakenToStarted());\n    callRunners(context, applicationArguments);\n  }\n  catch (Throwable ex) {\n    if (ex instanceof AbandonedRunException) {\n      throw ex;\n    }\n    handleRunFailure(context, ex, listeners);\n    throw new IllegalStateException(ex);\n  }\n  try {\n    if (context.isRunning()) {\n      listeners.ready(context, startup.ready());\n    }\n  }\n  catch (Throwable ex) {\n    if (ex instanceof AbandonedRunException) {\n      throw ex;\n    }\n    handleRunFailure(context, ex, null);\n    throw new IllegalStateException(ex);\n  }\n  return context;\n}\n```\n\nrun方法的流程可以拆分为以下三个主要阶段：\n\n1. 准备阶段\n2. 启动阶段\n3. 善后阶段\n\n#### 2.2.1. 准备阶段\n\n```java\nStartup startup = Startup.create();\nif (this.registerShutdownHook) {\n  SpringApplication.shutdownHook.enableShutdownHookAddition();\n}\nDefaultBootstrapContext bootstrapContext = createBootstrapContext();\nConfigurableApplicationContext context = null;\nconfigureHeadlessProperty();\nSpringApplicationRunListeners listeners = getRunListeners(args);\nlisteners.starting(bootstrapContext, this.mainApplicationClass);\n```\n\n准备阶段按顺序完成以下工作：\n\n1. 调用Startup.create()创建启动标志\n2. 如果有注册关闭事件的生命周期钩子，开启对应的生命周期钩子\n3. 创建启动上下文\n4. 配置无头模式\n5. 获取监听器\n6. 发布启动事件\n\n其中，下面的日志发生在第三步，创建启动上下文时。\n\n```log\n02:55:58.664 [main] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer\n02:55:58.705 [restartedMain] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer\n```\n\n```java\nprivate DefaultBootstrapContext createBootstrapContext() {\n  DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();\n  this.bootstrapRegistryInitializers.forEach((initializer) -> initializer.initialize(bootstrapContext));\n  return bootstrapContext;\n}\n\n@Slf4j\npublic class MyInitializer implements BootstrapRegistryInitializer {\n    @Override\n    public void initialize(BootstrapRegistry registry) {\n        log.info(\"Initializing MyInitializer\");\n    }\n}\n```\n\n当调用forEach方法挨个执行从spring.factories中读取的`BootstrapRegistryInitializer`接口的实现类时，便会调用initialize接口，本例中仅输出一条日志。\n\n第5步获取监听器配置是一个重要的拓展模式。请注意`SpringApplicationRunListener`的定义：\n\n```java\n/**\n * Listener for the {@link SpringApplication} {@code run} method.\n * {@link SpringApplicationRunListener}s are loaded through the\n * {@link SpringFactoriesLoader} and should declare a public constructor that accepts a\n * {@link SpringApplication} instance and a {@code String[]} of arguments. A new\n * {@link SpringApplicationRunListener} instance will be created for each run.\n *\n * @author Phillip Webb\n * @author Dave Syer\n * @author Andy Wilkinson\n * @author Chris Bono\n * @since 1.0.0\n */\npublic interface SpringApplicationRunListener {\n\n\t/**\n\t * Called immediately when the run method has first started. Can be used for very\n\t * early initialization.\n\t * @param bootstrapContext the bootstrap context\n\t */\n\tdefault void starting(ConfigurableBootstrapContext bootstrapContext) {\n\t}\n\n\t/**\n\t * Called once the environment has been prepared, but before the\n\t * {@link ApplicationContext} has been created.\n\t * @param bootstrapContext the bootstrap context\n\t * @param environment the environment\n\t */\n\tdefault void environmentPrepared(ConfigurableBootstrapContext bootstrapContext,\n\t\t\tConfigurableEnvironment environment) {\n\t}\n\n\t/**\n\t * Called once the {@link ApplicationContext} has been created and prepared, but\n\t * before sources have been loaded.\n\t * @param context the application context\n\t */\n\tdefault void contextPrepared(ConfigurableApplicationContext context) {\n\t}\n\n\t/**\n\t * Called once the application context has been loaded but before it has been\n\t * refreshed.\n\t * @param context the application context\n\t */\n\tdefault void contextLoaded(ConfigurableApplicationContext context) {\n\t}\n\n\t/**\n\t * The context has been refreshed and the application has started but\n\t * {@link CommandLineRunner CommandLineRunners} and {@link ApplicationRunner\n\t * ApplicationRunners} have not been called.\n\t * @param context the application context.\n\t * @param timeTaken the time taken to start the application or {@code null} if unknown\n\t * @since 2.6.0\n\t */\n\tdefault void started(ConfigurableApplicationContext context, Duration timeTaken) {\n\t}\n\n\t/**\n\t * Called immediately before the run method finishes, when the application context has\n\t * been refreshed and all {@link CommandLineRunner CommandLineRunners} and\n\t * {@link ApplicationRunner ApplicationRunners} have been called.\n\t * @param context the application context.\n\t * @param timeTaken the time taken for the application to be ready or {@code null} if\n\t * unknown\n\t * @since 2.6.0\n\t */\n\tdefault void ready(ConfigurableApplicationContext context, Duration timeTaken) {\n\t}\n\n\t/**\n\t * Called when a failure occurs when running the application.\n\t * @param context the application context or {@code null} if a failure occurred before\n\t * the context was created\n\t * @param exception the failure\n\t * @since 2.0.0\n\t */\n\tdefault void failed(ConfigurableApplicationContext context, Throwable exception) {\n\t}\n\n}\n```\n\n可以看到，Springboot为上下文设置了七个生命周期状态，即七个拓展点。分别是：\n\n- starting——在run方法启动时触发，可以用于执行非常早期的初始化动作。通过run方法的源码可以知道，该钩子在创建好启动上下文（`DefaultBootstrapContext`）即被调用\n- environmentPrepared\n- contextPrepared\n- contextLoaded\n- started\n- ready\n- failed\n\n我们可以通过实现SpringApplicationRunListener接口并利用spring.factories将实现类植入spring中，用于在正确的生命周期钩子处完成目标工作。作为举例我们可以观察其中一个实现类`org.springframework.boot.context.event.EventPublishingRunListener`，正是这个类实现了将上下文钩子事件广播出去的需求。\n\n#### 2.2.2. 启动阶段\n\n```java\n//1. 准备环境参数\nApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\nConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);\nBanner printedBanner = printBanner(environment);\n//2. 创建应用上下文\ncontext = createApplicationContext();\ncontext.setApplicationStartup(this.applicationStartup);\n//3. 准备应用上下文\nprepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n//4. 刷新应用上下文\nrefreshContext(context);\nafterRefresh(context, applicationArguments);\nstartup.started();\nif (this.logStartupInfo) {\n  new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), startup);\n}\n//5. 调用生命周期函数\nlisteners.started(context, startup.timeTakenToStarted());\n//6. 调用Runner\ncallRunners(context, applicationArguments);\n```\n\n正式的应用上下文（区别于启动上下文）是在上述代码中创建并且配置的。大致步骤如下:\n\n1. 准备环境参数\n2. 创建应用上下文\n3. 准备应用上下文\n4. 刷新应用上下文\n5. 调用生命周期函数\n6. 调用Runner\n\n##### 2.2.2.1. 准备环境参数\n\n这一步以打印标题为结束标志，即我们常说的Banner。\n\n```log\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::                (v3.2.0)\n```\n\n`ApplicationArguments`对象代表了命令行启动时输入的参数\n\n`ConfigurableEnvironment`对象则表示读取到的环境变量\n\n##### 2.2.2.2. 创建应用上下文\n\n通过调用`ApplicationContextFactory`的抽象工厂方法，实际通过spring.factories委派至对应的工厂实现创建应用上下文。**一般我们在需要创建定制上下文时可以在此处利用spring.factories机制拓展。**\n\n> 本例中，系统委派至`ReactiveWebServerApplicationContextFactory`实现类。注意，spring的两个web实现，`ServletWebServerApplicationContextFactory`和`ReactiveWebServerApplicationContextFactory`都在工厂内实现了aot上下文和非aot上下文的创建。\n\n```java\n\t@Override\n\tpublic ConfigurableApplicationContext create(WebApplicationType webApplicationType) {\n\t\treturn (webApplicationType != WebApplicationType.REACTIVE) ? null : createContext();\n\t}\n\n\tprivate ConfigurableApplicationContext createContext() {\n\t\tif (!AotDetector.useGeneratedArtifacts()) {\n\t\t\treturn new AnnotationConfigReactiveWebServerApplicationContext();\n\t\t}\n\t\treturn new ReactiveWebServerApplicationContext();\n\t}\n```\n\n##### 2.2.2.3. 准备应用上下文\n\n```java\n\tprivate void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,\n\t\t\tConfigurableEnvironment environment, SpringApplicationRunListeners listeners,\n\t\t\tApplicationArguments applicationArguments, Banner printedBanner) {\n\t\tcontext.setEnvironment(environment);\n\t\tpostProcessApplicationContext(context);\n\t\taddAotGeneratedInitializerIfNecessary(this.initializers);\n\t\tapplyInitializers(context);\n\t\tlisteners.contextPrepared(context);\n\t\tbootstrapContext.close(context);\n\t\tif (this.logStartupInfo) {\n\t\t\tlogStartupInfo(context.getParent() == null);\n\t\t\tlogStartupProfileInfo(context);\n\t\t}\n\t\t// Add boot specific singleton beans\n\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\t\tbeanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n\t\tif (printedBanner != null) {\n\t\t\tbeanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n\t\t}\n\t\tif (beanFactory instanceof AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) {\n\t\t\tautowireCapableBeanFactory.setAllowCircularReferences(this.allowCircularReferences);\n\t\t\tif (beanFactory instanceof DefaultListableBeanFactory listableBeanFactory) {\n\t\t\t\tlistableBeanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n\t\t\t}\n\t\t}\n\t\tif (this.lazyInitialization) {\n\t\t\tcontext.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n\t\t}\n\t\tif (this.keepAlive) {\n\t\t\tKeepAlive keepAlive = new KeepAlive();\n\t\t\tkeepAlive.start();\n\t\t\tcontext.addApplicationListener(keepAlive);\n\t\t}\n\t\tcontext.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context));\n\t\tif (!AotDetector.useGeneratedArtifacts()) {\n\t\t\t// Load the sources\n\t\t\tSet<Object> sources = getAllSources();\n\t\t\tAssert.notEmpty(sources, \"Sources must not be empty\");\n\t\t\tload(context, sources.toArray(new Object[0]));\n\t\t}\n\t\tlisteners.contextLoaded(context);\n\t}\n```\n\nspring在此处完成上下文的初始化工作，诸如：为上下文设置环境变量，初始化Bean工厂的设定，执行`ApplicationContextInitializer`对上下文进行自定义初始化，注册启动参数以及Banner的单例，配置循环引用开关，注册懒加载处理器等等\n\n其中，有如下拓展点可用于定制:\n1. 通过继承SpringApplication类，重写postProcessApplicationContext方法实现上下文的调整。如默认的SpringApplication类在该方法中完成对beanNameGenerator、resourceLoader、conversionService的初始化设定\n2. 实现`ApplicationContextInitializer`，自定义上下文的初始化。ApplicationContextInitializer的实现类需要写在spring.factories中，以便于Spring在启动时可以将其载入SpringApplication类的initializers属性中。当执行至`applyInitializers`方法时，便会遍历`getInitializers`方法返回的列表，逐个调用加载的`ApplicationContextInitializer`实现类完成自定义初始化。需要注意，`getInitializers`方法会根据实现类上的Order注解进行排序。\n\n##### 2.2.2.4. 刷新应用上下文\n\n这一步非常重要，前面的步骤中我们仅完成了上下文的创建，基础参数设置和部分初始化工作，我们书写的bean并没有被注册到上下文中。Spring正是通过refresh操作完成所有自定义bean的注册和启动工作。以webflux的启动为例，这里的调用链有些复杂，请看下图说明：\n\n\n\n\n#### 2.2.3. 善后阶段\n\n\n## 3. 总结\n\n![启动流程图](/img/spring-boot-start.jpg)\n","slug":"2024/deep-in-spring-boot-start","published":1,"updated":"2024-10-02T02:46:42.173Z","_id":"clxru55c30000ektg7c3l9fom","comments":1,"layout":"post","photos":[],"link":"","content":"<p>调用SpringbootApplication.run()之后到底发生了什么？<br>Spring是如何启动应用的？<br>拓展点有很多，我该选谁？<br>过程中有哪些设计可以借鉴？</p>\n<h2 id=\"1-观察现象\"><a href=\"#1-观察现象\" class=\"headerlink\" title=\"1. 观察现象\"></a>1. 观察现象</h2><p>让我们看一段Spring Boot应用启动日志</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs log\"><br>02:55:58.664 [main] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer<br>02:55:58.705 [restartedMain] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer<br><br>  .   ____          _            __ _ _<br> /\\\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \\ \\ \\ \\<br>( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\<br> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )<br>  &#x27;  |____| .__|_| |_|_| |_\\__, | / / / /<br> =========|_|==============|___/=/_/_/_/<br> :: Spring Boot ::                (v3.2.0)<br><br>2024-06-24T02:55:58.893+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : Starting SpringDemoApplication using Java 21 with PID 1364008 (\\spring-demo\\target\\classes started by adam in \\spring-demo)<br>2024-06-24T02:55:58.894+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : No active profile set, falling back to 1 default profile: &quot;default&quot;<br>2024-06-24T02:55:58.926+08:00  INFO 1364008 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set &#x27;spring.devtools.add-properties&#x27; to &#x27;false&#x27; to disable<br>2024-06-24T02:55:58.926+08:00  INFO 1364008 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the &#x27;logging.level.web&#x27; property to &#x27;DEBUG&#x27;<br>2024-06-24T02:55:59.500+08:00  INFO 1364008 --- [  restartedMain] c.e.s.a.MyAppAutoConfiguration           : MyAppAutoConfiguration built!<br>2024-06-24T02:55:59.526+08:00  INFO 1364008 --- [  restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729<br>2024-06-24T02:55:59.612+08:00  INFO 1364008 --- [  restartedMain] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port 8080<br>2024-06-24T02:55:59.613+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent[source=org.springframework.boot.web.embedded.netty.NettyWebServer@58fb4529]<br>2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent<br>2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent[source=org.springframework.boot.web.embedded.netty.NettyWebServer@58fb4529]<br>2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.context.event.ContextRefreshedEvent<br>2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : Started SpringDemoApplication in 0.913 seconds (process running for 1.276)<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@4a35486f]<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.context.event.ApplicationStartedEvent<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@4a35486f]<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.availability.AvailabilityChangeEvent<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.GammaRunner  : GammaRunner with highest precedence invoked<br>2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.AlphaRunner  : AlphaRunner without order annotation invoked<br>2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.BetaRunner   : BetaRunner without order annotation invoked<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@4a35486f]<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.context.event.ApplicationReadyEvent<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@4a35486f]<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.availability.AvailabilityChangeEvent<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br><br></code></pre></td></tr></table></figure>\n\n<p>Spring的启动日志中，总共出现了：</p>\n<ul>\n<li>MyInitializer</li>\n<li>MyAppAutoConfiguration</li>\n<li>DemoListener</li>\n<li>EmoListener</li>\n<li>GoodListener</li>\n<li>AlphaRunner</li>\n<li>BetaRunner</li>\n<li>GammaRunner</li>\n</ul>\n<p>共计8个自定义类，分属四种拓展形式。我们可以看到，它们的输出有特定顺序，并且可以人为调整。接下来，让我们阅读SPringbootApplication.run()方法的源码，了解Springboot是如何启动应用的。</p>\n<h2 id=\"2-第一步-SpringbootApplication-run\"><a href=\"#2-第一步-SpringbootApplication-run\" class=\"headerlink\" title=\"2. 第一步 SpringbootApplication.run()\"></a>2. 第一步 SpringbootApplication.run()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SpringDemoApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringDemoApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当我们执行上面这样的代码时，spring完成了两件工作：</p>\n<ol>\n<li>创建<code>SpringApplication</code>实例</li>\n<li>执行<code>SpringApplication</code>的run方法</li>\n</ol>\n<h3 id=\"2-1-创建SpringBootApplication实例\"><a href=\"#2-1-创建SpringBootApplication实例\" class=\"headerlink\" title=\"2.1. 创建SpringBootApplication实例\"></a>2.1. 创建<code>SpringBootApplication</code>实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// org.springframework.boot.SpringApplication</span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Create a new &#123;<span class=\"hljs-doctag\">@link</span> SpringApplication&#125; instance. The application context will load</span><br><span class=\"hljs-comment\"> * beans from the specified primary sources (see &#123;<span class=\"hljs-doctag\">@link</span> SpringApplication class-level&#125;</span><br><span class=\"hljs-comment\"> * documentation for details). The instance can be customized before calling</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> #run(String...)&#125;.</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> resourceLoader the resource loader to use</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> primarySources the primary bean sources</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@see</span> #run(Class, String[])</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@see</span> #setSources(Set)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">SpringApplication</span><span class=\"hljs-params\">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.resourceLoader = resourceLoader;<br>    Assert.notNull(primarySources, <span class=\"hljs-string\">&quot;PrimarySources must not be null&quot;</span>);<br>    <span class=\"hljs-built_in\">this</span>.primarySources = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));<br>    <span class=\"hljs-built_in\">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>    <span class=\"hljs-built_in\">this</span>.bootstrapRegistryInitializers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;(<br>            getSpringFactoriesInstances(BootstrapRegistryInitializer.class));<br>    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>    <span class=\"hljs-built_in\">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里创建了一个SpringApplication实例，<code>resourceLoader</code>为null，<code>primarySources</code>是我们的启动类<code>SpringDemoApplication.class</code>。先通过<code>WebApplicationType.deduceFromClasspath()</code>判断应用类型；然后通过<code>getSpringFactoriesInstances()</code>访问*.factories文件，以类似SPI加载的方式获取服务配置；最终完成SpringApplication实例的初始化工作。</p>\n<h3 id=\"2-2-执行SpringApplication的run方法\"><a href=\"#2-2-执行SpringApplication的run方法\" class=\"headerlink\" title=\"2.2. 执行SpringApplication的run方法\"></a>2.2. 执行SpringApplication的run方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Run the Spring application, creating and refreshing a new</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> ApplicationContext&#125;.</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> args the application arguments (usually passed from a Java main method)</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> a running &#123;<span class=\"hljs-doctag\">@link</span> ApplicationContext&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> ConfigurableApplicationContext <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(String... args)</span> &#123;<br>  <span class=\"hljs-type\">Startup</span> <span class=\"hljs-variable\">startup</span> <span class=\"hljs-operator\">=</span> Startup.create();<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.registerShutdownHook) &#123;<br>    SpringApplication.shutdownHook.enableShutdownHookAddition();<br>  &#125;<br>  <span class=\"hljs-type\">DefaultBootstrapContext</span> <span class=\"hljs-variable\">bootstrapContext</span> <span class=\"hljs-operator\">=</span> createBootstrapContext();<br>  <span class=\"hljs-type\">ConfigurableApplicationContext</span> <span class=\"hljs-variable\">context</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;<br>  configureHeadlessProperty();<br>  <span class=\"hljs-type\">SpringApplicationRunListeners</span> <span class=\"hljs-variable\">listeners</span> <span class=\"hljs-operator\">=</span> getRunListeners(args);<br>  listeners.starting(bootstrapContext, <span class=\"hljs-built_in\">this</span>.mainApplicationClass);<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-type\">ApplicationArguments</span> <span class=\"hljs-variable\">applicationArguments</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultApplicationArguments</span>(args);<br>    <span class=\"hljs-type\">ConfigurableEnvironment</span> <span class=\"hljs-variable\">environment</span> <span class=\"hljs-operator\">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>    <span class=\"hljs-type\">Banner</span> <span class=\"hljs-variable\">printedBanner</span> <span class=\"hljs-operator\">=</span> printBanner(environment);<br>    context = createApplicationContext();<br>    context.setApplicationStartup(<span class=\"hljs-built_in\">this</span>.applicationStartup);<br>    prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>    refreshContext(context);<br>    afterRefresh(context, applicationArguments);<br>    startup.started();<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.logStartupInfo) &#123;<br>      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StartupInfoLogger</span>(<span class=\"hljs-built_in\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), startup);<br>    &#125;<br>    listeners.started(context, startup.timeTakenToStarted());<br>    callRunners(context, applicationArguments);<br>  &#125;<br>  <span class=\"hljs-keyword\">catch</span> (Throwable ex) &#123;<br>    <span class=\"hljs-keyword\">if</span> (ex <span class=\"hljs-keyword\">instanceof</span> AbandonedRunException) &#123;<br>      <span class=\"hljs-keyword\">throw</span> ex;<br>    &#125;<br>    handleRunFailure(context, ex, listeners);<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalStateException</span>(ex);<br>  &#125;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (context.isRunning()) &#123;<br>      listeners.ready(context, startup.ready());<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">catch</span> (Throwable ex) &#123;<br>    <span class=\"hljs-keyword\">if</span> (ex <span class=\"hljs-keyword\">instanceof</span> AbandonedRunException) &#123;<br>      <span class=\"hljs-keyword\">throw</span> ex;<br>    &#125;<br>    handleRunFailure(context, ex, <span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalStateException</span>(ex);<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>run方法的流程可以拆分为以下三个主要阶段：</p>\n<ol>\n<li>准备阶段</li>\n<li>启动阶段</li>\n<li>善后阶段</li>\n</ol>\n<h4 id=\"2-2-1-准备阶段\"><a href=\"#2-2-1-准备阶段\" class=\"headerlink\" title=\"2.2.1. 准备阶段\"></a>2.2.1. 准备阶段</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Startup</span> <span class=\"hljs-variable\">startup</span> <span class=\"hljs-operator\">=</span> Startup.create();<br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.registerShutdownHook) &#123;<br>  SpringApplication.shutdownHook.enableShutdownHookAddition();<br>&#125;<br><span class=\"hljs-type\">DefaultBootstrapContext</span> <span class=\"hljs-variable\">bootstrapContext</span> <span class=\"hljs-operator\">=</span> createBootstrapContext();<br><span class=\"hljs-type\">ConfigurableApplicationContext</span> <span class=\"hljs-variable\">context</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;<br>configureHeadlessProperty();<br><span class=\"hljs-type\">SpringApplicationRunListeners</span> <span class=\"hljs-variable\">listeners</span> <span class=\"hljs-operator\">=</span> getRunListeners(args);<br>listeners.starting(bootstrapContext, <span class=\"hljs-built_in\">this</span>.mainApplicationClass);<br></code></pre></td></tr></table></figure>\n\n<p>准备阶段按顺序完成以下工作：</p>\n<ol>\n<li>调用Startup.create()创建启动标志</li>\n<li>如果有注册关闭事件的生命周期钩子，开启对应的生命周期钩子</li>\n<li>创建启动上下文</li>\n<li>配置无头模式</li>\n<li>获取监听器</li>\n<li>发布启动事件</li>\n</ol>\n<p>其中，下面的日志发生在第三步，创建启动上下文时。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs log\">02:55:58.664 [main] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer<br>02:55:58.705 [restartedMain] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> DefaultBootstrapContext <span class=\"hljs-title function_\">createBootstrapContext</span><span class=\"hljs-params\">()</span> &#123;<br>  <span class=\"hljs-type\">DefaultBootstrapContext</span> <span class=\"hljs-variable\">bootstrapContext</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultBootstrapContext</span>();<br>  <span class=\"hljs-built_in\">this</span>.bootstrapRegistryInitializers.forEach((initializer) -&gt; initializer.initialize(bootstrapContext));<br>  <span class=\"hljs-keyword\">return</span> bootstrapContext;<br>&#125;<br><br><span class=\"hljs-meta\">@Slf4j</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyInitializer</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">BootstrapRegistryInitializer</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initialize</span><span class=\"hljs-params\">(BootstrapRegistry registry)</span> &#123;<br>        log.info(<span class=\"hljs-string\">&quot;Initializing MyInitializer&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当调用forEach方法挨个执行从spring.factories中读取的<code>BootstrapRegistryInitializer</code>接口的实现类时，便会调用initialize接口，本例中仅输出一条日志。</p>\n<p>第5步获取监听器配置是一个重要的拓展模式。请注意<code>SpringApplicationRunListener</code>的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Listener for the &#123;<span class=\"hljs-doctag\">@link</span> SpringApplication&#125; &#123;<span class=\"hljs-doctag\">@code</span> run&#125; method.</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> SpringApplicationRunListener&#125;s are loaded through the</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> SpringFactoriesLoader&#125; and should declare a public constructor that accepts a</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> SpringApplication&#125; instance and a &#123;<span class=\"hljs-doctag\">@code</span> String[]&#125; of arguments. A new</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> SpringApplicationRunListener&#125; instance will be created for each run.</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> Phillip Webb</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> Dave Syer</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> Andy Wilkinson</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> Chris Bono</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@since</span> 1.0.0</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">SpringApplicationRunListener</span> &#123;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called immediately when the run method has first started. Can be used for very</span><br><span class=\"hljs-comment\">\t * early initialization.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> bootstrapContext the bootstrap context</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">starting</span><span class=\"hljs-params\">(ConfigurableBootstrapContext bootstrapContext)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called once the environment has been prepared, but before the</span><br><span class=\"hljs-comment\">\t * &#123;<span class=\"hljs-doctag\">@link</span> ApplicationContext&#125; has been created.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> bootstrapContext the bootstrap context</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> environment the environment</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">environmentPrepared</span><span class=\"hljs-params\">(ConfigurableBootstrapContext bootstrapContext,</span><br><span class=\"hljs-params\">\t\t\tConfigurableEnvironment environment)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called once the &#123;<span class=\"hljs-doctag\">@link</span> ApplicationContext&#125; has been created and prepared, but</span><br><span class=\"hljs-comment\">\t * before sources have been loaded.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">contextPrepared</span><span class=\"hljs-params\">(ConfigurableApplicationContext context)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called once the application context has been loaded but before it has been</span><br><span class=\"hljs-comment\">\t * refreshed.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">contextLoaded</span><span class=\"hljs-params\">(ConfigurableApplicationContext context)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * The context has been refreshed and the application has started but</span><br><span class=\"hljs-comment\">\t * &#123;<span class=\"hljs-doctag\">@link</span> CommandLineRunner CommandLineRunners&#125; and &#123;<span class=\"hljs-doctag\">@link</span> ApplicationRunner</span><br><span class=\"hljs-comment\">\t * ApplicationRunners&#125; have not been called.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> timeTaken the time taken to start the application or &#123;<span class=\"hljs-doctag\">@code</span> null&#125; if unknown</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@since</span> 2.6.0</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">started</span><span class=\"hljs-params\">(ConfigurableApplicationContext context, Duration timeTaken)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called immediately before the run method finishes, when the application context has</span><br><span class=\"hljs-comment\">\t * been refreshed and all &#123;<span class=\"hljs-doctag\">@link</span> CommandLineRunner CommandLineRunners&#125; and</span><br><span class=\"hljs-comment\">\t * &#123;<span class=\"hljs-doctag\">@link</span> ApplicationRunner ApplicationRunners&#125; have been called.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> timeTaken the time taken for the application to be ready or &#123;<span class=\"hljs-doctag\">@code</span> null&#125; if</span><br><span class=\"hljs-comment\">\t * unknown</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@since</span> 2.6.0</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">ready</span><span class=\"hljs-params\">(ConfigurableApplicationContext context, Duration timeTaken)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called when a failure occurs when running the application.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context or &#123;<span class=\"hljs-doctag\">@code</span> null&#125; if a failure occurred before</span><br><span class=\"hljs-comment\">\t * the context was created</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> exception the failure</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@since</span> 2.0.0</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">failed</span><span class=\"hljs-params\">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;<br>\t&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，Springboot为上下文设置了七个生命周期状态，即七个拓展点。分别是：</p>\n<ul>\n<li>starting——在run方法启动时触发，可以用于执行非常早期的初始化动作。通过run方法的源码可以知道，该钩子在创建好启动上下文（<code>DefaultBootstrapContext</code>）即被调用</li>\n<li>environmentPrepared</li>\n<li>contextPrepared</li>\n<li>contextLoaded</li>\n<li>started</li>\n<li>ready</li>\n<li>failed</li>\n</ul>\n<p>我们可以通过实现SpringApplicationRunListener接口并利用spring.factories将实现类植入spring中，用于在正确的生命周期钩子处完成目标工作。作为举例我们可以观察其中一个实现类<code>org.springframework.boot.context.event.EventPublishingRunListener</code>，正是这个类实现了将上下文钩子事件广播出去的需求。</p>\n<h4 id=\"2-2-2-启动阶段\"><a href=\"#2-2-2-启动阶段\" class=\"headerlink\" title=\"2.2.2. 启动阶段\"></a>2.2.2. 启动阶段</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//1. 准备环境参数</span><br><span class=\"hljs-type\">ApplicationArguments</span> <span class=\"hljs-variable\">applicationArguments</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultApplicationArguments</span>(args);<br><span class=\"hljs-type\">ConfigurableEnvironment</span> <span class=\"hljs-variable\">environment</span> <span class=\"hljs-operator\">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br><span class=\"hljs-type\">Banner</span> <span class=\"hljs-variable\">printedBanner</span> <span class=\"hljs-operator\">=</span> printBanner(environment);<br><span class=\"hljs-comment\">//2. 创建应用上下文</span><br>context = createApplicationContext();<br>context.setApplicationStartup(<span class=\"hljs-built_in\">this</span>.applicationStartup);<br><span class=\"hljs-comment\">//3. 准备应用上下文</span><br>prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br><span class=\"hljs-comment\">//4. 刷新应用上下文</span><br>refreshContext(context);<br>afterRefresh(context, applicationArguments);<br>startup.started();<br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.logStartupInfo) &#123;<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StartupInfoLogger</span>(<span class=\"hljs-built_in\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), startup);<br>&#125;<br><span class=\"hljs-comment\">//5. 调用生命周期函数</span><br>listeners.started(context, startup.timeTakenToStarted());<br><span class=\"hljs-comment\">//6. 调用Runner</span><br>callRunners(context, applicationArguments);<br></code></pre></td></tr></table></figure>\n\n<p>正式的应用上下文（区别于启动上下文）是在上述代码中创建并且配置的。大致步骤如下:</p>\n<ol>\n<li>准备环境参数</li>\n<li>创建应用上下文</li>\n<li>准备应用上下文</li>\n<li>刷新应用上下文</li>\n<li>调用生命周期函数</li>\n<li>调用Runner</li>\n</ol>\n<h5 id=\"2-2-2-1-准备环境参数\"><a href=\"#2-2-2-1-准备环境参数\" class=\"headerlink\" title=\"2.2.2.1. 准备环境参数\"></a>2.2.2.1. 准备环境参数</h5><p>这一步以打印标题为结束标志，即我们常说的Banner。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs log\">  .   ____          _            __ _ _<br> /\\\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \\ \\ \\ \\<br>( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\<br> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )<br>  &#x27;  |____| .__|_| |_|_| |_\\__, | / / / /<br> =========|_|==============|___/=/_/_/_/<br> :: Spring Boot ::                (v3.2.0)<br></code></pre></td></tr></table></figure>\n\n<p><code>ApplicationArguments</code>对象代表了命令行启动时输入的参数</p>\n<p><code>ConfigurableEnvironment</code>对象则表示读取到的环境变量</p>\n<h5 id=\"2-2-2-2-创建应用上下文\"><a href=\"#2-2-2-2-创建应用上下文\" class=\"headerlink\" title=\"2.2.2.2. 创建应用上下文\"></a>2.2.2.2. 创建应用上下文</h5><p>通过调用<code>ApplicationContextFactory</code>的抽象工厂方法，实际通过spring.factories委派至对应的工厂实现创建应用上下文。<strong>一般我们在需要创建定制上下文时可以在此处利用spring.factories机制拓展。</strong></p>\n<blockquote>\n<p>本例中，系统委派至<code>ReactiveWebServerApplicationContextFactory</code>实现类。注意，spring的两个web实现，<code>ServletWebServerApplicationContextFactory</code>和<code>ReactiveWebServerApplicationContextFactory</code>都在工厂内实现了aot上下文和非aot上下文的创建。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-keyword\">public</span> ConfigurableApplicationContext <span class=\"hljs-title function_\">create</span><span class=\"hljs-params\">(WebApplicationType webApplicationType)</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> (webApplicationType != WebApplicationType.REACTIVE) ? <span class=\"hljs-literal\">null</span> : createContext();<br>&#125;<br><br><span class=\"hljs-keyword\">private</span> ConfigurableApplicationContext <span class=\"hljs-title function_\">createContext</span><span class=\"hljs-params\">()</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> (!AotDetector.useGeneratedArtifacts()) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AnnotationConfigReactiveWebServerApplicationContext</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReactiveWebServerApplicationContext</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-2-3-准备应用上下文\"><a href=\"#2-2-2-3-准备应用上下文\" class=\"headerlink\" title=\"2.2.2.3. 准备应用上下文\"></a>2.2.2.3. 准备应用上下文</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">prepareContext</span><span class=\"hljs-params\">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,</span><br><span class=\"hljs-params\">\t\tConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span><br><span class=\"hljs-params\">\t\tApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;<br>\tcontext.setEnvironment(environment);<br>\tpostProcessApplicationContext(context);<br>\taddAotGeneratedInitializerIfNecessary(<span class=\"hljs-built_in\">this</span>.initializers);<br>\tapplyInitializers(context);<br>\tlisteners.contextPrepared(context);<br>\tbootstrapContext.close(context);<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.logStartupInfo) &#123;<br>\t\tlogStartupInfo(context.getParent() == <span class=\"hljs-literal\">null</span>);<br>\t\tlogStartupProfileInfo(context);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// Add boot specific singleton beans</span><br>\t<span class=\"hljs-type\">ConfigurableListableBeanFactory</span> <span class=\"hljs-variable\">beanFactory</span> <span class=\"hljs-operator\">=</span> context.getBeanFactory();<br>\tbeanFactory.registerSingleton(<span class=\"hljs-string\">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br>\t<span class=\"hljs-keyword\">if</span> (printedBanner != <span class=\"hljs-literal\">null</span>) &#123;<br>\t\tbeanFactory.registerSingleton(<span class=\"hljs-string\">&quot;springBootBanner&quot;</span>, printedBanner);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (beanFactory <span class=\"hljs-keyword\">instanceof</span> AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) &#123;<br>\t\tautowireCapableBeanFactory.setAllowCircularReferences(<span class=\"hljs-built_in\">this</span>.allowCircularReferences);<br>\t\t<span class=\"hljs-keyword\">if</span> (beanFactory <span class=\"hljs-keyword\">instanceof</span> DefaultListableBeanFactory listableBeanFactory) &#123;<br>\t\t\tlistableBeanFactory.setAllowBeanDefinitionOverriding(<span class=\"hljs-built_in\">this</span>.allowBeanDefinitionOverriding);<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.lazyInitialization) &#123;<br>\t\tcontext.addBeanFactoryPostProcessor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LazyInitializationBeanFactoryPostProcessor</span>());<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.keepAlive) &#123;<br>\t\t<span class=\"hljs-type\">KeepAlive</span> <span class=\"hljs-variable\">keepAlive</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">KeepAlive</span>();<br>\t\tkeepAlive.start();<br>\t\tcontext.addApplicationListener(keepAlive);<br>\t&#125;<br>\tcontext.addBeanFactoryPostProcessor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PropertySourceOrderingBeanFactoryPostProcessor</span>(context));<br>\t<span class=\"hljs-keyword\">if</span> (!AotDetector.useGeneratedArtifacts()) &#123;<br>\t\t<span class=\"hljs-comment\">// Load the sources</span><br>\t\tSet&lt;Object&gt; sources = getAllSources();<br>\t\tAssert.notEmpty(sources, <span class=\"hljs-string\">&quot;Sources must not be empty&quot;</span>);<br>\t\tload(context, sources.toArray(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[<span class=\"hljs-number\">0</span>]));<br>\t&#125;<br>\tlisteners.contextLoaded(context);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>spring在此处完成上下文的初始化工作，诸如：为上下文设置环境变量，初始化Bean工厂的设定，执行<code>ApplicationContextInitializer</code>对上下文进行自定义初始化，注册启动参数以及Banner的单例，配置循环引用开关，注册懒加载处理器等等</p>\n<p>其中，有如下拓展点可用于定制:</p>\n<ol>\n<li>通过继承SpringApplication类，重写postProcessApplicationContext方法实现上下文的调整。如默认的SpringApplication类在该方法中完成对beanNameGenerator、resourceLoader、conversionService的初始化设定</li>\n<li>实现<code>ApplicationContextInitializer</code>，自定义上下文的初始化。ApplicationContextInitializer的实现类需要写在spring.factories中，以便于Spring在启动时可以将其载入SpringApplication类的initializers属性中。当执行至<code>applyInitializers</code>方法时，便会遍历<code>getInitializers</code>方法返回的列表，逐个调用加载的<code>ApplicationContextInitializer</code>实现类完成自定义初始化。需要注意，<code>getInitializers</code>方法会根据实现类上的Order注解进行排序。</li>\n</ol>\n<h5 id=\"2-2-2-4-刷新应用上下文\"><a href=\"#2-2-2-4-刷新应用上下文\" class=\"headerlink\" title=\"2.2.2.4. 刷新应用上下文\"></a>2.2.2.4. 刷新应用上下文</h5><p>这一步非常重要，前面的步骤中我们仅完成了上下文的创建，基础参数设置和部分初始化工作，我们书写的bean并没有被注册到上下文中。Spring正是通过refresh操作完成所有自定义bean的注册和启动工作。以webflux的启动为例，这里的调用链有些复杂，请看下图说明：</p>\n<h4 id=\"2-2-3-善后阶段\"><a href=\"#2-2-3-善后阶段\" class=\"headerlink\" title=\"2.2.3. 善后阶段\"></a>2.2.3. 善后阶段</h4><h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h2><p><img src=\"/img/spring-boot-start.jpg\" alt=\"启动流程图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>调用SpringbootApplication.run()之后到底发生了什么？<br>Spring是如何启动应用的？<br>拓展点有很多，我该选谁？<br>过程中有哪些设计可以借鉴？</p>\n<h2 id=\"1-观察现象\"><a href=\"#1-观察现象\" class=\"headerlink\" title=\"1. 观察现象\"></a>1. 观察现象</h2><p>让我们看一段Spring Boot应用启动日志</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs log\"><br>02:55:58.664 [main] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer<br>02:55:58.705 [restartedMain] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer<br><br>  .   ____          _            __ _ _<br> /\\\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \\ \\ \\ \\<br>( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\<br> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )<br>  &#x27;  |____| .__|_| |_|_| |_\\__, | / / / /<br> =========|_|==============|___/=/_/_/_/<br> :: Spring Boot ::                (v3.2.0)<br><br>2024-06-24T02:55:58.893+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : Starting SpringDemoApplication using Java 21 with PID 1364008 (\\spring-demo\\target\\classes started by adam in \\spring-demo)<br>2024-06-24T02:55:58.894+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : No active profile set, falling back to 1 default profile: &quot;default&quot;<br>2024-06-24T02:55:58.926+08:00  INFO 1364008 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set &#x27;spring.devtools.add-properties&#x27; to &#x27;false&#x27; to disable<br>2024-06-24T02:55:58.926+08:00  INFO 1364008 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the &#x27;logging.level.web&#x27; property to &#x27;DEBUG&#x27;<br>2024-06-24T02:55:59.500+08:00  INFO 1364008 --- [  restartedMain] c.e.s.a.MyAppAutoConfiguration           : MyAppAutoConfiguration built!<br>2024-06-24T02:55:59.526+08:00  INFO 1364008 --- [  restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729<br>2024-06-24T02:55:59.612+08:00  INFO 1364008 --- [  restartedMain] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port 8080<br>2024-06-24T02:55:59.613+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent[source=org.springframework.boot.web.embedded.netty.NettyWebServer@58fb4529]<br>2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent<br>2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.web.reactive.context.ReactiveWebServerInitializedEvent[source=org.springframework.boot.web.embedded.netty.NettyWebServer@58fb4529]<br>2024-06-24T02:55:59.614+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.context.event.ContextRefreshedEvent<br>2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.617+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.SpringDemoApplication     : Started SpringDemoApplication in 0.913 seconds (process running for 1.276)<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@4a35486f]<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.context.event.ApplicationStartedEvent<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@4a35486f]<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.availability.AvailabilityChangeEvent<br>2024-06-24T02:55:59.618+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.GammaRunner  : GammaRunner with highest precedence invoked<br>2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.AlphaRunner  : AlphaRunner without order annotation invoked<br>2024-06-24T02:55:59.619+08:00  INFO 1364008 --- [  restartedMain] c.example.springdemo.runner.BetaRunner   : BetaRunner without order annotation invoked<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@4a35486f]<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.context.event.ApplicationReadyEvent<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@4a35486f]<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.GoodListener     : GoodListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.DemoListener     : Application event received: org.springframework.boot.availability.AvailabilityChangeEvent<br>2024-06-24T02:55:59.620+08:00  INFO 1364008 --- [  restartedMain] c.e.springdemo.listener.EmoListener      : EmoListener event receive event: org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@630d7a02, started on Mon Jun 24 02:55:58 CST 2024]<br><br></code></pre></td></tr></table></figure>\n\n<p>Spring的启动日志中，总共出现了：</p>\n<ul>\n<li>MyInitializer</li>\n<li>MyAppAutoConfiguration</li>\n<li>DemoListener</li>\n<li>EmoListener</li>\n<li>GoodListener</li>\n<li>AlphaRunner</li>\n<li>BetaRunner</li>\n<li>GammaRunner</li>\n</ul>\n<p>共计8个自定义类，分属四种拓展形式。我们可以看到，它们的输出有特定顺序，并且可以人为调整。接下来，让我们阅读SPringbootApplication.run()方法的源码，了解Springboot是如何启动应用的。</p>\n<h2 id=\"2-第一步-SpringbootApplication-run\"><a href=\"#2-第一步-SpringbootApplication-run\" class=\"headerlink\" title=\"2. 第一步 SpringbootApplication.run()\"></a>2. 第一步 SpringbootApplication.run()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SpringDemoApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringDemoApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当我们执行上面这样的代码时，spring完成了两件工作：</p>\n<ol>\n<li>创建<code>SpringApplication</code>实例</li>\n<li>执行<code>SpringApplication</code>的run方法</li>\n</ol>\n<h3 id=\"2-1-创建SpringBootApplication实例\"><a href=\"#2-1-创建SpringBootApplication实例\" class=\"headerlink\" title=\"2.1. 创建SpringBootApplication实例\"></a>2.1. 创建<code>SpringBootApplication</code>实例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// org.springframework.boot.SpringApplication</span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Create a new &#123;<span class=\"hljs-doctag\">@link</span> SpringApplication&#125; instance. The application context will load</span><br><span class=\"hljs-comment\"> * beans from the specified primary sources (see &#123;<span class=\"hljs-doctag\">@link</span> SpringApplication class-level&#125;</span><br><span class=\"hljs-comment\"> * documentation for details). The instance can be customized before calling</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> #run(String...)&#125;.</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> resourceLoader the resource loader to use</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> primarySources the primary bean sources</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@see</span> #run(Class, String[])</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@see</span> #setSources(Set)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">SpringApplication</span><span class=\"hljs-params\">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.resourceLoader = resourceLoader;<br>    Assert.notNull(primarySources, <span class=\"hljs-string\">&quot;PrimarySources must not be null&quot;</span>);<br>    <span class=\"hljs-built_in\">this</span>.primarySources = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));<br>    <span class=\"hljs-built_in\">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>    <span class=\"hljs-built_in\">this</span>.bootstrapRegistryInitializers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;(<br>            getSpringFactoriesInstances(BootstrapRegistryInitializer.class));<br>    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>    <span class=\"hljs-built_in\">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里创建了一个SpringApplication实例，<code>resourceLoader</code>为null，<code>primarySources</code>是我们的启动类<code>SpringDemoApplication.class</code>。先通过<code>WebApplicationType.deduceFromClasspath()</code>判断应用类型；然后通过<code>getSpringFactoriesInstances()</code>访问*.factories文件，以类似SPI加载的方式获取服务配置；最终完成SpringApplication实例的初始化工作。</p>\n<h3 id=\"2-2-执行SpringApplication的run方法\"><a href=\"#2-2-执行SpringApplication的run方法\" class=\"headerlink\" title=\"2.2. 执行SpringApplication的run方法\"></a>2.2. 执行SpringApplication的run方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Run the Spring application, creating and refreshing a new</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> ApplicationContext&#125;.</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> args the application arguments (usually passed from a Java main method)</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> a running &#123;<span class=\"hljs-doctag\">@link</span> ApplicationContext&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> ConfigurableApplicationContext <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(String... args)</span> &#123;<br>  <span class=\"hljs-type\">Startup</span> <span class=\"hljs-variable\">startup</span> <span class=\"hljs-operator\">=</span> Startup.create();<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.registerShutdownHook) &#123;<br>    SpringApplication.shutdownHook.enableShutdownHookAddition();<br>  &#125;<br>  <span class=\"hljs-type\">DefaultBootstrapContext</span> <span class=\"hljs-variable\">bootstrapContext</span> <span class=\"hljs-operator\">=</span> createBootstrapContext();<br>  <span class=\"hljs-type\">ConfigurableApplicationContext</span> <span class=\"hljs-variable\">context</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;<br>  configureHeadlessProperty();<br>  <span class=\"hljs-type\">SpringApplicationRunListeners</span> <span class=\"hljs-variable\">listeners</span> <span class=\"hljs-operator\">=</span> getRunListeners(args);<br>  listeners.starting(bootstrapContext, <span class=\"hljs-built_in\">this</span>.mainApplicationClass);<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-type\">ApplicationArguments</span> <span class=\"hljs-variable\">applicationArguments</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultApplicationArguments</span>(args);<br>    <span class=\"hljs-type\">ConfigurableEnvironment</span> <span class=\"hljs-variable\">environment</span> <span class=\"hljs-operator\">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>    <span class=\"hljs-type\">Banner</span> <span class=\"hljs-variable\">printedBanner</span> <span class=\"hljs-operator\">=</span> printBanner(environment);<br>    context = createApplicationContext();<br>    context.setApplicationStartup(<span class=\"hljs-built_in\">this</span>.applicationStartup);<br>    prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>    refreshContext(context);<br>    afterRefresh(context, applicationArguments);<br>    startup.started();<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.logStartupInfo) &#123;<br>      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StartupInfoLogger</span>(<span class=\"hljs-built_in\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), startup);<br>    &#125;<br>    listeners.started(context, startup.timeTakenToStarted());<br>    callRunners(context, applicationArguments);<br>  &#125;<br>  <span class=\"hljs-keyword\">catch</span> (Throwable ex) &#123;<br>    <span class=\"hljs-keyword\">if</span> (ex <span class=\"hljs-keyword\">instanceof</span> AbandonedRunException) &#123;<br>      <span class=\"hljs-keyword\">throw</span> ex;<br>    &#125;<br>    handleRunFailure(context, ex, listeners);<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalStateException</span>(ex);<br>  &#125;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (context.isRunning()) &#123;<br>      listeners.ready(context, startup.ready());<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">catch</span> (Throwable ex) &#123;<br>    <span class=\"hljs-keyword\">if</span> (ex <span class=\"hljs-keyword\">instanceof</span> AbandonedRunException) &#123;<br>      <span class=\"hljs-keyword\">throw</span> ex;<br>    &#125;<br>    handleRunFailure(context, ex, <span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalStateException</span>(ex);<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>run方法的流程可以拆分为以下三个主要阶段：</p>\n<ol>\n<li>准备阶段</li>\n<li>启动阶段</li>\n<li>善后阶段</li>\n</ol>\n<h4 id=\"2-2-1-准备阶段\"><a href=\"#2-2-1-准备阶段\" class=\"headerlink\" title=\"2.2.1. 准备阶段\"></a>2.2.1. 准备阶段</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Startup</span> <span class=\"hljs-variable\">startup</span> <span class=\"hljs-operator\">=</span> Startup.create();<br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.registerShutdownHook) &#123;<br>  SpringApplication.shutdownHook.enableShutdownHookAddition();<br>&#125;<br><span class=\"hljs-type\">DefaultBootstrapContext</span> <span class=\"hljs-variable\">bootstrapContext</span> <span class=\"hljs-operator\">=</span> createBootstrapContext();<br><span class=\"hljs-type\">ConfigurableApplicationContext</span> <span class=\"hljs-variable\">context</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;<br>configureHeadlessProperty();<br><span class=\"hljs-type\">SpringApplicationRunListeners</span> <span class=\"hljs-variable\">listeners</span> <span class=\"hljs-operator\">=</span> getRunListeners(args);<br>listeners.starting(bootstrapContext, <span class=\"hljs-built_in\">this</span>.mainApplicationClass);<br></code></pre></td></tr></table></figure>\n\n<p>准备阶段按顺序完成以下工作：</p>\n<ol>\n<li>调用Startup.create()创建启动标志</li>\n<li>如果有注册关闭事件的生命周期钩子，开启对应的生命周期钩子</li>\n<li>创建启动上下文</li>\n<li>配置无头模式</li>\n<li>获取监听器</li>\n<li>发布启动事件</li>\n</ol>\n<p>其中，下面的日志发生在第三步，创建启动上下文时。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs log\">02:55:58.664 [main] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer<br>02:55:58.705 [restartedMain] INFO com.example.springdemo.initializer.MyInitializer -- Initializing MyInitializer<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> DefaultBootstrapContext <span class=\"hljs-title function_\">createBootstrapContext</span><span class=\"hljs-params\">()</span> &#123;<br>  <span class=\"hljs-type\">DefaultBootstrapContext</span> <span class=\"hljs-variable\">bootstrapContext</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultBootstrapContext</span>();<br>  <span class=\"hljs-built_in\">this</span>.bootstrapRegistryInitializers.forEach((initializer) -&gt; initializer.initialize(bootstrapContext));<br>  <span class=\"hljs-keyword\">return</span> bootstrapContext;<br>&#125;<br><br><span class=\"hljs-meta\">@Slf4j</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyInitializer</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">BootstrapRegistryInitializer</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initialize</span><span class=\"hljs-params\">(BootstrapRegistry registry)</span> &#123;<br>        log.info(<span class=\"hljs-string\">&quot;Initializing MyInitializer&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当调用forEach方法挨个执行从spring.factories中读取的<code>BootstrapRegistryInitializer</code>接口的实现类时，便会调用initialize接口，本例中仅输出一条日志。</p>\n<p>第5步获取监听器配置是一个重要的拓展模式。请注意<code>SpringApplicationRunListener</code>的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Listener for the &#123;<span class=\"hljs-doctag\">@link</span> SpringApplication&#125; &#123;<span class=\"hljs-doctag\">@code</span> run&#125; method.</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> SpringApplicationRunListener&#125;s are loaded through the</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> SpringFactoriesLoader&#125; and should declare a public constructor that accepts a</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> SpringApplication&#125; instance and a &#123;<span class=\"hljs-doctag\">@code</span> String[]&#125; of arguments. A new</span><br><span class=\"hljs-comment\"> * &#123;<span class=\"hljs-doctag\">@link</span> SpringApplicationRunListener&#125; instance will be created for each run.</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> Phillip Webb</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> Dave Syer</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> Andy Wilkinson</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> Chris Bono</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@since</span> 1.0.0</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">SpringApplicationRunListener</span> &#123;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called immediately when the run method has first started. Can be used for very</span><br><span class=\"hljs-comment\">\t * early initialization.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> bootstrapContext the bootstrap context</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">starting</span><span class=\"hljs-params\">(ConfigurableBootstrapContext bootstrapContext)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called once the environment has been prepared, but before the</span><br><span class=\"hljs-comment\">\t * &#123;<span class=\"hljs-doctag\">@link</span> ApplicationContext&#125; has been created.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> bootstrapContext the bootstrap context</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> environment the environment</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">environmentPrepared</span><span class=\"hljs-params\">(ConfigurableBootstrapContext bootstrapContext,</span><br><span class=\"hljs-params\">\t\t\tConfigurableEnvironment environment)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called once the &#123;<span class=\"hljs-doctag\">@link</span> ApplicationContext&#125; has been created and prepared, but</span><br><span class=\"hljs-comment\">\t * before sources have been loaded.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">contextPrepared</span><span class=\"hljs-params\">(ConfigurableApplicationContext context)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called once the application context has been loaded but before it has been</span><br><span class=\"hljs-comment\">\t * refreshed.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">contextLoaded</span><span class=\"hljs-params\">(ConfigurableApplicationContext context)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * The context has been refreshed and the application has started but</span><br><span class=\"hljs-comment\">\t * &#123;<span class=\"hljs-doctag\">@link</span> CommandLineRunner CommandLineRunners&#125; and &#123;<span class=\"hljs-doctag\">@link</span> ApplicationRunner</span><br><span class=\"hljs-comment\">\t * ApplicationRunners&#125; have not been called.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> timeTaken the time taken to start the application or &#123;<span class=\"hljs-doctag\">@code</span> null&#125; if unknown</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@since</span> 2.6.0</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">started</span><span class=\"hljs-params\">(ConfigurableApplicationContext context, Duration timeTaken)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called immediately before the run method finishes, when the application context has</span><br><span class=\"hljs-comment\">\t * been refreshed and all &#123;<span class=\"hljs-doctag\">@link</span> CommandLineRunner CommandLineRunners&#125; and</span><br><span class=\"hljs-comment\">\t * &#123;<span class=\"hljs-doctag\">@link</span> ApplicationRunner ApplicationRunners&#125; have been called.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> timeTaken the time taken for the application to be ready or &#123;<span class=\"hljs-doctag\">@code</span> null&#125; if</span><br><span class=\"hljs-comment\">\t * unknown</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@since</span> 2.6.0</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">ready</span><span class=\"hljs-params\">(ConfigurableApplicationContext context, Duration timeTaken)</span> &#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Called when a failure occurs when running the application.</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> context the application context or &#123;<span class=\"hljs-doctag\">@code</span> null&#125; if a failure occurred before</span><br><span class=\"hljs-comment\">\t * the context was created</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@param</span> exception the failure</span><br><span class=\"hljs-comment\">\t * <span class=\"hljs-doctag\">@since</span> 2.0.0</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">failed</span><span class=\"hljs-params\">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;<br>\t&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，Springboot为上下文设置了七个生命周期状态，即七个拓展点。分别是：</p>\n<ul>\n<li>starting——在run方法启动时触发，可以用于执行非常早期的初始化动作。通过run方法的源码可以知道，该钩子在创建好启动上下文（<code>DefaultBootstrapContext</code>）即被调用</li>\n<li>environmentPrepared</li>\n<li>contextPrepared</li>\n<li>contextLoaded</li>\n<li>started</li>\n<li>ready</li>\n<li>failed</li>\n</ul>\n<p>我们可以通过实现SpringApplicationRunListener接口并利用spring.factories将实现类植入spring中，用于在正确的生命周期钩子处完成目标工作。作为举例我们可以观察其中一个实现类<code>org.springframework.boot.context.event.EventPublishingRunListener</code>，正是这个类实现了将上下文钩子事件广播出去的需求。</p>\n<h4 id=\"2-2-2-启动阶段\"><a href=\"#2-2-2-启动阶段\" class=\"headerlink\" title=\"2.2.2. 启动阶段\"></a>2.2.2. 启动阶段</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//1. 准备环境参数</span><br><span class=\"hljs-type\">ApplicationArguments</span> <span class=\"hljs-variable\">applicationArguments</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultApplicationArguments</span>(args);<br><span class=\"hljs-type\">ConfigurableEnvironment</span> <span class=\"hljs-variable\">environment</span> <span class=\"hljs-operator\">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br><span class=\"hljs-type\">Banner</span> <span class=\"hljs-variable\">printedBanner</span> <span class=\"hljs-operator\">=</span> printBanner(environment);<br><span class=\"hljs-comment\">//2. 创建应用上下文</span><br>context = createApplicationContext();<br>context.setApplicationStartup(<span class=\"hljs-built_in\">this</span>.applicationStartup);<br><span class=\"hljs-comment\">//3. 准备应用上下文</span><br>prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br><span class=\"hljs-comment\">//4. 刷新应用上下文</span><br>refreshContext(context);<br>afterRefresh(context, applicationArguments);<br>startup.started();<br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.logStartupInfo) &#123;<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StartupInfoLogger</span>(<span class=\"hljs-built_in\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), startup);<br>&#125;<br><span class=\"hljs-comment\">//5. 调用生命周期函数</span><br>listeners.started(context, startup.timeTakenToStarted());<br><span class=\"hljs-comment\">//6. 调用Runner</span><br>callRunners(context, applicationArguments);<br></code></pre></td></tr></table></figure>\n\n<p>正式的应用上下文（区别于启动上下文）是在上述代码中创建并且配置的。大致步骤如下:</p>\n<ol>\n<li>准备环境参数</li>\n<li>创建应用上下文</li>\n<li>准备应用上下文</li>\n<li>刷新应用上下文</li>\n<li>调用生命周期函数</li>\n<li>调用Runner</li>\n</ol>\n<h5 id=\"2-2-2-1-准备环境参数\"><a href=\"#2-2-2-1-准备环境参数\" class=\"headerlink\" title=\"2.2.2.1. 准备环境参数\"></a>2.2.2.1. 准备环境参数</h5><p>这一步以打印标题为结束标志，即我们常说的Banner。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs log\">  .   ____          _            __ _ _<br> /\\\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \\ \\ \\ \\<br>( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\<br> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )<br>  &#x27;  |____| .__|_| |_|_| |_\\__, | / / / /<br> =========|_|==============|___/=/_/_/_/<br> :: Spring Boot ::                (v3.2.0)<br></code></pre></td></tr></table></figure>\n\n<p><code>ApplicationArguments</code>对象代表了命令行启动时输入的参数</p>\n<p><code>ConfigurableEnvironment</code>对象则表示读取到的环境变量</p>\n<h5 id=\"2-2-2-2-创建应用上下文\"><a href=\"#2-2-2-2-创建应用上下文\" class=\"headerlink\" title=\"2.2.2.2. 创建应用上下文\"></a>2.2.2.2. 创建应用上下文</h5><p>通过调用<code>ApplicationContextFactory</code>的抽象工厂方法，实际通过spring.factories委派至对应的工厂实现创建应用上下文。<strong>一般我们在需要创建定制上下文时可以在此处利用spring.factories机制拓展。</strong></p>\n<blockquote>\n<p>本例中，系统委派至<code>ReactiveWebServerApplicationContextFactory</code>实现类。注意，spring的两个web实现，<code>ServletWebServerApplicationContextFactory</code>和<code>ReactiveWebServerApplicationContextFactory</code>都在工厂内实现了aot上下文和非aot上下文的创建。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-keyword\">public</span> ConfigurableApplicationContext <span class=\"hljs-title function_\">create</span><span class=\"hljs-params\">(WebApplicationType webApplicationType)</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> (webApplicationType != WebApplicationType.REACTIVE) ? <span class=\"hljs-literal\">null</span> : createContext();<br>&#125;<br><br><span class=\"hljs-keyword\">private</span> ConfigurableApplicationContext <span class=\"hljs-title function_\">createContext</span><span class=\"hljs-params\">()</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> (!AotDetector.useGeneratedArtifacts()) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AnnotationConfigReactiveWebServerApplicationContext</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReactiveWebServerApplicationContext</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-2-3-准备应用上下文\"><a href=\"#2-2-2-3-准备应用上下文\" class=\"headerlink\" title=\"2.2.2.3. 准备应用上下文\"></a>2.2.2.3. 准备应用上下文</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">prepareContext</span><span class=\"hljs-params\">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,</span><br><span class=\"hljs-params\">\t\tConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span><br><span class=\"hljs-params\">\t\tApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;<br>\tcontext.setEnvironment(environment);<br>\tpostProcessApplicationContext(context);<br>\taddAotGeneratedInitializerIfNecessary(<span class=\"hljs-built_in\">this</span>.initializers);<br>\tapplyInitializers(context);<br>\tlisteners.contextPrepared(context);<br>\tbootstrapContext.close(context);<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.logStartupInfo) &#123;<br>\t\tlogStartupInfo(context.getParent() == <span class=\"hljs-literal\">null</span>);<br>\t\tlogStartupProfileInfo(context);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// Add boot specific singleton beans</span><br>\t<span class=\"hljs-type\">ConfigurableListableBeanFactory</span> <span class=\"hljs-variable\">beanFactory</span> <span class=\"hljs-operator\">=</span> context.getBeanFactory();<br>\tbeanFactory.registerSingleton(<span class=\"hljs-string\">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br>\t<span class=\"hljs-keyword\">if</span> (printedBanner != <span class=\"hljs-literal\">null</span>) &#123;<br>\t\tbeanFactory.registerSingleton(<span class=\"hljs-string\">&quot;springBootBanner&quot;</span>, printedBanner);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (beanFactory <span class=\"hljs-keyword\">instanceof</span> AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) &#123;<br>\t\tautowireCapableBeanFactory.setAllowCircularReferences(<span class=\"hljs-built_in\">this</span>.allowCircularReferences);<br>\t\t<span class=\"hljs-keyword\">if</span> (beanFactory <span class=\"hljs-keyword\">instanceof</span> DefaultListableBeanFactory listableBeanFactory) &#123;<br>\t\t\tlistableBeanFactory.setAllowBeanDefinitionOverriding(<span class=\"hljs-built_in\">this</span>.allowBeanDefinitionOverriding);<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.lazyInitialization) &#123;<br>\t\tcontext.addBeanFactoryPostProcessor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LazyInitializationBeanFactoryPostProcessor</span>());<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.keepAlive) &#123;<br>\t\t<span class=\"hljs-type\">KeepAlive</span> <span class=\"hljs-variable\">keepAlive</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">KeepAlive</span>();<br>\t\tkeepAlive.start();<br>\t\tcontext.addApplicationListener(keepAlive);<br>\t&#125;<br>\tcontext.addBeanFactoryPostProcessor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PropertySourceOrderingBeanFactoryPostProcessor</span>(context));<br>\t<span class=\"hljs-keyword\">if</span> (!AotDetector.useGeneratedArtifacts()) &#123;<br>\t\t<span class=\"hljs-comment\">// Load the sources</span><br>\t\tSet&lt;Object&gt; sources = getAllSources();<br>\t\tAssert.notEmpty(sources, <span class=\"hljs-string\">&quot;Sources must not be empty&quot;</span>);<br>\t\tload(context, sources.toArray(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[<span class=\"hljs-number\">0</span>]));<br>\t&#125;<br>\tlisteners.contextLoaded(context);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>spring在此处完成上下文的初始化工作，诸如：为上下文设置环境变量，初始化Bean工厂的设定，执行<code>ApplicationContextInitializer</code>对上下文进行自定义初始化，注册启动参数以及Banner的单例，配置循环引用开关，注册懒加载处理器等等</p>\n<p>其中，有如下拓展点可用于定制:</p>\n<ol>\n<li>通过继承SpringApplication类，重写postProcessApplicationContext方法实现上下文的调整。如默认的SpringApplication类在该方法中完成对beanNameGenerator、resourceLoader、conversionService的初始化设定</li>\n<li>实现<code>ApplicationContextInitializer</code>，自定义上下文的初始化。ApplicationContextInitializer的实现类需要写在spring.factories中，以便于Spring在启动时可以将其载入SpringApplication类的initializers属性中。当执行至<code>applyInitializers</code>方法时，便会遍历<code>getInitializers</code>方法返回的列表，逐个调用加载的<code>ApplicationContextInitializer</code>实现类完成自定义初始化。需要注意，<code>getInitializers</code>方法会根据实现类上的Order注解进行排序。</li>\n</ol>\n<h5 id=\"2-2-2-4-刷新应用上下文\"><a href=\"#2-2-2-4-刷新应用上下文\" class=\"headerlink\" title=\"2.2.2.4. 刷新应用上下文\"></a>2.2.2.4. 刷新应用上下文</h5><p>这一步非常重要，前面的步骤中我们仅完成了上下文的创建，基础参数设置和部分初始化工作，我们书写的bean并没有被注册到上下文中。Spring正是通过refresh操作完成所有自定义bean的注册和启动工作。以webflux的启动为例，这里的调用链有些复杂，请看下图说明：</p>\n<h4 id=\"2-2-3-善后阶段\"><a href=\"#2-2-3-善后阶段\" class=\"headerlink\" title=\"2.2.3. 善后阶段\"></a>2.2.3. 善后阶段</h4><h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h2><p><img src=\"/img/spring-boot-start.jpg\" alt=\"启动流程图\"></p>\n"},{"title":"设计模式——策略模式","date":"2024-06-12T18:10:00.000Z","_content":"\n","source":"_posts/2024/desgin-patterns-2.md","raw":"---\ntitle: 设计模式——策略模式\ndate: 2024-06-13 02:10:00\ntag:\n  - 设计模式\n---\n\n","slug":"2024/desgin-patterns-2","published":1,"updated":"2024-06-14T16:47:45.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxru55cb0007ektg2lbh22cq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"设计模式——写在最前面","date":"2024-06-12T18:10:00.000Z","_content":"## 什么是设计模式\n\nwiki中介绍，模式是存在于人们感知到的世界、人造设计或抽象思想中的规律。而设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。\n\n## 为什么需要设计模式\n\n1. 设计模式是针对软件设计中常见问题的工具箱， 其中的工具就是各种经过实践验证的解决方案。\n2. 设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。\n\n## 有多少种设计模式，如何对他们进行分类\n\n最基础的、 底层的模式通常被称为惯用技巧。 这类模式一般只能在一种编程语言中使用。\n\n最通用的、 高层的模式是构架模式。 开发者可以在任何编程语言中使用这类模式。 与其他模式不同， 它们可用于整个应用程序的架构设计。\n\n《GoF》中提出了23种设计模式，并将其归类为创建型模式，结构型模式，行为模式三类。但人们在后续的工作和学习中又总结并丰富了更多的模式，如《反应式设计模式》一书中又新增6类，27种架构模式。他们的关系图如下：\n\n![GoF23](/img/design-patterns/gof.svg)\n![反应式设计模式](/img/design-patterns/reactor.svg)\n","source":"_posts/2024/desgin-patterns-1.md","raw":"---\ntitle: 设计模式——写在最前面\ndate: 2024-06-13 02:10:00\ntag:\n  - 设计模式\n---\n## 什么是设计模式\n\nwiki中介绍，模式是存在于人们感知到的世界、人造设计或抽象思想中的规律。而设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。\n\n## 为什么需要设计模式\n\n1. 设计模式是针对软件设计中常见问题的工具箱， 其中的工具就是各种经过实践验证的解决方案。\n2. 设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。\n\n## 有多少种设计模式，如何对他们进行分类\n\n最基础的、 底层的模式通常被称为惯用技巧。 这类模式一般只能在一种编程语言中使用。\n\n最通用的、 高层的模式是构架模式。 开发者可以在任何编程语言中使用这类模式。 与其他模式不同， 它们可用于整个应用程序的架构设计。\n\n《GoF》中提出了23种设计模式，并将其归类为创建型模式，结构型模式，行为模式三类。但人们在后续的工作和学习中又总结并丰富了更多的模式，如《反应式设计模式》一书中又新增6类，27种架构模式。他们的关系图如下：\n\n![GoF23](/img/design-patterns/gof.svg)\n![反应式设计模式](/img/design-patterns/reactor.svg)\n","slug":"2024/desgin-patterns-1","published":1,"updated":"2024-06-12T18:59:00.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxru55cb0008ektg07d811go","content":"<h2 id=\"什么是设计模式\"><a href=\"#什么是设计模式\" class=\"headerlink\" title=\"什么是设计模式\"></a>什么是设计模式</h2><p>wiki中介绍，模式是存在于人们感知到的世界、人造设计或抽象思想中的规律。而设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p>\n<h2 id=\"为什么需要设计模式\"><a href=\"#为什么需要设计模式\" class=\"headerlink\" title=\"为什么需要设计模式\"></a>为什么需要设计模式</h2><ol>\n<li>设计模式是针对软件设计中常见问题的工具箱， 其中的工具就是各种经过实践验证的解决方案。</li>\n<li>设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。</li>\n</ol>\n<h2 id=\"有多少种设计模式，如何对他们进行分类\"><a href=\"#有多少种设计模式，如何对他们进行分类\" class=\"headerlink\" title=\"有多少种设计模式，如何对他们进行分类\"></a>有多少种设计模式，如何对他们进行分类</h2><p>最基础的、 底层的模式通常被称为惯用技巧。 这类模式一般只能在一种编程语言中使用。</p>\n<p>最通用的、 高层的模式是构架模式。 开发者可以在任何编程语言中使用这类模式。 与其他模式不同， 它们可用于整个应用程序的架构设计。</p>\n<p>《GoF》中提出了23种设计模式，并将其归类为创建型模式，结构型模式，行为模式三类。但人们在后续的工作和学习中又总结并丰富了更多的模式，如《反应式设计模式》一书中又新增6类，27种架构模式。他们的关系图如下：</p>\n<p><img src=\"/img/design-patterns/gof.svg\" alt=\"GoF23\"><br><img src=\"/img/design-patterns/reactor.svg\" alt=\"反应式设计模式\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是设计模式\"><a href=\"#什么是设计模式\" class=\"headerlink\" title=\"什么是设计模式\"></a>什么是设计模式</h2><p>wiki中介绍，模式是存在于人们感知到的世界、人造设计或抽象思想中的规律。而设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p>\n<h2 id=\"为什么需要设计模式\"><a href=\"#为什么需要设计模式\" class=\"headerlink\" title=\"为什么需要设计模式\"></a>为什么需要设计模式</h2><ol>\n<li>设计模式是针对软件设计中常见问题的工具箱， 其中的工具就是各种经过实践验证的解决方案。</li>\n<li>设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。</li>\n</ol>\n<h2 id=\"有多少种设计模式，如何对他们进行分类\"><a href=\"#有多少种设计模式，如何对他们进行分类\" class=\"headerlink\" title=\"有多少种设计模式，如何对他们进行分类\"></a>有多少种设计模式，如何对他们进行分类</h2><p>最基础的、 底层的模式通常被称为惯用技巧。 这类模式一般只能在一种编程语言中使用。</p>\n<p>最通用的、 高层的模式是构架模式。 开发者可以在任何编程语言中使用这类模式。 与其他模式不同， 它们可用于整个应用程序的架构设计。</p>\n<p>《GoF》中提出了23种设计模式，并将其归类为创建型模式，结构型模式，行为模式三类。但人们在后续的工作和学习中又总结并丰富了更多的模式，如《反应式设计模式》一书中又新增6类，27种架构模式。他们的关系图如下：</p>\n<p><img src=\"/img/design-patterns/gof.svg\" alt=\"GoF23\"><br><img src=\"/img/design-patterns/reactor.svg\" alt=\"反应式设计模式\"></p>\n"},{"title":"如何实现高性能FIFO队列","date":"2025-02-28T12:00:00.000Z","_content":"---\n\n> 面试还遇到个题目，“如何实现高性能FIFO队列”\n> 乍一听很唬人，实际上也是个纸老虎，重点在于拆解问题对症下药。\n\n## 1. 问题分析\n\nFIFO队列很简单，可以用LinkedList构建一个无界FIFO队列，或者用ArrayDeque构建一个有界队列，但他们是高性能的队列么？\n\n回想一下队列的使用场景，队列用于连接生产者和消费者，帮助生产者和消费者解耦，可能的匹配模型有单生产者-单消费者，单生产者-多消费者，多生产者-单消费者，多生产者-多消费者。\n\n当存在多个消费者或者生产者竞争时，就会涉及竞态条件问题，此时为了同步控制，必定有额外的系统开销，进而影响队列的吞吐量和延迟。所以高性能的目标是：\n\n1. 低延迟\n2. 高吞吐量\n3. 线程安全\n\n## 2. 设计要点\n\n### 2.1. 无锁设计\n\n存在竞态条件的前提下，为了实现同步控制，加锁是一种可行的方案，比如通过`ReentrantLock`控制入队和出队。但是锁竞争就意味着高延迟和低吞吐量，我们需要无锁的数据结构规避锁竞争成本。\n\n### 2.2. 有界队列\n\n同时为了规避频繁的对象创建和销毁操作带来的额外内存管理开销，我们需要一个有界队列。但有界队列需要额外的设计处理拥塞和饥饿问题，当队列满或者空时，生产者或者消费者需要等待或者被阻塞。\n\n### 2.3. 批量操作优化\n\n类似存储聚合IO写入换取高吞吐量，单次同步过程中转移的数据量越大，平摊到每一份数据的同步开销越小，对批量操作进行特殊优化也可以显著提高吞吐量。\n\n### 2.4. 伪共享问题\n\n由于CPU装载缓存时采用Cache line机制，现代CPU的多个核心同时访问连续空间的数据时有可能出现同一段数据在多个核心的Cache line中，不管其中哪一个数据修改，都会使得其他核心的Cache立即作废，需要重新访问，带来额外的数据加载开销。\n\n## 3. 解决方案\n\n### 3.1. 用RingBuffer搭建底座\n\n由于FIFO的要求，队列的首尾元素一直在动。如果我们使用链表或者顺序表，前者面临不断创建和销毁Node的开销，后者需要不断移动整个队列元素，很难称得上高性能，但环形缓冲区仅需要移动首尾元素的标记即可实现FIFO。\n\n```java\npublic class HighPerformanceFIFOQueue<T> {\n    private final int capacity;\n    private int count;\n\n    private int head = 0;\n    private int tail = 0;\n\n    private final Object[] buffer;\n\n    public HighPerformanceFIFOQueue(int capacity) {\n        this.capacity = capacity;\n        this.count = 0;\n        this.buffer = new Object[capacity];\n    }\n\n    public boolean offer(E item){\n        if (count == capacity) {\n            return false;\n        }\n        final Object[] items = this.buffer;\n        items[tail] = item;\n        if (++tail == items.length) {\n            tail = 0;\n        }\n        count++;\n        return true;\n    }\n\n    public E poll() {\n        final Object[] items = this.buffer;\n        @SuppressWarnings(\"unchecked\")\n        E e = (E) items[head];\n        items[head] = null;\n        if (++head == items.length){\n            head = 0;\n        }\n        count--;\n        return e;\n    }\n}\n```\n\n### 3.2. 线程安全问题\n\n接下来考虑线程安全问题，由于当前的实现没有保护，并发场景下head和tail的更新一定会出现竞态条件导致结果无法预测，最终程序出现预期之外的行为。\n\n#### 3.2.1. 方案一：加锁\n\n考虑到只有`offer()`和`poll()`方法需要修改head和tail，对`offer()`和`poll()`上锁即可满足线程安全要求。比如使用`synchronized`关键字:\n\n```java\npublic boolean offer(E item){\n    synchronized(this) {\n        ...\n    }\n}\npublic E poll() {\n    synchronized (this) {\n        ...\n    }\n}\n```\n\n或者使用`ReentrantLock`，后面还能方便的设计阻塞功能。\n\n```java\npublic class HighPerformanceFIFOQueue<T> {\n    ...\n    private final ReentrantLock lock;\n\n    public HighPerformanceFIFOQueue(int capacity) {\n        ...\n        this.lock = new ReentrantLock(true);\n    }\n\n    public boolean offer(E item){\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            ...\n        } finally {\n            lock.unlock()\n        }\n    }\n\n    public E poll() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            ...\n        } finally {\n            lock.unlock()\n        }\n    }\n}\n```\n\n恭喜，我们已经实现了ArrayBlockingQueue的核心逻辑。赶紧翻一翻源码，看看有什么不同？\n> ABQ = ArrayBlockingQueue，HP = HighPerformanceFIFOQueue\n\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |195.490  |ops/ms   |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |97.748   |ops/ms   |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |97.741   |ops/ms   |\n|ABQ.throughput                   |       1024|            4|            4|  thrpt |195.983  |ops/ms   |\n|ABQ.throughput:throughputConsumer|       1024|            4|            4|  thrpt |98.132   |ops/ms   |\n|ABQ.throughput:throughputProducer|       1024|            4|            4|  thrpt |97.851   |ops/ms   |\n\n可以看到，两者因为同步机制相同，吞吐量也相同。但是这个吞吐量高么？如果我们不考虑FIFO，使用非公平锁会是什么结果？\n\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |83856.887| ops/ms  |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |61293.762| ops/ms  |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |22563.125| ops/ms  |\n|ABQ.throughput                   |       1024|            4|            4|  thrpt |92083.911| ops/ms  |\n|ABQ.throughput:throughputConsumer|       1024|            4|            4|  thrpt |73741.456| ops/ms  |\n|ABQ.throughput:throughputProducer|       1024|            4|            4|  thrpt |18342.456| ops/ms  |\n\n可以看到吞吐量有数量级程度的提升，但是看数值生产者和消费者缺不能匹配，这是因为offer方法中如果发现队列是空的就会立即返回，导致两边吞吐量不匹配。\n\n**为什么公平锁对性能的影响这么严重？**\n\n公平锁保证了线程获取锁的顺序是按照请求锁的先后顺序来进行的，也就是先到先得，在这里主要是对生产者而言需要公平才能保证FIFO。非公平锁不保证线程获取锁的顺序，当锁被释放时，任何一个等待的线程都有机会获取锁，而不是按照请求的先后顺序。\n\n>设想一个电话客服排队场景，接线员就是消费者，客户是生产者。当客户电话请求超过接线员数量时出现生产者竞争，大家需要排队等待接线员接入。正常逻辑需要按照先来后到的原则排队，如果此时使用非公平锁，就可能出现客户A等了10分钟没有接通反而客户B等了2分钟就接通的情况，因为非公平锁不保证先来后到，在等待池的所有请求都有可能争抢到锁。\n\n由于公平锁必须保证请求按照先来后到的顺序获得锁，所以为了维护请求顺序，必须有额外的资源用于排队和调度。而队列的读写使用同一把锁，所以两者必须交替进行。因此我们可以看到使用公平锁模式时生产者和消费者的吞吐量几乎一致，而频繁的唤醒、阻塞以及上下文切换也进一步拖慢了整体吞吐量。\n所以要想实现高性能，就不能依赖基于ObjectMonitor的重量锁同步机制。其次，要考虑缩小锁的粒度，尽可能避免offer和poll操作互相争抢锁。\n\n#### 3.2.2. 方案二：CAS自旋\n\n回到开头，我们希望head和tail的更新可以分开，同时由于需要判断head和tail重合时RingBuffer为空还是满了的问题，需要保证可见性。\n先使用原子类改造head和tail，利用CAS自旋解决同步问题。\n\n```java\npublic class HighPerformanceFIFOQueue<E> {\n    private final int capacity;\n\n    // 将 head 和 tail 改造成原子类\n    private final AtomicInteger head = new AtomicInteger(0);\n    private final AtomicInteger tail = new AtomicInteger(0);\n\n    private final Object[] buffer;\n\n    public HighPerformanceFIFOQueue(int capacity) {\n        this.capacity = capacity;\n        this.buffer = new Object[capacity];\n    }\n\n    public boolean offer(E item) {\n        int currentTail = tail.get();\n        int nextTail = (currentTail + 1) % buffer.length;\n        if (nextTail == head.get()) {\n            // 队列已满\n            return false;\n        }\n        buffer[currentTail] = item;\n        tail.set(nextTail);\n        return true;\n    }\n\n    public E poll() {\n        if (head.get() == tail.get()) {\n            // 队列为空\n            return null;\n        }\n        int currentHead = head.get();\n        @SuppressWarnings(\"unchecked\")\n        E e = (E) buffer[currentHead];\n        buffer[currentHead] = null;\n        head.set((currentHead + 1) % buffer.length);\n        return e;\n    }\n}\n```\n\n基准测试结果如下：\n\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |19352.535|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |11265.928|ops/ms   |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |8086.607 |ops/ms   |\n|HP.throughput                    |       1024|           16|           16|  thrpt |14997.528|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|           16|           16|  thrpt | 7732.578|ops/ms   |\n|HP.throughput:throughputProducer |       1024|           16|           16|  thrpt | 7264.950|ops/ms   |\n\n可以看到，随着并发数的增加，整体吞吐量在下降，但仍然远远领先公平锁模式。可见频繁唤醒、阻塞以及上下文切换带来的影响之大。\n\n### 3.3. 更进一步\n\n如果我们只是需要验证设计思路，那到这里基本上已经可以收工了。但是我们肯定不能做这种浅尝辄止的事情，还记得前面提到的伪共享和批量优化么？\n\n#### 3.3.1. 消除伪共享\n\n简单复习一下Cache Line的机制，CPU为了提高缓存命中率和使用效率，每次都会按行获取数据。考虑下面的情况：\n\n> 由于`head`和`tail`二者在字节码文件中相近，会被放置在内存中靠近的位置，核心在装载缓存时会直接从主存中拉取一个Cache Line的数据，有可能同时把`head`和`tail`同时拉走。\n> 核心0负责生产者，需要更新`tail`，而核心1负责消费者，需要更新`head`。当核心0更新时会作废核心1中一整个Cache Line的数据，导致核心1需要重新从主存读取数据。\n\n上面这种情况，两个核心访问两个不同的变量，不产生竞态条件，但是依然表现出资源的互斥性看起来就像是共享资源一样，就是伪共享。\n\n知道原理后解决起来也很简单，用无效数据填充空间，保证要访问的数据不会出现在同一个Cache Line中即可。现代x86架构CPU一个Cache Line通常是64B，arm架构CPU普遍是128B。\n填充方法有很多种：\n\n**1. 使用`@Contended`注解**\n通过`sun.misc.Contended`可以由java自动完成填充工作，但是由于这是内部注解，从规范上来说它是不稳定的，并不承诺永远不变。所以虽然这种方法最简单，但我们不会采用。\n\n**2. 手动填充**\n手动填充通过插入无效数据填满Cache Line从而实现Cache Line对齐。\n例如在本例中，我们期望`head`和`tail`在不同的缓存行，使用`long`填充，服务器是x86架构CPU预计填充到64B以上。\n\n- 每个long类型占8字节，7个long字段共56字节\n- 结合AtomicInteger（4字节）和对象头（8-16字节），确保head和tail分布在不同的缓存行\n\n字段排列策略：\n\n```java\n// 内存布局示意图（64字节缓存行）：\n[ head (4B) | 对象头 (12B) | p1-p7 (56B) ] → 4+12+56=72B（跨缓存行）\n[ tail (4B) | p8-p14 (56B) | ... ] → 新的缓存行起始\n```\n\n**3.注意事项**\n​JVM内存布局不确定性：\n\n- 使用-XX:FieldsAllocationStyle=1强制字段顺序（HotSpot参数）\n- 通过Unsafe.objectFieldOffset验证字段偏移量\n\n​对象大小验证工具：\n\n```bash\n# 使用JOL工具分析对象布局\njava -jar jol-cli.jar internals HighPerformanceQueue\n```\n\n**最终代码：**\n\n```java\nprivate final AtomicInteger head = new AtomicInteger(0);\nprivate volatile long p1, p2, p3, p4, p5, p6, p7;\nprivate final AtomicInteger tail = new AtomicInteger(0);\nprivate volatile long p8, p9, p10, p11, p12, p13, p14, p15;\n```\n\n**基准测试结果**\n可以看到对齐Cache Line之后，高并发情况下吞吐量有了明显改善。对齐Cache Line明显减少了伪共享导致的同步开销。\n\n>未对齐Cache line\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |19352.535|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |11265.928|ops/ms   |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |8086.607 |ops/ms   |\n|HP.throughput                    |       1024|           16|           16|  thrpt |14997.528|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|           16|           16|  thrpt | 7732.578|ops/ms   |\n|HP.throughput:throughputProducer |       1024|           16|           16|  thrpt | 7264.950|ops/ms   |\n>\n>对齐Cache Line\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |18715.221|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |10845.742|ops/ms   |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |7869.480 |ops/ms   |\n|HP.throughput                    |       1024|           16|           16|  thrpt |22896.964|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|           16|           16|  thrpt |12737.297|ops/ms   |\n|HP.throughput:throughputProducer |       1024|           16|           16|  thrpt |10159.668|ops/ms   |\n\n\n\n#### 3.3.2. 批量读写优化\n\n另一种提高吞吐量的办法是提升单次操作的数据量，即批处理思路。\n比如一次\n\n#### 3.3.3. 补齐Queue的其他接口\n\n**下标优化**\n一般单机高性能FIFO队列不会很大，因为过大的FIFO队列内存利用率低，也不利于提升性能。所以我们可以要求队列容量必须满足2的幂，这样在环形队列求下标时可以简单的通过位运算\n\n#### 3.3.4. 支持阻塞\n\n","source":"_posts/2025/how-to-build-high-performance-fifo-queue.md","raw":"---\ntitle: 如何实现高性能FIFO队列\ndate: 2025-02-28 20:00:00\ntag:\n  - 高性能\n  - 高并发\n  - DIY自己做\n  - 面试\n------\n\n> 面试还遇到个题目，“如何实现高性能FIFO队列”\n> 乍一听很唬人，实际上也是个纸老虎，重点在于拆解问题对症下药。\n\n## 1. 问题分析\n\nFIFO队列很简单，可以用LinkedList构建一个无界FIFO队列，或者用ArrayDeque构建一个有界队列，但他们是高性能的队列么？\n\n回想一下队列的使用场景，队列用于连接生产者和消费者，帮助生产者和消费者解耦，可能的匹配模型有单生产者-单消费者，单生产者-多消费者，多生产者-单消费者，多生产者-多消费者。\n\n当存在多个消费者或者生产者竞争时，就会涉及竞态条件问题，此时为了同步控制，必定有额外的系统开销，进而影响队列的吞吐量和延迟。所以高性能的目标是：\n\n1. 低延迟\n2. 高吞吐量\n3. 线程安全\n\n## 2. 设计要点\n\n### 2.1. 无锁设计\n\n存在竞态条件的前提下，为了实现同步控制，加锁是一种可行的方案，比如通过`ReentrantLock`控制入队和出队。但是锁竞争就意味着高延迟和低吞吐量，我们需要无锁的数据结构规避锁竞争成本。\n\n### 2.2. 有界队列\n\n同时为了规避频繁的对象创建和销毁操作带来的额外内存管理开销，我们需要一个有界队列。但有界队列需要额外的设计处理拥塞和饥饿问题，当队列满或者空时，生产者或者消费者需要等待或者被阻塞。\n\n### 2.3. 批量操作优化\n\n类似存储聚合IO写入换取高吞吐量，单次同步过程中转移的数据量越大，平摊到每一份数据的同步开销越小，对批量操作进行特殊优化也可以显著提高吞吐量。\n\n### 2.4. 伪共享问题\n\n由于CPU装载缓存时采用Cache line机制，现代CPU的多个核心同时访问连续空间的数据时有可能出现同一段数据在多个核心的Cache line中，不管其中哪一个数据修改，都会使得其他核心的Cache立即作废，需要重新访问，带来额外的数据加载开销。\n\n## 3. 解决方案\n\n### 3.1. 用RingBuffer搭建底座\n\n由于FIFO的要求，队列的首尾元素一直在动。如果我们使用链表或者顺序表，前者面临不断创建和销毁Node的开销，后者需要不断移动整个队列元素，很难称得上高性能，但环形缓冲区仅需要移动首尾元素的标记即可实现FIFO。\n\n```java\npublic class HighPerformanceFIFOQueue<T> {\n    private final int capacity;\n    private int count;\n\n    private int head = 0;\n    private int tail = 0;\n\n    private final Object[] buffer;\n\n    public HighPerformanceFIFOQueue(int capacity) {\n        this.capacity = capacity;\n        this.count = 0;\n        this.buffer = new Object[capacity];\n    }\n\n    public boolean offer(E item){\n        if (count == capacity) {\n            return false;\n        }\n        final Object[] items = this.buffer;\n        items[tail] = item;\n        if (++tail == items.length) {\n            tail = 0;\n        }\n        count++;\n        return true;\n    }\n\n    public E poll() {\n        final Object[] items = this.buffer;\n        @SuppressWarnings(\"unchecked\")\n        E e = (E) items[head];\n        items[head] = null;\n        if (++head == items.length){\n            head = 0;\n        }\n        count--;\n        return e;\n    }\n}\n```\n\n### 3.2. 线程安全问题\n\n接下来考虑线程安全问题，由于当前的实现没有保护，并发场景下head和tail的更新一定会出现竞态条件导致结果无法预测，最终程序出现预期之外的行为。\n\n#### 3.2.1. 方案一：加锁\n\n考虑到只有`offer()`和`poll()`方法需要修改head和tail，对`offer()`和`poll()`上锁即可满足线程安全要求。比如使用`synchronized`关键字:\n\n```java\npublic boolean offer(E item){\n    synchronized(this) {\n        ...\n    }\n}\npublic E poll() {\n    synchronized (this) {\n        ...\n    }\n}\n```\n\n或者使用`ReentrantLock`，后面还能方便的设计阻塞功能。\n\n```java\npublic class HighPerformanceFIFOQueue<T> {\n    ...\n    private final ReentrantLock lock;\n\n    public HighPerformanceFIFOQueue(int capacity) {\n        ...\n        this.lock = new ReentrantLock(true);\n    }\n\n    public boolean offer(E item){\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            ...\n        } finally {\n            lock.unlock()\n        }\n    }\n\n    public E poll() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            ...\n        } finally {\n            lock.unlock()\n        }\n    }\n}\n```\n\n恭喜，我们已经实现了ArrayBlockingQueue的核心逻辑。赶紧翻一翻源码，看看有什么不同？\n> ABQ = ArrayBlockingQueue，HP = HighPerformanceFIFOQueue\n\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |195.490  |ops/ms   |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |97.748   |ops/ms   |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |97.741   |ops/ms   |\n|ABQ.throughput                   |       1024|            4|            4|  thrpt |195.983  |ops/ms   |\n|ABQ.throughput:throughputConsumer|       1024|            4|            4|  thrpt |98.132   |ops/ms   |\n|ABQ.throughput:throughputProducer|       1024|            4|            4|  thrpt |97.851   |ops/ms   |\n\n可以看到，两者因为同步机制相同，吞吐量也相同。但是这个吞吐量高么？如果我们不考虑FIFO，使用非公平锁会是什么结果？\n\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |83856.887| ops/ms  |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |61293.762| ops/ms  |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |22563.125| ops/ms  |\n|ABQ.throughput                   |       1024|            4|            4|  thrpt |92083.911| ops/ms  |\n|ABQ.throughput:throughputConsumer|       1024|            4|            4|  thrpt |73741.456| ops/ms  |\n|ABQ.throughput:throughputProducer|       1024|            4|            4|  thrpt |18342.456| ops/ms  |\n\n可以看到吞吐量有数量级程度的提升，但是看数值生产者和消费者缺不能匹配，这是因为offer方法中如果发现队列是空的就会立即返回，导致两边吞吐量不匹配。\n\n**为什么公平锁对性能的影响这么严重？**\n\n公平锁保证了线程获取锁的顺序是按照请求锁的先后顺序来进行的，也就是先到先得，在这里主要是对生产者而言需要公平才能保证FIFO。非公平锁不保证线程获取锁的顺序，当锁被释放时，任何一个等待的线程都有机会获取锁，而不是按照请求的先后顺序。\n\n>设想一个电话客服排队场景，接线员就是消费者，客户是生产者。当客户电话请求超过接线员数量时出现生产者竞争，大家需要排队等待接线员接入。正常逻辑需要按照先来后到的原则排队，如果此时使用非公平锁，就可能出现客户A等了10分钟没有接通反而客户B等了2分钟就接通的情况，因为非公平锁不保证先来后到，在等待池的所有请求都有可能争抢到锁。\n\n由于公平锁必须保证请求按照先来后到的顺序获得锁，所以为了维护请求顺序，必须有额外的资源用于排队和调度。而队列的读写使用同一把锁，所以两者必须交替进行。因此我们可以看到使用公平锁模式时生产者和消费者的吞吐量几乎一致，而频繁的唤醒、阻塞以及上下文切换也进一步拖慢了整体吞吐量。\n所以要想实现高性能，就不能依赖基于ObjectMonitor的重量锁同步机制。其次，要考虑缩小锁的粒度，尽可能避免offer和poll操作互相争抢锁。\n\n#### 3.2.2. 方案二：CAS自旋\n\n回到开头，我们希望head和tail的更新可以分开，同时由于需要判断head和tail重合时RingBuffer为空还是满了的问题，需要保证可见性。\n先使用原子类改造head和tail，利用CAS自旋解决同步问题。\n\n```java\npublic class HighPerformanceFIFOQueue<E> {\n    private final int capacity;\n\n    // 将 head 和 tail 改造成原子类\n    private final AtomicInteger head = new AtomicInteger(0);\n    private final AtomicInteger tail = new AtomicInteger(0);\n\n    private final Object[] buffer;\n\n    public HighPerformanceFIFOQueue(int capacity) {\n        this.capacity = capacity;\n        this.buffer = new Object[capacity];\n    }\n\n    public boolean offer(E item) {\n        int currentTail = tail.get();\n        int nextTail = (currentTail + 1) % buffer.length;\n        if (nextTail == head.get()) {\n            // 队列已满\n            return false;\n        }\n        buffer[currentTail] = item;\n        tail.set(nextTail);\n        return true;\n    }\n\n    public E poll() {\n        if (head.get() == tail.get()) {\n            // 队列为空\n            return null;\n        }\n        int currentHead = head.get();\n        @SuppressWarnings(\"unchecked\")\n        E e = (E) buffer[currentHead];\n        buffer[currentHead] = null;\n        head.set((currentHead + 1) % buffer.length);\n        return e;\n    }\n}\n```\n\n基准测试结果如下：\n\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |19352.535|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |11265.928|ops/ms   |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |8086.607 |ops/ms   |\n|HP.throughput                    |       1024|           16|           16|  thrpt |14997.528|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|           16|           16|  thrpt | 7732.578|ops/ms   |\n|HP.throughput:throughputProducer |       1024|           16|           16|  thrpt | 7264.950|ops/ms   |\n\n可以看到，随着并发数的增加，整体吞吐量在下降，但仍然远远领先公平锁模式。可见频繁唤醒、阻塞以及上下文切换带来的影响之大。\n\n### 3.3. 更进一步\n\n如果我们只是需要验证设计思路，那到这里基本上已经可以收工了。但是我们肯定不能做这种浅尝辄止的事情，还记得前面提到的伪共享和批量优化么？\n\n#### 3.3.1. 消除伪共享\n\n简单复习一下Cache Line的机制，CPU为了提高缓存命中率和使用效率，每次都会按行获取数据。考虑下面的情况：\n\n> 由于`head`和`tail`二者在字节码文件中相近，会被放置在内存中靠近的位置，核心在装载缓存时会直接从主存中拉取一个Cache Line的数据，有可能同时把`head`和`tail`同时拉走。\n> 核心0负责生产者，需要更新`tail`，而核心1负责消费者，需要更新`head`。当核心0更新时会作废核心1中一整个Cache Line的数据，导致核心1需要重新从主存读取数据。\n\n上面这种情况，两个核心访问两个不同的变量，不产生竞态条件，但是依然表现出资源的互斥性看起来就像是共享资源一样，就是伪共享。\n\n知道原理后解决起来也很简单，用无效数据填充空间，保证要访问的数据不会出现在同一个Cache Line中即可。现代x86架构CPU一个Cache Line通常是64B，arm架构CPU普遍是128B。\n填充方法有很多种：\n\n**1. 使用`@Contended`注解**\n通过`sun.misc.Contended`可以由java自动完成填充工作，但是由于这是内部注解，从规范上来说它是不稳定的，并不承诺永远不变。所以虽然这种方法最简单，但我们不会采用。\n\n**2. 手动填充**\n手动填充通过插入无效数据填满Cache Line从而实现Cache Line对齐。\n例如在本例中，我们期望`head`和`tail`在不同的缓存行，使用`long`填充，服务器是x86架构CPU预计填充到64B以上。\n\n- 每个long类型占8字节，7个long字段共56字节\n- 结合AtomicInteger（4字节）和对象头（8-16字节），确保head和tail分布在不同的缓存行\n\n字段排列策略：\n\n```java\n// 内存布局示意图（64字节缓存行）：\n[ head (4B) | 对象头 (12B) | p1-p7 (56B) ] → 4+12+56=72B（跨缓存行）\n[ tail (4B) | p8-p14 (56B) | ... ] → 新的缓存行起始\n```\n\n**3.注意事项**\n​JVM内存布局不确定性：\n\n- 使用-XX:FieldsAllocationStyle=1强制字段顺序（HotSpot参数）\n- 通过Unsafe.objectFieldOffset验证字段偏移量\n\n​对象大小验证工具：\n\n```bash\n# 使用JOL工具分析对象布局\njava -jar jol-cli.jar internals HighPerformanceQueue\n```\n\n**最终代码：**\n\n```java\nprivate final AtomicInteger head = new AtomicInteger(0);\nprivate volatile long p1, p2, p3, p4, p5, p6, p7;\nprivate final AtomicInteger tail = new AtomicInteger(0);\nprivate volatile long p8, p9, p10, p11, p12, p13, p14, p15;\n```\n\n**基准测试结果**\n可以看到对齐Cache Line之后，高并发情况下吞吐量有了明显改善。对齐Cache Line明显减少了伪共享导致的同步开销。\n\n>未对齐Cache line\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |19352.535|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |11265.928|ops/ms   |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |8086.607 |ops/ms   |\n|HP.throughput                    |       1024|           16|           16|  thrpt |14997.528|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|           16|           16|  thrpt | 7732.578|ops/ms   |\n|HP.throughput:throughputProducer |       1024|           16|           16|  thrpt | 7264.950|ops/ms   |\n>\n>对齐Cache Line\n|Benchmark                        |(capacity) | (consumers) | (producers) |  Mode  |  Score  |  Units  |\n|---------------------------------|-----------|-------------|-------------|--------|---------|---------|\n|HP.throughput                    |       1024|            4|            4|  thrpt |18715.221|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|            4|            4|  thrpt |10845.742|ops/ms   |\n|HP.throughput:throughputProducer |       1024|            4|            4|  thrpt |7869.480 |ops/ms   |\n|HP.throughput                    |       1024|           16|           16|  thrpt |22896.964|ops/ms   |\n|HP.throughput:throughputConsumer |       1024|           16|           16|  thrpt |12737.297|ops/ms   |\n|HP.throughput:throughputProducer |       1024|           16|           16|  thrpt |10159.668|ops/ms   |\n\n\n\n#### 3.3.2. 批量读写优化\n\n另一种提高吞吐量的办法是提升单次操作的数据量，即批处理思路。\n比如一次\n\n#### 3.3.3. 补齐Queue的其他接口\n\n**下标优化**\n一般单机高性能FIFO队列不会很大，因为过大的FIFO队列内存利用率低，也不利于提升性能。所以我们可以要求队列容量必须满足2的幂，这样在环形队列求下标时可以简单的通过位运算\n\n#### 3.3.4. 支持阻塞\n\n","slug":"2025/how-to-build-high-performance-fifo-queue","published":1,"updated":"2025-03-01T10:03:31.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7q3a39h0000totg9d0t9qli","content":"<hr>\n<blockquote>\n<p>面试还遇到个题目，“如何实现高性能FIFO队列”<br>乍一听很唬人，实际上也是个纸老虎，重点在于拆解问题对症下药。</p>\n</blockquote>\n<h2 id=\"1-问题分析\"><a href=\"#1-问题分析\" class=\"headerlink\" title=\"1. 问题分析\"></a>1. 问题分析</h2><p>FIFO队列很简单，可以用LinkedList构建一个无界FIFO队列，或者用ArrayDeque构建一个有界队列，但他们是高性能的队列么？</p>\n<p>回想一下队列的使用场景，队列用于连接生产者和消费者，帮助生产者和消费者解耦，可能的匹配模型有单生产者-单消费者，单生产者-多消费者，多生产者-单消费者，多生产者-多消费者。</p>\n<p>当存在多个消费者或者生产者竞争时，就会涉及竞态条件问题，此时为了同步控制，必定有额外的系统开销，进而影响队列的吞吐量和延迟。所以高性能的目标是：</p>\n<ol>\n<li>低延迟</li>\n<li>高吞吐量</li>\n<li>线程安全</li>\n</ol>\n<h2 id=\"2-设计要点\"><a href=\"#2-设计要点\" class=\"headerlink\" title=\"2. 设计要点\"></a>2. 设计要点</h2><h3 id=\"2-1-无锁设计\"><a href=\"#2-1-无锁设计\" class=\"headerlink\" title=\"2.1. 无锁设计\"></a>2.1. 无锁设计</h3><p>存在竞态条件的前提下，为了实现同步控制，加锁是一种可行的方案，比如通过<code>ReentrantLock</code>控制入队和出队。但是锁竞争就意味着高延迟和低吞吐量，我们需要无锁的数据结构规避锁竞争成本。</p>\n<h3 id=\"2-2-有界队列\"><a href=\"#2-2-有界队列\" class=\"headerlink\" title=\"2.2. 有界队列\"></a>2.2. 有界队列</h3><p>同时为了规避频繁的对象创建和销毁操作带来的额外内存管理开销，我们需要一个有界队列。但有界队列需要额外的设计处理拥塞和饥饿问题，当队列满或者空时，生产者或者消费者需要等待或者被阻塞。</p>\n<h3 id=\"2-3-批量操作优化\"><a href=\"#2-3-批量操作优化\" class=\"headerlink\" title=\"2.3. 批量操作优化\"></a>2.3. 批量操作优化</h3><p>类似存储聚合IO写入换取高吞吐量，单次同步过程中转移的数据量越大，平摊到每一份数据的同步开销越小，对批量操作进行特殊优化也可以显著提高吞吐量。</p>\n<h3 id=\"2-4-伪共享问题\"><a href=\"#2-4-伪共享问题\" class=\"headerlink\" title=\"2.4. 伪共享问题\"></a>2.4. 伪共享问题</h3><p>由于CPU装载缓存时采用Cache line机制，现代CPU的多个核心同时访问连续空间的数据时有可能出现同一段数据在多个核心的Cache line中，不管其中哪一个数据修改，都会使得其他核心的Cache立即作废，需要重新访问，带来额外的数据加载开销。</p>\n<h2 id=\"3-解决方案\"><a href=\"#3-解决方案\" class=\"headerlink\" title=\"3. 解决方案\"></a>3. 解决方案</h2><h3 id=\"3-1-用RingBuffer搭建底座\"><a href=\"#3-1-用RingBuffer搭建底座\" class=\"headerlink\" title=\"3.1. 用RingBuffer搭建底座\"></a>3.1. 用RingBuffer搭建底座</h3><p>由于FIFO的要求，队列的首尾元素一直在动。如果我们使用链表或者顺序表，前者面临不断创建和销毁Node的开销，后者需要不断移动整个队列元素，很难称得上高性能，但环形缓冲区仅需要移动首尾元素的标记即可实现FIFO。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HighPerformanceFIFOQueue</span>&lt;T&gt; &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> capacity;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> count;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">tail</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Object[] buffer;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">HighPerformanceFIFOQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> capacity)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.capacity = capacity;<br>        <span class=\"hljs-built_in\">this</span>.count = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-built_in\">this</span>.buffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[capacity];<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">offer</span><span class=\"hljs-params\">(E item)</span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (count == capacity) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">final</span> Object[] items = <span class=\"hljs-built_in\">this</span>.buffer;<br>        items[tail] = item;<br>        <span class=\"hljs-keyword\">if</span> (++tail == items.length) &#123;<br>            tail = <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        count++;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">poll</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> Object[] items = <span class=\"hljs-built_in\">this</span>.buffer;<br>        <span class=\"hljs-meta\">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class=\"hljs-type\">E</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> (E) items[head];<br>        items[head] = <span class=\"hljs-literal\">null</span>;<br>        <span class=\"hljs-keyword\">if</span> (++head == items.length)&#123;<br>            head = <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        count--;<br>        <span class=\"hljs-keyword\">return</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-线程安全问题\"><a href=\"#3-2-线程安全问题\" class=\"headerlink\" title=\"3.2. 线程安全问题\"></a>3.2. 线程安全问题</h3><p>接下来考虑线程安全问题，由于当前的实现没有保护，并发场景下head和tail的更新一定会出现竞态条件导致结果无法预测，最终程序出现预期之外的行为。</p>\n<h4 id=\"3-2-1-方案一：加锁\"><a href=\"#3-2-1-方案一：加锁\" class=\"headerlink\" title=\"3.2.1. 方案一：加锁\"></a>3.2.1. 方案一：加锁</h4><p>考虑到只有<code>offer()</code>和<code>poll()</code>方法需要修改head和tail，对<code>offer()</code>和<code>poll()</code>上锁即可满足线程安全要求。比如使用<code>synchronized</code>关键字:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">offer</span><span class=\"hljs-params\">(E item)</span>&#123;<br>    <span class=\"hljs-keyword\">synchronized</span>(<span class=\"hljs-built_in\">this</span>) &#123;<br>        ...<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">poll</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-built_in\">this</span>) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或者使用<code>ReentrantLock</code>，后面还能方便的设计阻塞功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HighPerformanceFIFOQueue</span>&lt;T&gt; &#123;<br>    ...<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ReentrantLock lock;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">HighPerformanceFIFOQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> capacity)</span> &#123;<br>        ...<br>        <span class=\"hljs-built_in\">this</span>.lock = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReentrantLock</span>(<span class=\"hljs-literal\">true</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">offer</span><span class=\"hljs-params\">(E item)</span>&#123;<br>        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">ReentrantLock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.lock;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            ...<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock()<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">poll</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">ReentrantLock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.lock;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            ...<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>恭喜，我们已经实现了ArrayBlockingQueue的核心逻辑。赶紧翻一翻源码，看看有什么不同？</p>\n<blockquote>\n<p>ABQ &#x3D; ArrayBlockingQueue，HP &#x3D; HighPerformanceFIFOQueue</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>195.490</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>97.748</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>97.741</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>195.983</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>98.132</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>97.851</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n<p>可以看到，两者因为同步机制相同，吞吐量也相同。但是这个吞吐量高么？如果我们不考虑FIFO，使用非公平锁会是什么结果？</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>83856.887</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>61293.762</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>22563.125</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>92083.911</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>73741.456</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>18342.456</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n<p>可以看到吞吐量有数量级程度的提升，但是看数值生产者和消费者缺不能匹配，这是因为offer方法中如果发现队列是空的就会立即返回，导致两边吞吐量不匹配。</p>\n<p><strong>为什么公平锁对性能的影响这么严重？</strong></p>\n<p>公平锁保证了线程获取锁的顺序是按照请求锁的先后顺序来进行的，也就是先到先得，在这里主要是对生产者而言需要公平才能保证FIFO。非公平锁不保证线程获取锁的顺序，当锁被释放时，任何一个等待的线程都有机会获取锁，而不是按照请求的先后顺序。</p>\n<blockquote>\n<p>设想一个电话客服排队场景，接线员就是消费者，客户是生产者。当客户电话请求超过接线员数量时出现生产者竞争，大家需要排队等待接线员接入。正常逻辑需要按照先来后到的原则排队，如果此时使用非公平锁，就可能出现客户A等了10分钟没有接通反而客户B等了2分钟就接通的情况，因为非公平锁不保证先来后到，在等待池的所有请求都有可能争抢到锁。</p>\n</blockquote>\n<p>由于公平锁必须保证请求按照先来后到的顺序获得锁，所以为了维护请求顺序，必须有额外的资源用于排队和调度。而队列的读写使用同一把锁，所以两者必须交替进行。因此我们可以看到使用公平锁模式时生产者和消费者的吞吐量几乎一致，而频繁的唤醒、阻塞以及上下文切换也进一步拖慢了整体吞吐量。<br>所以要想实现高性能，就不能依赖基于ObjectMonitor的重量锁同步机制。其次，要考虑缩小锁的粒度，尽可能避免offer和poll操作互相争抢锁。</p>\n<h4 id=\"3-2-2-方案二：CAS自旋\"><a href=\"#3-2-2-方案二：CAS自旋\" class=\"headerlink\" title=\"3.2.2. 方案二：CAS自旋\"></a>3.2.2. 方案二：CAS自旋</h4><p>回到开头，我们希望head和tail的更新可以分开，同时由于需要判断head和tail重合时RingBuffer为空还是满了的问题，需要保证可见性。<br>先使用原子类改造head和tail，利用CAS自旋解决同步问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HighPerformanceFIFOQueue</span>&lt;E&gt; &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> capacity;<br><br>    <span class=\"hljs-comment\">// 将 head 和 tail 改造成原子类</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">AtomicInteger</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicInteger</span>(<span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">AtomicInteger</span> <span class=\"hljs-variable\">tail</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicInteger</span>(<span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Object[] buffer;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">HighPerformanceFIFOQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> capacity)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.capacity = capacity;<br>        <span class=\"hljs-built_in\">this</span>.buffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[capacity];<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">offer</span><span class=\"hljs-params\">(E item)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">currentTail</span> <span class=\"hljs-operator\">=</span> tail.get();<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nextTail</span> <span class=\"hljs-operator\">=</span> (currentTail + <span class=\"hljs-number\">1</span>) % buffer.length;<br>        <span class=\"hljs-keyword\">if</span> (nextTail == head.get()) &#123;<br>            <span class=\"hljs-comment\">// 队列已满</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        buffer[currentTail] = item;<br>        tail.set(nextTail);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">poll</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (head.get() == tail.get()) &#123;<br>            <span class=\"hljs-comment\">// 队列为空</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        &#125;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">currentHead</span> <span class=\"hljs-operator\">=</span> head.get();<br>        <span class=\"hljs-meta\">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class=\"hljs-type\">E</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> (E) buffer[currentHead];<br>        buffer[currentHead] = <span class=\"hljs-literal\">null</span>;<br>        head.set((currentHead + <span class=\"hljs-number\">1</span>) % buffer.length);<br>        <span class=\"hljs-keyword\">return</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>基准测试结果如下：</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>19352.535</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>11265.928</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>8086.607</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>14997.528</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>7732.578</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>7264.950</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n<p>可以看到，随着并发数的增加，整体吞吐量在下降，但仍然远远领先公平锁模式。可见频繁唤醒、阻塞以及上下文切换带来的影响之大。</p>\n<h3 id=\"3-3-更进一步\"><a href=\"#3-3-更进一步\" class=\"headerlink\" title=\"3.3. 更进一步\"></a>3.3. 更进一步</h3><p>如果我们只是需要验证设计思路，那到这里基本上已经可以收工了。但是我们肯定不能做这种浅尝辄止的事情，还记得前面提到的伪共享和批量优化么？</p>\n<h4 id=\"3-3-1-消除伪共享\"><a href=\"#3-3-1-消除伪共享\" class=\"headerlink\" title=\"3.3.1. 消除伪共享\"></a>3.3.1. 消除伪共享</h4><p>简单复习一下Cache Line的机制，CPU为了提高缓存命中率和使用效率，每次都会按行获取数据。考虑下面的情况：</p>\n<blockquote>\n<p>由于<code>head</code>和<code>tail</code>二者在字节码文件中相近，会被放置在内存中靠近的位置，核心在装载缓存时会直接从主存中拉取一个Cache Line的数据，有可能同时把<code>head</code>和<code>tail</code>同时拉走。<br>核心0负责生产者，需要更新<code>tail</code>，而核心1负责消费者，需要更新<code>head</code>。当核心0更新时会作废核心1中一整个Cache Line的数据，导致核心1需要重新从主存读取数据。</p>\n</blockquote>\n<p>上面这种情况，两个核心访问两个不同的变量，不产生竞态条件，但是依然表现出资源的互斥性看起来就像是共享资源一样，就是伪共享。</p>\n<p>知道原理后解决起来也很简单，用无效数据填充空间，保证要访问的数据不会出现在同一个Cache Line中即可。现代x86架构CPU一个Cache Line通常是64B，arm架构CPU普遍是128B。<br>填充方法有很多种：</p>\n<p><strong>1. 使用<code>@Contended</code>注解</strong><br>通过<code>sun.misc.Contended</code>可以由java自动完成填充工作，但是由于这是内部注解，从规范上来说它是不稳定的，并不承诺永远不变。所以虽然这种方法最简单，但我们不会采用。</p>\n<p><strong>2. 手动填充</strong><br>手动填充通过插入无效数据填满Cache Line从而实现Cache Line对齐。<br>例如在本例中，我们期望<code>head</code>和<code>tail</code>在不同的缓存行，使用<code>long</code>填充，服务器是x86架构CPU预计填充到64B以上。</p>\n<ul>\n<li>每个long类型占8字节，7个long字段共56字节</li>\n<li>结合AtomicInteger（4字节）和对象头（8-16字节），确保head和tail分布在不同的缓存行</li>\n</ul>\n<p>字段排列策略：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 内存布局示意图（64字节缓存行）：</span><br>[ head (4B) | 对象头 (12B) | p1-p7 (56B) ] → <span class=\"hljs-number\">4</span>+<span class=\"hljs-number\">12</span>+<span class=\"hljs-number\">56</span>=72B（跨缓存行）<br>[ tail (4B) | p8-p14 (56B) | ... ] → 新的缓存行起始<br></code></pre></td></tr></table></figure>\n\n<p><strong>3.注意事项</strong><br>​JVM内存布局不确定性：</p>\n<ul>\n<li>使用-XX:FieldsAllocationStyle&#x3D;1强制字段顺序（HotSpot参数）</li>\n<li>通过Unsafe.objectFieldOffset验证字段偏移量</li>\n</ul>\n<p>​对象大小验证工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 使用JOL工具分析对象布局</span><br>java -jar jol-cli.jar internals HighPerformanceQueue<br></code></pre></td></tr></table></figure>\n\n<p><strong>最终代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">AtomicInteger</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicInteger</span>(<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">long</span> p1, p2, p3, p4, p5, p6, p7;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">AtomicInteger</span> <span class=\"hljs-variable\">tail</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicInteger</span>(<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">long</span> p8, p9, p10, p11, p12, p13, p14, p15;<br></code></pre></td></tr></table></figure>\n\n<p><strong>基准测试结果</strong><br>可以看到对齐Cache Line之后，高并发情况下吞吐量有了明显改善。对齐Cache Line明显减少了伪共享导致的同步开销。</p>\n<blockquote>\n<p>未对齐Cache line</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>19352.535</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>11265.928</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>8086.607</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>14997.528</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>7732.578</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>7264.950</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n<p>对齐Cache Line</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>18715.221</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>10845.742</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>7869.480</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>22896.964</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>12737.297</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>10159.668</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n</blockquote>\n<h4 id=\"3-3-2-批量读写优化\"><a href=\"#3-3-2-批量读写优化\" class=\"headerlink\" title=\"3.3.2. 批量读写优化\"></a>3.3.2. 批量读写优化</h4><p>另一种提高吞吐量的办法是提升单次操作的数据量，即批处理思路。<br>比如一次</p>\n<h4 id=\"3-3-3-补齐Queue的其他接口\"><a href=\"#3-3-3-补齐Queue的其他接口\" class=\"headerlink\" title=\"3.3.3. 补齐Queue的其他接口\"></a>3.3.3. 补齐Queue的其他接口</h4><p><strong>下标优化</strong><br>一般单机高性能FIFO队列不会很大，因为过大的FIFO队列内存利用率低，也不利于提升性能。所以我们可以要求队列容量必须满足2的幂，这样在环形队列求下标时可以简单的通过位运算</p>\n<h4 id=\"3-3-4-支持阻塞\"><a href=\"#3-3-4-支持阻塞\" class=\"headerlink\" title=\"3.3.4. 支持阻塞\"></a>3.3.4. 支持阻塞</h4>","site":{"data":{}},"excerpt":"","more":"<hr>\n<blockquote>\n<p>面试还遇到个题目，“如何实现高性能FIFO队列”<br>乍一听很唬人，实际上也是个纸老虎，重点在于拆解问题对症下药。</p>\n</blockquote>\n<h2 id=\"1-问题分析\"><a href=\"#1-问题分析\" class=\"headerlink\" title=\"1. 问题分析\"></a>1. 问题分析</h2><p>FIFO队列很简单，可以用LinkedList构建一个无界FIFO队列，或者用ArrayDeque构建一个有界队列，但他们是高性能的队列么？</p>\n<p>回想一下队列的使用场景，队列用于连接生产者和消费者，帮助生产者和消费者解耦，可能的匹配模型有单生产者-单消费者，单生产者-多消费者，多生产者-单消费者，多生产者-多消费者。</p>\n<p>当存在多个消费者或者生产者竞争时，就会涉及竞态条件问题，此时为了同步控制，必定有额外的系统开销，进而影响队列的吞吐量和延迟。所以高性能的目标是：</p>\n<ol>\n<li>低延迟</li>\n<li>高吞吐量</li>\n<li>线程安全</li>\n</ol>\n<h2 id=\"2-设计要点\"><a href=\"#2-设计要点\" class=\"headerlink\" title=\"2. 设计要点\"></a>2. 设计要点</h2><h3 id=\"2-1-无锁设计\"><a href=\"#2-1-无锁设计\" class=\"headerlink\" title=\"2.1. 无锁设计\"></a>2.1. 无锁设计</h3><p>存在竞态条件的前提下，为了实现同步控制，加锁是一种可行的方案，比如通过<code>ReentrantLock</code>控制入队和出队。但是锁竞争就意味着高延迟和低吞吐量，我们需要无锁的数据结构规避锁竞争成本。</p>\n<h3 id=\"2-2-有界队列\"><a href=\"#2-2-有界队列\" class=\"headerlink\" title=\"2.2. 有界队列\"></a>2.2. 有界队列</h3><p>同时为了规避频繁的对象创建和销毁操作带来的额外内存管理开销，我们需要一个有界队列。但有界队列需要额外的设计处理拥塞和饥饿问题，当队列满或者空时，生产者或者消费者需要等待或者被阻塞。</p>\n<h3 id=\"2-3-批量操作优化\"><a href=\"#2-3-批量操作优化\" class=\"headerlink\" title=\"2.3. 批量操作优化\"></a>2.3. 批量操作优化</h3><p>类似存储聚合IO写入换取高吞吐量，单次同步过程中转移的数据量越大，平摊到每一份数据的同步开销越小，对批量操作进行特殊优化也可以显著提高吞吐量。</p>\n<h3 id=\"2-4-伪共享问题\"><a href=\"#2-4-伪共享问题\" class=\"headerlink\" title=\"2.4. 伪共享问题\"></a>2.4. 伪共享问题</h3><p>由于CPU装载缓存时采用Cache line机制，现代CPU的多个核心同时访问连续空间的数据时有可能出现同一段数据在多个核心的Cache line中，不管其中哪一个数据修改，都会使得其他核心的Cache立即作废，需要重新访问，带来额外的数据加载开销。</p>\n<h2 id=\"3-解决方案\"><a href=\"#3-解决方案\" class=\"headerlink\" title=\"3. 解决方案\"></a>3. 解决方案</h2><h3 id=\"3-1-用RingBuffer搭建底座\"><a href=\"#3-1-用RingBuffer搭建底座\" class=\"headerlink\" title=\"3.1. 用RingBuffer搭建底座\"></a>3.1. 用RingBuffer搭建底座</h3><p>由于FIFO的要求，队列的首尾元素一直在动。如果我们使用链表或者顺序表，前者面临不断创建和销毁Node的开销，后者需要不断移动整个队列元素，很难称得上高性能，但环形缓冲区仅需要移动首尾元素的标记即可实现FIFO。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HighPerformanceFIFOQueue</span>&lt;T&gt; &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> capacity;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> count;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">tail</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Object[] buffer;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">HighPerformanceFIFOQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> capacity)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.capacity = capacity;<br>        <span class=\"hljs-built_in\">this</span>.count = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-built_in\">this</span>.buffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[capacity];<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">offer</span><span class=\"hljs-params\">(E item)</span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (count == capacity) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">final</span> Object[] items = <span class=\"hljs-built_in\">this</span>.buffer;<br>        items[tail] = item;<br>        <span class=\"hljs-keyword\">if</span> (++tail == items.length) &#123;<br>            tail = <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        count++;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">poll</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> Object[] items = <span class=\"hljs-built_in\">this</span>.buffer;<br>        <span class=\"hljs-meta\">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class=\"hljs-type\">E</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> (E) items[head];<br>        items[head] = <span class=\"hljs-literal\">null</span>;<br>        <span class=\"hljs-keyword\">if</span> (++head == items.length)&#123;<br>            head = <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        count--;<br>        <span class=\"hljs-keyword\">return</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-线程安全问题\"><a href=\"#3-2-线程安全问题\" class=\"headerlink\" title=\"3.2. 线程安全问题\"></a>3.2. 线程安全问题</h3><p>接下来考虑线程安全问题，由于当前的实现没有保护，并发场景下head和tail的更新一定会出现竞态条件导致结果无法预测，最终程序出现预期之外的行为。</p>\n<h4 id=\"3-2-1-方案一：加锁\"><a href=\"#3-2-1-方案一：加锁\" class=\"headerlink\" title=\"3.2.1. 方案一：加锁\"></a>3.2.1. 方案一：加锁</h4><p>考虑到只有<code>offer()</code>和<code>poll()</code>方法需要修改head和tail，对<code>offer()</code>和<code>poll()</code>上锁即可满足线程安全要求。比如使用<code>synchronized</code>关键字:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">offer</span><span class=\"hljs-params\">(E item)</span>&#123;<br>    <span class=\"hljs-keyword\">synchronized</span>(<span class=\"hljs-built_in\">this</span>) &#123;<br>        ...<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">poll</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-built_in\">this</span>) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或者使用<code>ReentrantLock</code>，后面还能方便的设计阻塞功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HighPerformanceFIFOQueue</span>&lt;T&gt; &#123;<br>    ...<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ReentrantLock lock;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">HighPerformanceFIFOQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> capacity)</span> &#123;<br>        ...<br>        <span class=\"hljs-built_in\">this</span>.lock = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReentrantLock</span>(<span class=\"hljs-literal\">true</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">offer</span><span class=\"hljs-params\">(E item)</span>&#123;<br>        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">ReentrantLock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.lock;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            ...<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock()<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">poll</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">ReentrantLock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.lock;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            ...<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>恭喜，我们已经实现了ArrayBlockingQueue的核心逻辑。赶紧翻一翻源码，看看有什么不同？</p>\n<blockquote>\n<p>ABQ &#x3D; ArrayBlockingQueue，HP &#x3D; HighPerformanceFIFOQueue</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>195.490</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>97.748</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>97.741</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>195.983</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>98.132</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>97.851</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n<p>可以看到，两者因为同步机制相同，吞吐量也相同。但是这个吞吐量高么？如果我们不考虑FIFO，使用非公平锁会是什么结果？</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>83856.887</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>61293.762</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>22563.125</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>92083.911</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>73741.456</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>ABQ.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>18342.456</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n<p>可以看到吞吐量有数量级程度的提升，但是看数值生产者和消费者缺不能匹配，这是因为offer方法中如果发现队列是空的就会立即返回，导致两边吞吐量不匹配。</p>\n<p><strong>为什么公平锁对性能的影响这么严重？</strong></p>\n<p>公平锁保证了线程获取锁的顺序是按照请求锁的先后顺序来进行的，也就是先到先得，在这里主要是对生产者而言需要公平才能保证FIFO。非公平锁不保证线程获取锁的顺序，当锁被释放时，任何一个等待的线程都有机会获取锁，而不是按照请求的先后顺序。</p>\n<blockquote>\n<p>设想一个电话客服排队场景，接线员就是消费者，客户是生产者。当客户电话请求超过接线员数量时出现生产者竞争，大家需要排队等待接线员接入。正常逻辑需要按照先来后到的原则排队，如果此时使用非公平锁，就可能出现客户A等了10分钟没有接通反而客户B等了2分钟就接通的情况，因为非公平锁不保证先来后到，在等待池的所有请求都有可能争抢到锁。</p>\n</blockquote>\n<p>由于公平锁必须保证请求按照先来后到的顺序获得锁，所以为了维护请求顺序，必须有额外的资源用于排队和调度。而队列的读写使用同一把锁，所以两者必须交替进行。因此我们可以看到使用公平锁模式时生产者和消费者的吞吐量几乎一致，而频繁的唤醒、阻塞以及上下文切换也进一步拖慢了整体吞吐量。<br>所以要想实现高性能，就不能依赖基于ObjectMonitor的重量锁同步机制。其次，要考虑缩小锁的粒度，尽可能避免offer和poll操作互相争抢锁。</p>\n<h4 id=\"3-2-2-方案二：CAS自旋\"><a href=\"#3-2-2-方案二：CAS自旋\" class=\"headerlink\" title=\"3.2.2. 方案二：CAS自旋\"></a>3.2.2. 方案二：CAS自旋</h4><p>回到开头，我们希望head和tail的更新可以分开，同时由于需要判断head和tail重合时RingBuffer为空还是满了的问题，需要保证可见性。<br>先使用原子类改造head和tail，利用CAS自旋解决同步问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HighPerformanceFIFOQueue</span>&lt;E&gt; &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> capacity;<br><br>    <span class=\"hljs-comment\">// 将 head 和 tail 改造成原子类</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">AtomicInteger</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicInteger</span>(<span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">AtomicInteger</span> <span class=\"hljs-variable\">tail</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicInteger</span>(<span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Object[] buffer;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">HighPerformanceFIFOQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> capacity)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.capacity = capacity;<br>        <span class=\"hljs-built_in\">this</span>.buffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[capacity];<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">offer</span><span class=\"hljs-params\">(E item)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">currentTail</span> <span class=\"hljs-operator\">=</span> tail.get();<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nextTail</span> <span class=\"hljs-operator\">=</span> (currentTail + <span class=\"hljs-number\">1</span>) % buffer.length;<br>        <span class=\"hljs-keyword\">if</span> (nextTail == head.get()) &#123;<br>            <span class=\"hljs-comment\">// 队列已满</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        buffer[currentTail] = item;<br>        tail.set(nextTail);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">poll</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (head.get() == tail.get()) &#123;<br>            <span class=\"hljs-comment\">// 队列为空</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        &#125;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">currentHead</span> <span class=\"hljs-operator\">=</span> head.get();<br>        <span class=\"hljs-meta\">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class=\"hljs-type\">E</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> (E) buffer[currentHead];<br>        buffer[currentHead] = <span class=\"hljs-literal\">null</span>;<br>        head.set((currentHead + <span class=\"hljs-number\">1</span>) % buffer.length);<br>        <span class=\"hljs-keyword\">return</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>基准测试结果如下：</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>19352.535</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>11265.928</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>8086.607</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>14997.528</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>7732.578</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>7264.950</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n<p>可以看到，随着并发数的增加，整体吞吐量在下降，但仍然远远领先公平锁模式。可见频繁唤醒、阻塞以及上下文切换带来的影响之大。</p>\n<h3 id=\"3-3-更进一步\"><a href=\"#3-3-更进一步\" class=\"headerlink\" title=\"3.3. 更进一步\"></a>3.3. 更进一步</h3><p>如果我们只是需要验证设计思路，那到这里基本上已经可以收工了。但是我们肯定不能做这种浅尝辄止的事情，还记得前面提到的伪共享和批量优化么？</p>\n<h4 id=\"3-3-1-消除伪共享\"><a href=\"#3-3-1-消除伪共享\" class=\"headerlink\" title=\"3.3.1. 消除伪共享\"></a>3.3.1. 消除伪共享</h4><p>简单复习一下Cache Line的机制，CPU为了提高缓存命中率和使用效率，每次都会按行获取数据。考虑下面的情况：</p>\n<blockquote>\n<p>由于<code>head</code>和<code>tail</code>二者在字节码文件中相近，会被放置在内存中靠近的位置，核心在装载缓存时会直接从主存中拉取一个Cache Line的数据，有可能同时把<code>head</code>和<code>tail</code>同时拉走。<br>核心0负责生产者，需要更新<code>tail</code>，而核心1负责消费者，需要更新<code>head</code>。当核心0更新时会作废核心1中一整个Cache Line的数据，导致核心1需要重新从主存读取数据。</p>\n</blockquote>\n<p>上面这种情况，两个核心访问两个不同的变量，不产生竞态条件，但是依然表现出资源的互斥性看起来就像是共享资源一样，就是伪共享。</p>\n<p>知道原理后解决起来也很简单，用无效数据填充空间，保证要访问的数据不会出现在同一个Cache Line中即可。现代x86架构CPU一个Cache Line通常是64B，arm架构CPU普遍是128B。<br>填充方法有很多种：</p>\n<p><strong>1. 使用<code>@Contended</code>注解</strong><br>通过<code>sun.misc.Contended</code>可以由java自动完成填充工作，但是由于这是内部注解，从规范上来说它是不稳定的，并不承诺永远不变。所以虽然这种方法最简单，但我们不会采用。</p>\n<p><strong>2. 手动填充</strong><br>手动填充通过插入无效数据填满Cache Line从而实现Cache Line对齐。<br>例如在本例中，我们期望<code>head</code>和<code>tail</code>在不同的缓存行，使用<code>long</code>填充，服务器是x86架构CPU预计填充到64B以上。</p>\n<ul>\n<li>每个long类型占8字节，7个long字段共56字节</li>\n<li>结合AtomicInteger（4字节）和对象头（8-16字节），确保head和tail分布在不同的缓存行</li>\n</ul>\n<p>字段排列策略：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 内存布局示意图（64字节缓存行）：</span><br>[ head (4B) | 对象头 (12B) | p1-p7 (56B) ] → <span class=\"hljs-number\">4</span>+<span class=\"hljs-number\">12</span>+<span class=\"hljs-number\">56</span>=72B（跨缓存行）<br>[ tail (4B) | p8-p14 (56B) | ... ] → 新的缓存行起始<br></code></pre></td></tr></table></figure>\n\n<p><strong>3.注意事项</strong><br>​JVM内存布局不确定性：</p>\n<ul>\n<li>使用-XX:FieldsAllocationStyle&#x3D;1强制字段顺序（HotSpot参数）</li>\n<li>通过Unsafe.objectFieldOffset验证字段偏移量</li>\n</ul>\n<p>​对象大小验证工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 使用JOL工具分析对象布局</span><br>java -jar jol-cli.jar internals HighPerformanceQueue<br></code></pre></td></tr></table></figure>\n\n<p><strong>最终代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">AtomicInteger</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicInteger</span>(<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">long</span> p1, p2, p3, p4, p5, p6, p7;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">AtomicInteger</span> <span class=\"hljs-variable\">tail</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicInteger</span>(<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">long</span> p8, p9, p10, p11, p12, p13, p14, p15;<br></code></pre></td></tr></table></figure>\n\n<p><strong>基准测试结果</strong><br>可以看到对齐Cache Line之后，高并发情况下吞吐量有了明显改善。对齐Cache Line明显减少了伪共享导致的同步开销。</p>\n<blockquote>\n<p>未对齐Cache line</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>19352.535</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>11265.928</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>8086.607</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>14997.528</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>7732.578</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>7264.950</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n<p>对齐Cache Line</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark</th>\n<th>(capacity)</th>\n<th>(consumers)</th>\n<th>(producers)</th>\n<th>Mode</th>\n<th>Score</th>\n<th>Units</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>18715.221</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>10845.742</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>4</td>\n<td>4</td>\n<td>thrpt</td>\n<td>7869.480</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>22896.964</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputConsumer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>12737.297</td>\n<td>ops&#x2F;ms</td>\n</tr>\n<tr>\n<td>HP.throughput:throughputProducer</td>\n<td>1024</td>\n<td>16</td>\n<td>16</td>\n<td>thrpt</td>\n<td>10159.668</td>\n<td>ops&#x2F;ms</td>\n</tr>\n</tbody></table>\n</blockquote>\n<h4 id=\"3-3-2-批量读写优化\"><a href=\"#3-3-2-批量读写优化\" class=\"headerlink\" title=\"3.3.2. 批量读写优化\"></a>3.3.2. 批量读写优化</h4><p>另一种提高吞吐量的办法是提升单次操作的数据量，即批处理思路。<br>比如一次</p>\n<h4 id=\"3-3-3-补齐Queue的其他接口\"><a href=\"#3-3-3-补齐Queue的其他接口\" class=\"headerlink\" title=\"3.3.3. 补齐Queue的其他接口\"></a>3.3.3. 补齐Queue的其他接口</h4><p><strong>下标优化</strong><br>一般单机高性能FIFO队列不会很大，因为过大的FIFO队列内存利用率低，也不利于提升性能。所以我们可以要求队列容量必须满足2的幂，这样在环形队列求下标时可以简单的通过位运算</p>\n<h4 id=\"3-3-4-支持阻塞\"><a href=\"#3-3-4-支持阻塞\" class=\"headerlink\" title=\"3.3.4. 支持阻塞\"></a>3.3.4. 支持阻塞</h4>"},{"title":"为什么Netty宁可自己实现ByteBuf也不愿意使用ByteBuffer","date":"2025-02-28T11:00:00.000Z","_content":"> 面试遇到个题目，“为什么Netty宁可自己实现ByteBuf也不愿意使用ByteBuffer”\n> 正常说来就是引用计数好回收和大小可变，可是面试官提出不同的看法，热烈讨论一番之后我们谁也不能说服谁。\n> 虽然面试黄了但总结不能少，不能及时拿出成体系的论据证明自己的观点，还是平时还是过于怠惰。\n\n## 1. 接口差异\n\n先看二者的接口差异，找到netty到底比jdk自带的ByteBuffer多做了哪些事情\n\n### 1.1. 实例化\n\n`ByteBuffer`主要通过静态方法进行内存分配，有堆内和对外两种模式。\n\n```java\nimport java.nio.ByteBuffer;\n\n// 分配堆内缓冲区\nByteBuffer heapBuffer = ByteBuffer.allocate(1024);\n// 分配堆外缓冲区\nByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);\n```\n\n`ByteBuf`主要通过`Unpooled`工具类创建，也可以使用`PooledByteBufAllocator`在池化的内存空间中创建`ByteBuf`，避开系统反复开辟和回收的开销。\n\n```java\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.buffer.PooledByteBufAllocator;\n\n// 创建非池化的堆内存 ByteBuf\nByteBuf heapByteBuf = Unpooled.buffer(1024);\n// 创建非池化的直接内存 ByteBuf\nByteBuf directByteBuf = Unpooled.directBuffer(1024);\n\n// 获取池化的 ByteBuf 分配器\nPooledByteBufAllocator allocator = PooledByteBufAllocator.DEFAULT;\n// 分配一个池化的 ByteBuf 实例\nByteBuf byteBuf = allocator.buffer(1024);\ntry {\n    // 使用 ByteBuf\n    byteBuf.writeByte(1);\n    System.out.println(\"ByteBuf 写入成功\");\n} finally {\n    // 释放 ByteBuf\n    byteBuf.release();\n}\n```\n\n从对象创建角度来看，两者区别不大。Netty额外提供了池化的内存分配工具。\n\n### 1.2. 读写操作\n\n`ByteBuffer`需要手动调用`filp()`方法从写模式切换到读模式，调用`clear()`或`compact()`方法从读模式切换到写模式\n\n```java\nByteBuffer buffer = ByteBuffer.allocate(10);\nbuffer.put((byte) 1); // 写操作\nbuffer.flip(); // 切换到读模式\nbyte value = buffer.get(); // 读操作\nbuffer.clear(); // 切换回写模式\n```\n\n`ByteBuf`读写模式分离，有独立的读索引和写索引，不需要切换模式，操作更简单。\n\n```java\nByteBuf byteBuf = Unpooled.buffer(10);\nbyteBuf.writeByte(1); // 写操作\nbyte readValue = byteBuf.readByte(); // 读操作\n```\n\n从读写方面来看，`ByteBuffer`操作繁琐，由于只有一个索引，读和写需要调用`filp()`或者`clear()`切换，编写代码容易出错。\n\n### 1.3. 容量管理\n\n`ByteBuffer`容量固定，一旦分配不能动态扩展，需要创建新的`ByteBuffer`实例然后手动复制数据至新的实例。\n\n```java\nByteBuffer original = ByteBuffer.allocate(10);\n// 如果需要更大容量，需要重新分配\nByteBuffer newBuffer = ByteBuffer.allocate(20);\noriginal.flip();\nnewBuffer.put(original);\n```\n\n`ByteBuf`容量可以通过`ensureWritable(int minWritableBytes)`方法保证有足够空间写入数据，如果不够，会自动扩展不需要手动复制。\n\n```java\nByteBuf byteBuf = Unpooled.buffer(10);\nbyteBuf.ensureWritable(20); // 确保有 20 字节的可写空间\n```\n\n这里比较有意思的是`ByteBuf`根据实现会提供不同的行为，主要看`capacity()`的具体实现。比如`UnpooledDirectByteBuf`在实际扩容时依然进行了复制，但是`PooledByteBuf`由于使用池化资源，仅移动了计数器。可以看到，`ByteBuf`通过暴露的接口可以方便的调整大小而不用手动复制，比起`ByteBuffer`使用更为便捷。\n\n### 1.4. 垃圾回收\n\n`ByteBuffer`依赖垃圾回收，堆外的直接内存需要手动调用`java.lang.ref.Cleaner`进行释放(cleaner并不堆外暴露清除直接内存的方法)，或者等待ByteBuffer不再被引用后在某个时段被GC回收。\n\n`ByteBuf`使用引用计数来管理内存，通过`retain()`方法来增加引用计数，`release()`方法减少引用计数。当计数为0时，会自动释放。\n\n```java\nByteBuf byteBuf = Unpooled.buffer(10);\nbyteBuf.retain(); // 增加引用计数\nbyteBuf.release(); // 减少引用计数\n```\n\n### 1.5. 切片与复制\n\n`ByteBuffer`通过`slice()`方法创建的切片与原缓冲区共享底层数据，修改切片会影响原缓冲区\n\n```java\nByteBuffer buffer = ByteBuffer.allocate(10);\nByteBuffer slice = buffer.slice();\nslice.put((byte) 1); // 会影响原缓冲区\n```\n\n`ByteBuf`的切片和复制更灵活，`slice()`方法创建的切片同样共享底层数据，但`duplicate()`方法创建的副本也共享底层数据，而`copy()`方法创建的是独立的副本，修改副本不会影响原`ByteBuf`。\n\n```java\nByteBuf byteBuf = Unpooled.buffer(10);\nByteBuf slice = byteBuf.slice();\nByteBuf copy = byteBuf.copy();\nslice.setByte(0, 1); // 会影响原 ByteBuf\ncopy.setByte(0, 2); // 不会影响原 ByteBuf\n```\n\n## 2. 网络编程场景对比\n\n### 2.1. 频繁数据读写\n\n#### 2.1.1. 场景描述\n\n在网络编程中，服务器需要不断接收客户端发送的数据并进行处理，同时也需要向客户端发送响应数据，数据的读写操作非常频繁。\n\n#### 2.1.2. `ByteBuffer`的潜在风险\n\n使用`ByteBuffer`需要确认当前读写模式，如果处于读模式，忘记调用filp()就会抛出异常。在业务复杂的情况下，容易出现难以察觉的编码失误，出错风险增加。\n\n#### 2.1.3. `ByteBuf`的好处\n\n采用读写分离的索引，不需要手动切换读写模式，代码更加简洁，减少了出错的可能性。\n\n### 2.2. 数据量不确定的情况\n\n#### 2.2.1. 场景描述\n\n网络传输中，待接收的数据量往往不确定。例如在文件上传场景中，客户端上传的文件大小就不确定。再比如接收一段分成多个chunk发送的长报文，比如GB28181的设备目录，协议仅提供条目总数信息，并不能给出每个条目占用多大空间。此时需要动态处理不同大小的数据。\n\n#### 2.2.2. `ByteBuffer`的问题\n\n`ByteBuffer`的容量固定，一旦分配就无法动态扩展，如果数据量超过一开始开辟的大小，需要手动创建新的`ByteBuffer`对象并复制数据，这会增加内存开销和代码复杂度。\n\n#### 2.2.3. `ByteBuf`的好处\n\n`ByteBuf`可以通过`ensureWritable(int minWritableBytes)`方法动态扩展容量，当数据量超过当前容量时，会自动进行扩容，无需手动处理。尤其池化的`ByteBuf`没有创建新对象和数据复制的开销。\n\n### 2.3. 高并发场景下的内存管理\n\n#### 2.3.1. 场景描述\n\n在高并发的网络编程中，会有大量的连接同时进行数据传输，每个连接都需要分配一定的内存来处理数据。如果内存管理不当，会导致内存泄漏或内存溢出。\n\n#### 2.3.2. `ByteBuffer`的潜在风险\n\n`ByteBuffer`的内存管理依赖于`Java`的垃圾回收机制，对于堆外内存如果不等待GC，还需要手动调用`Cleaner`进行释放。在高并发场景下，频繁的创建和销毁`ByteBuffer`会给垃圾回收带来很大压力，影响系统性能。\n\n#### 2.3.3. `ByteBuf`的优势\n\n`ByteBuf`采用引用计数机制，通过`retain()`和`release()`方法来管理内存。当一个`ByteBuf`不再使用时，只要其引用计数为0，就会立即释放内存，避免了垃圾回收的压力。在Netty中，还提供了池化的 `ByteBuf`分配器，可以复用`ByteBuf`实例，减少内存分配和释放的开销。\n\n## 3. Netty 何时使用池化的`ByteBuf`\n\n### 3.1. 高并发场景\n\n在高并发的网络编程环境中，大量的连接会频繁地进行数据读写操作。每次创建和销毁`ByteBuf`会带来显著的内存分配和回收开销，这可能会成为系统性能的瓶颈。池化的`ByteBuf`可以通过复用已有的`ByteBuf`实例，减少内存分配和垃圾回收的压力，从而提高系统的性能和响应速度。\n例如，在一个基于Netty构建的高并发服务器中，每秒可能会处理数千甚至数万个请求，每个请求都需要分配一定的内存来处理数据。使用池化的`ByteBuf`可以避免频繁的内存分配和回收操作，使得系统能够更高效地处理大量请求。\n\n### 3.2. 内存资源紧张的场景\n\n当系统的内存资源有限时，池化的`ByteBuf`可以更好地管理内存使用。通过复用`ByteBuf`实例，减少了内存碎片的产生，提高了内存的利用率。这对于一些资源受限的设备（如嵌入式系统）或者在云计算环境中需要严格控制内存使用的场景尤为重要。\n\n### 3.3. 长连接场景\n\n在长连接的网络应用中，客户端和服务器之间会保持长时间的连接，不断地进行数据传输。在这种情况下，使用池化的`ByteBuf`可以减少每次数据传输时的内存分配开销，提高连接的稳定性和性能。\n\n## 总结\n\n为什么Netty宁可自己实现ByteBuf也不愿意使用`ByteBuffer`呢？虽然没有机会直接询问作者，但是从源码入手可以明显感受到，jdk自带的`ByteBuffer`在使用上存在诸多不便，比如没有池化，回收条件苛刻等。netty作为网络框架需要更高效和便捷的工具，为此不得不额外增加大量设计。\n\n对了，还有`ByteBuf`的容量是否可变的争论。从接口定义来看，是可变的。细纠实现，非池化的`ByteBuf`会创建新的数组并且复制数据，池化的`ByteBuf`仅会改变内部的计数器，没有其他副作用。\n","source":"_posts/2025/why-netty-prefer-bytebuf-to-bytebuffer.md","raw":"---\ntitle: 为什么Netty宁可自己实现ByteBuf也不愿意使用ByteBuffer\ndate: 2025-02-28 19:00:00\ntag:\n  - netty\n  - 网络编程\n  - 面试\n---\n> 面试遇到个题目，“为什么Netty宁可自己实现ByteBuf也不愿意使用ByteBuffer”\n> 正常说来就是引用计数好回收和大小可变，可是面试官提出不同的看法，热烈讨论一番之后我们谁也不能说服谁。\n> 虽然面试黄了但总结不能少，不能及时拿出成体系的论据证明自己的观点，还是平时还是过于怠惰。\n\n## 1. 接口差异\n\n先看二者的接口差异，找到netty到底比jdk自带的ByteBuffer多做了哪些事情\n\n### 1.1. 实例化\n\n`ByteBuffer`主要通过静态方法进行内存分配，有堆内和对外两种模式。\n\n```java\nimport java.nio.ByteBuffer;\n\n// 分配堆内缓冲区\nByteBuffer heapBuffer = ByteBuffer.allocate(1024);\n// 分配堆外缓冲区\nByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);\n```\n\n`ByteBuf`主要通过`Unpooled`工具类创建，也可以使用`PooledByteBufAllocator`在池化的内存空间中创建`ByteBuf`，避开系统反复开辟和回收的开销。\n\n```java\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.buffer.PooledByteBufAllocator;\n\n// 创建非池化的堆内存 ByteBuf\nByteBuf heapByteBuf = Unpooled.buffer(1024);\n// 创建非池化的直接内存 ByteBuf\nByteBuf directByteBuf = Unpooled.directBuffer(1024);\n\n// 获取池化的 ByteBuf 分配器\nPooledByteBufAllocator allocator = PooledByteBufAllocator.DEFAULT;\n// 分配一个池化的 ByteBuf 实例\nByteBuf byteBuf = allocator.buffer(1024);\ntry {\n    // 使用 ByteBuf\n    byteBuf.writeByte(1);\n    System.out.println(\"ByteBuf 写入成功\");\n} finally {\n    // 释放 ByteBuf\n    byteBuf.release();\n}\n```\n\n从对象创建角度来看，两者区别不大。Netty额外提供了池化的内存分配工具。\n\n### 1.2. 读写操作\n\n`ByteBuffer`需要手动调用`filp()`方法从写模式切换到读模式，调用`clear()`或`compact()`方法从读模式切换到写模式\n\n```java\nByteBuffer buffer = ByteBuffer.allocate(10);\nbuffer.put((byte) 1); // 写操作\nbuffer.flip(); // 切换到读模式\nbyte value = buffer.get(); // 读操作\nbuffer.clear(); // 切换回写模式\n```\n\n`ByteBuf`读写模式分离，有独立的读索引和写索引，不需要切换模式，操作更简单。\n\n```java\nByteBuf byteBuf = Unpooled.buffer(10);\nbyteBuf.writeByte(1); // 写操作\nbyte readValue = byteBuf.readByte(); // 读操作\n```\n\n从读写方面来看，`ByteBuffer`操作繁琐，由于只有一个索引，读和写需要调用`filp()`或者`clear()`切换，编写代码容易出错。\n\n### 1.3. 容量管理\n\n`ByteBuffer`容量固定，一旦分配不能动态扩展，需要创建新的`ByteBuffer`实例然后手动复制数据至新的实例。\n\n```java\nByteBuffer original = ByteBuffer.allocate(10);\n// 如果需要更大容量，需要重新分配\nByteBuffer newBuffer = ByteBuffer.allocate(20);\noriginal.flip();\nnewBuffer.put(original);\n```\n\n`ByteBuf`容量可以通过`ensureWritable(int minWritableBytes)`方法保证有足够空间写入数据，如果不够，会自动扩展不需要手动复制。\n\n```java\nByteBuf byteBuf = Unpooled.buffer(10);\nbyteBuf.ensureWritable(20); // 确保有 20 字节的可写空间\n```\n\n这里比较有意思的是`ByteBuf`根据实现会提供不同的行为，主要看`capacity()`的具体实现。比如`UnpooledDirectByteBuf`在实际扩容时依然进行了复制，但是`PooledByteBuf`由于使用池化资源，仅移动了计数器。可以看到，`ByteBuf`通过暴露的接口可以方便的调整大小而不用手动复制，比起`ByteBuffer`使用更为便捷。\n\n### 1.4. 垃圾回收\n\n`ByteBuffer`依赖垃圾回收，堆外的直接内存需要手动调用`java.lang.ref.Cleaner`进行释放(cleaner并不堆外暴露清除直接内存的方法)，或者等待ByteBuffer不再被引用后在某个时段被GC回收。\n\n`ByteBuf`使用引用计数来管理内存，通过`retain()`方法来增加引用计数，`release()`方法减少引用计数。当计数为0时，会自动释放。\n\n```java\nByteBuf byteBuf = Unpooled.buffer(10);\nbyteBuf.retain(); // 增加引用计数\nbyteBuf.release(); // 减少引用计数\n```\n\n### 1.5. 切片与复制\n\n`ByteBuffer`通过`slice()`方法创建的切片与原缓冲区共享底层数据，修改切片会影响原缓冲区\n\n```java\nByteBuffer buffer = ByteBuffer.allocate(10);\nByteBuffer slice = buffer.slice();\nslice.put((byte) 1); // 会影响原缓冲区\n```\n\n`ByteBuf`的切片和复制更灵活，`slice()`方法创建的切片同样共享底层数据，但`duplicate()`方法创建的副本也共享底层数据，而`copy()`方法创建的是独立的副本，修改副本不会影响原`ByteBuf`。\n\n```java\nByteBuf byteBuf = Unpooled.buffer(10);\nByteBuf slice = byteBuf.slice();\nByteBuf copy = byteBuf.copy();\nslice.setByte(0, 1); // 会影响原 ByteBuf\ncopy.setByte(0, 2); // 不会影响原 ByteBuf\n```\n\n## 2. 网络编程场景对比\n\n### 2.1. 频繁数据读写\n\n#### 2.1.1. 场景描述\n\n在网络编程中，服务器需要不断接收客户端发送的数据并进行处理，同时也需要向客户端发送响应数据，数据的读写操作非常频繁。\n\n#### 2.1.2. `ByteBuffer`的潜在风险\n\n使用`ByteBuffer`需要确认当前读写模式，如果处于读模式，忘记调用filp()就会抛出异常。在业务复杂的情况下，容易出现难以察觉的编码失误，出错风险增加。\n\n#### 2.1.3. `ByteBuf`的好处\n\n采用读写分离的索引，不需要手动切换读写模式，代码更加简洁，减少了出错的可能性。\n\n### 2.2. 数据量不确定的情况\n\n#### 2.2.1. 场景描述\n\n网络传输中，待接收的数据量往往不确定。例如在文件上传场景中，客户端上传的文件大小就不确定。再比如接收一段分成多个chunk发送的长报文，比如GB28181的设备目录，协议仅提供条目总数信息，并不能给出每个条目占用多大空间。此时需要动态处理不同大小的数据。\n\n#### 2.2.2. `ByteBuffer`的问题\n\n`ByteBuffer`的容量固定，一旦分配就无法动态扩展，如果数据量超过一开始开辟的大小，需要手动创建新的`ByteBuffer`对象并复制数据，这会增加内存开销和代码复杂度。\n\n#### 2.2.3. `ByteBuf`的好处\n\n`ByteBuf`可以通过`ensureWritable(int minWritableBytes)`方法动态扩展容量，当数据量超过当前容量时，会自动进行扩容，无需手动处理。尤其池化的`ByteBuf`没有创建新对象和数据复制的开销。\n\n### 2.3. 高并发场景下的内存管理\n\n#### 2.3.1. 场景描述\n\n在高并发的网络编程中，会有大量的连接同时进行数据传输，每个连接都需要分配一定的内存来处理数据。如果内存管理不当，会导致内存泄漏或内存溢出。\n\n#### 2.3.2. `ByteBuffer`的潜在风险\n\n`ByteBuffer`的内存管理依赖于`Java`的垃圾回收机制，对于堆外内存如果不等待GC，还需要手动调用`Cleaner`进行释放。在高并发场景下，频繁的创建和销毁`ByteBuffer`会给垃圾回收带来很大压力，影响系统性能。\n\n#### 2.3.3. `ByteBuf`的优势\n\n`ByteBuf`采用引用计数机制，通过`retain()`和`release()`方法来管理内存。当一个`ByteBuf`不再使用时，只要其引用计数为0，就会立即释放内存，避免了垃圾回收的压力。在Netty中，还提供了池化的 `ByteBuf`分配器，可以复用`ByteBuf`实例，减少内存分配和释放的开销。\n\n## 3. Netty 何时使用池化的`ByteBuf`\n\n### 3.1. 高并发场景\n\n在高并发的网络编程环境中，大量的连接会频繁地进行数据读写操作。每次创建和销毁`ByteBuf`会带来显著的内存分配和回收开销，这可能会成为系统性能的瓶颈。池化的`ByteBuf`可以通过复用已有的`ByteBuf`实例，减少内存分配和垃圾回收的压力，从而提高系统的性能和响应速度。\n例如，在一个基于Netty构建的高并发服务器中，每秒可能会处理数千甚至数万个请求，每个请求都需要分配一定的内存来处理数据。使用池化的`ByteBuf`可以避免频繁的内存分配和回收操作，使得系统能够更高效地处理大量请求。\n\n### 3.2. 内存资源紧张的场景\n\n当系统的内存资源有限时，池化的`ByteBuf`可以更好地管理内存使用。通过复用`ByteBuf`实例，减少了内存碎片的产生，提高了内存的利用率。这对于一些资源受限的设备（如嵌入式系统）或者在云计算环境中需要严格控制内存使用的场景尤为重要。\n\n### 3.3. 长连接场景\n\n在长连接的网络应用中，客户端和服务器之间会保持长时间的连接，不断地进行数据传输。在这种情况下，使用池化的`ByteBuf`可以减少每次数据传输时的内存分配开销，提高连接的稳定性和性能。\n\n## 总结\n\n为什么Netty宁可自己实现ByteBuf也不愿意使用`ByteBuffer`呢？虽然没有机会直接询问作者，但是从源码入手可以明显感受到，jdk自带的`ByteBuffer`在使用上存在诸多不便，比如没有池化，回收条件苛刻等。netty作为网络框架需要更高效和便捷的工具，为此不得不额外增加大量设计。\n\n对了，还有`ByteBuf`的容量是否可变的争论。从接口定义来看，是可变的。细纠实现，非池化的`ByteBuf`会创建新的数组并且复制数据，池化的`ByteBuf`仅会改变内部的计数器，没有其他副作用。\n","slug":"2025/why-netty-prefer-bytebuf-to-bytebuffer","published":1,"updated":"2025-02-28T16:12:38.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7q3a39m0008totga71o1ih0","content":"<blockquote>\n<p>面试遇到个题目，“为什么Netty宁可自己实现ByteBuf也不愿意使用ByteBuffer”<br>正常说来就是引用计数好回收和大小可变，可是面试官提出不同的看法，热烈讨论一番之后我们谁也不能说服谁。<br>虽然面试黄了但总结不能少，不能及时拿出成体系的论据证明自己的观点，还是平时还是过于怠惰。</p>\n</blockquote>\n<h2 id=\"1-接口差异\"><a href=\"#1-接口差异\" class=\"headerlink\" title=\"1. 接口差异\"></a>1. 接口差异</h2><p>先看二者的接口差异，找到netty到底比jdk自带的ByteBuffer多做了哪些事情</p>\n<h3 id=\"1-1-实例化\"><a href=\"#1-1-实例化\" class=\"headerlink\" title=\"1.1. 实例化\"></a>1.1. 实例化</h3><p><code>ByteBuffer</code>主要通过静态方法进行内存分配，有堆内和对外两种模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.nio.ByteBuffer;<br><br><span class=\"hljs-comment\">// 分配堆内缓冲区</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">heapBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);<br><span class=\"hljs-comment\">// 分配堆外缓冲区</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">directBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocateDirect(<span class=\"hljs-number\">1024</span>);<br></code></pre></td></tr></table></figure>\n\n<p><code>ByteBuf</code>主要通过<code>Unpooled</code>工具类创建，也可以使用<code>PooledByteBufAllocator</code>在池化的内存空间中创建<code>ByteBuf</code>，避开系统反复开辟和回收的开销。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> io.netty.buffer.ByteBuf;<br><span class=\"hljs-keyword\">import</span> io.netty.buffer.Unpooled;<br><span class=\"hljs-keyword\">import</span> io.netty.buffer.PooledByteBufAllocator;<br><br><span class=\"hljs-comment\">// 创建非池化的堆内存 ByteBuf</span><br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">heapByteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">1024</span>);<br><span class=\"hljs-comment\">// 创建非池化的直接内存 ByteBuf</span><br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">directByteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.directBuffer(<span class=\"hljs-number\">1024</span>);<br><br><span class=\"hljs-comment\">// 获取池化的 ByteBuf 分配器</span><br><span class=\"hljs-type\">PooledByteBufAllocator</span> <span class=\"hljs-variable\">allocator</span> <span class=\"hljs-operator\">=</span> PooledByteBufAllocator.DEFAULT;<br><span class=\"hljs-comment\">// 分配一个池化的 ByteBuf 实例</span><br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> allocator.buffer(<span class=\"hljs-number\">1024</span>);<br><span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-comment\">// 使用 ByteBuf</span><br>    byteBuf.writeByte(<span class=\"hljs-number\">1</span>);<br>    System.out.println(<span class=\"hljs-string\">&quot;ByteBuf 写入成功&quot;</span>);<br>&#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    <span class=\"hljs-comment\">// 释放 ByteBuf</span><br>    byteBuf.release();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从对象创建角度来看，两者区别不大。Netty额外提供了池化的内存分配工具。</p>\n<h3 id=\"1-2-读写操作\"><a href=\"#1-2-读写操作\" class=\"headerlink\" title=\"1.2. 读写操作\"></a>1.2. 读写操作</h3><p><code>ByteBuffer</code>需要手动调用<code>filp()</code>方法从写模式切换到读模式，调用<code>clear()</code>或<code>compact()</code>方法从读模式切换到写模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);<br>buffer.put((<span class=\"hljs-type\">byte</span>) <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 写操作</span><br>buffer.flip(); <span class=\"hljs-comment\">// 切换到读模式</span><br><span class=\"hljs-type\">byte</span> <span class=\"hljs-variable\">value</span> <span class=\"hljs-operator\">=</span> buffer.get(); <span class=\"hljs-comment\">// 读操作</span><br>buffer.clear(); <span class=\"hljs-comment\">// 切换回写模式</span><br></code></pre></td></tr></table></figure>\n\n<p><code>ByteBuf</code>读写模式分离，有独立的读索引和写索引，不需要切换模式，操作更简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">10</span>);<br>byteBuf.writeByte(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 写操作</span><br><span class=\"hljs-type\">byte</span> <span class=\"hljs-variable\">readValue</span> <span class=\"hljs-operator\">=</span> byteBuf.readByte(); <span class=\"hljs-comment\">// 读操作</span><br></code></pre></td></tr></table></figure>\n\n<p>从读写方面来看，<code>ByteBuffer</code>操作繁琐，由于只有一个索引，读和写需要调用<code>filp()</code>或者<code>clear()</code>切换，编写代码容易出错。</p>\n<h3 id=\"1-3-容量管理\"><a href=\"#1-3-容量管理\" class=\"headerlink\" title=\"1.3. 容量管理\"></a>1.3. 容量管理</h3><p><code>ByteBuffer</code>容量固定，一旦分配不能动态扩展，需要创建新的<code>ByteBuffer</code>实例然后手动复制数据至新的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">original</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);<br><span class=\"hljs-comment\">// 如果需要更大容量，需要重新分配</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">newBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">20</span>);<br>original.flip();<br>newBuffer.put(original);<br></code></pre></td></tr></table></figure>\n\n<p><code>ByteBuf</code>容量可以通过<code>ensureWritable(int minWritableBytes)</code>方法保证有足够空间写入数据，如果不够，会自动扩展不需要手动复制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">10</span>);<br>byteBuf.ensureWritable(<span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">// 确保有 20 字节的可写空间</span><br></code></pre></td></tr></table></figure>\n\n<p>这里比较有意思的是<code>ByteBuf</code>根据实现会提供不同的行为，主要看<code>capacity()</code>的具体实现。比如<code>UnpooledDirectByteBuf</code>在实际扩容时依然进行了复制，但是<code>PooledByteBuf</code>由于使用池化资源，仅移动了计数器。可以看到，<code>ByteBuf</code>通过暴露的接口可以方便的调整大小而不用手动复制，比起<code>ByteBuffer</code>使用更为便捷。</p>\n<h3 id=\"1-4-垃圾回收\"><a href=\"#1-4-垃圾回收\" class=\"headerlink\" title=\"1.4. 垃圾回收\"></a>1.4. 垃圾回收</h3><p><code>ByteBuffer</code>依赖垃圾回收，堆外的直接内存需要手动调用<code>java.lang.ref.Cleaner</code>进行释放(cleaner并不堆外暴露清除直接内存的方法)，或者等待ByteBuffer不再被引用后在某个时段被GC回收。</p>\n<p><code>ByteBuf</code>使用引用计数来管理内存，通过<code>retain()</code>方法来增加引用计数，<code>release()</code>方法减少引用计数。当计数为0时，会自动释放。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">10</span>);<br>byteBuf.retain(); <span class=\"hljs-comment\">// 增加引用计数</span><br>byteBuf.release(); <span class=\"hljs-comment\">// 减少引用计数</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-切片与复制\"><a href=\"#1-5-切片与复制\" class=\"headerlink\" title=\"1.5. 切片与复制\"></a>1.5. 切片与复制</h3><p><code>ByteBuffer</code>通过<code>slice()</code>方法创建的切片与原缓冲区共享底层数据，修改切片会影响原缓冲区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);<br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">slice</span> <span class=\"hljs-operator\">=</span> buffer.slice();<br>slice.put((<span class=\"hljs-type\">byte</span>) <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 会影响原缓冲区</span><br></code></pre></td></tr></table></figure>\n\n<p><code>ByteBuf</code>的切片和复制更灵活，<code>slice()</code>方法创建的切片同样共享底层数据，但<code>duplicate()</code>方法创建的副本也共享底层数据，而<code>copy()</code>方法创建的是独立的副本，修改副本不会影响原<code>ByteBuf</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">10</span>);<br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">slice</span> <span class=\"hljs-operator\">=</span> byteBuf.slice();<br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">copy</span> <span class=\"hljs-operator\">=</span> byteBuf.copy();<br>slice.setByte(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 会影响原 ByteBuf</span><br>copy.setByte(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 不会影响原 ByteBuf</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-网络编程场景对比\"><a href=\"#2-网络编程场景对比\" class=\"headerlink\" title=\"2. 网络编程场景对比\"></a>2. 网络编程场景对比</h2><h3 id=\"2-1-频繁数据读写\"><a href=\"#2-1-频繁数据读写\" class=\"headerlink\" title=\"2.1. 频繁数据读写\"></a>2.1. 频繁数据读写</h3><h4 id=\"2-1-1-场景描述\"><a href=\"#2-1-1-场景描述\" class=\"headerlink\" title=\"2.1.1. 场景描述\"></a>2.1.1. 场景描述</h4><p>在网络编程中，服务器需要不断接收客户端发送的数据并进行处理，同时也需要向客户端发送响应数据，数据的读写操作非常频繁。</p>\n<h4 id=\"2-1-2-ByteBuffer的潜在风险\"><a href=\"#2-1-2-ByteBuffer的潜在风险\" class=\"headerlink\" title=\"2.1.2. ByteBuffer的潜在风险\"></a>2.1.2. <code>ByteBuffer</code>的潜在风险</h4><p>使用<code>ByteBuffer</code>需要确认当前读写模式，如果处于读模式，忘记调用filp()就会抛出异常。在业务复杂的情况下，容易出现难以察觉的编码失误，出错风险增加。</p>\n<h4 id=\"2-1-3-ByteBuf的好处\"><a href=\"#2-1-3-ByteBuf的好处\" class=\"headerlink\" title=\"2.1.3. ByteBuf的好处\"></a>2.1.3. <code>ByteBuf</code>的好处</h4><p>采用读写分离的索引，不需要手动切换读写模式，代码更加简洁，减少了出错的可能性。</p>\n<h3 id=\"2-2-数据量不确定的情况\"><a href=\"#2-2-数据量不确定的情况\" class=\"headerlink\" title=\"2.2. 数据量不确定的情况\"></a>2.2. 数据量不确定的情况</h3><h4 id=\"2-2-1-场景描述\"><a href=\"#2-2-1-场景描述\" class=\"headerlink\" title=\"2.2.1. 场景描述\"></a>2.2.1. 场景描述</h4><p>网络传输中，待接收的数据量往往不确定。例如在文件上传场景中，客户端上传的文件大小就不确定。再比如接收一段分成多个chunk发送的长报文，比如GB28181的设备目录，协议仅提供条目总数信息，并不能给出每个条目占用多大空间。此时需要动态处理不同大小的数据。</p>\n<h4 id=\"2-2-2-ByteBuffer的问题\"><a href=\"#2-2-2-ByteBuffer的问题\" class=\"headerlink\" title=\"2.2.2. ByteBuffer的问题\"></a>2.2.2. <code>ByteBuffer</code>的问题</h4><p><code>ByteBuffer</code>的容量固定，一旦分配就无法动态扩展，如果数据量超过一开始开辟的大小，需要手动创建新的<code>ByteBuffer</code>对象并复制数据，这会增加内存开销和代码复杂度。</p>\n<h4 id=\"2-2-3-ByteBuf的好处\"><a href=\"#2-2-3-ByteBuf的好处\" class=\"headerlink\" title=\"2.2.3. ByteBuf的好处\"></a>2.2.3. <code>ByteBuf</code>的好处</h4><p><code>ByteBuf</code>可以通过<code>ensureWritable(int minWritableBytes)</code>方法动态扩展容量，当数据量超过当前容量时，会自动进行扩容，无需手动处理。尤其池化的<code>ByteBuf</code>没有创建新对象和数据复制的开销。</p>\n<h3 id=\"2-3-高并发场景下的内存管理\"><a href=\"#2-3-高并发场景下的内存管理\" class=\"headerlink\" title=\"2.3. 高并发场景下的内存管理\"></a>2.3. 高并发场景下的内存管理</h3><h4 id=\"2-3-1-场景描述\"><a href=\"#2-3-1-场景描述\" class=\"headerlink\" title=\"2.3.1. 场景描述\"></a>2.3.1. 场景描述</h4><p>在高并发的网络编程中，会有大量的连接同时进行数据传输，每个连接都需要分配一定的内存来处理数据。如果内存管理不当，会导致内存泄漏或内存溢出。</p>\n<h4 id=\"2-3-2-ByteBuffer的潜在风险\"><a href=\"#2-3-2-ByteBuffer的潜在风险\" class=\"headerlink\" title=\"2.3.2. ByteBuffer的潜在风险\"></a>2.3.2. <code>ByteBuffer</code>的潜在风险</h4><p><code>ByteBuffer</code>的内存管理依赖于<code>Java</code>的垃圾回收机制，对于堆外内存如果不等待GC，还需要手动调用<code>Cleaner</code>进行释放。在高并发场景下，频繁的创建和销毁<code>ByteBuffer</code>会给垃圾回收带来很大压力，影响系统性能。</p>\n<h4 id=\"2-3-3-ByteBuf的优势\"><a href=\"#2-3-3-ByteBuf的优势\" class=\"headerlink\" title=\"2.3.3. ByteBuf的优势\"></a>2.3.3. <code>ByteBuf</code>的优势</h4><p><code>ByteBuf</code>采用引用计数机制，通过<code>retain()</code>和<code>release()</code>方法来管理内存。当一个<code>ByteBuf</code>不再使用时，只要其引用计数为0，就会立即释放内存，避免了垃圾回收的压力。在Netty中，还提供了池化的 <code>ByteBuf</code>分配器，可以复用<code>ByteBuf</code>实例，减少内存分配和释放的开销。</p>\n<h2 id=\"3-Netty-何时使用池化的ByteBuf\"><a href=\"#3-Netty-何时使用池化的ByteBuf\" class=\"headerlink\" title=\"3. Netty 何时使用池化的ByteBuf\"></a>3. Netty 何时使用池化的<code>ByteBuf</code></h2><h3 id=\"3-1-高并发场景\"><a href=\"#3-1-高并发场景\" class=\"headerlink\" title=\"3.1. 高并发场景\"></a>3.1. 高并发场景</h3><p>在高并发的网络编程环境中，大量的连接会频繁地进行数据读写操作。每次创建和销毁<code>ByteBuf</code>会带来显著的内存分配和回收开销，这可能会成为系统性能的瓶颈。池化的<code>ByteBuf</code>可以通过复用已有的<code>ByteBuf</code>实例，减少内存分配和垃圾回收的压力，从而提高系统的性能和响应速度。<br>例如，在一个基于Netty构建的高并发服务器中，每秒可能会处理数千甚至数万个请求，每个请求都需要分配一定的内存来处理数据。使用池化的<code>ByteBuf</code>可以避免频繁的内存分配和回收操作，使得系统能够更高效地处理大量请求。</p>\n<h3 id=\"3-2-内存资源紧张的场景\"><a href=\"#3-2-内存资源紧张的场景\" class=\"headerlink\" title=\"3.2. 内存资源紧张的场景\"></a>3.2. 内存资源紧张的场景</h3><p>当系统的内存资源有限时，池化的<code>ByteBuf</code>可以更好地管理内存使用。通过复用<code>ByteBuf</code>实例，减少了内存碎片的产生，提高了内存的利用率。这对于一些资源受限的设备（如嵌入式系统）或者在云计算环境中需要严格控制内存使用的场景尤为重要。</p>\n<h3 id=\"3-3-长连接场景\"><a href=\"#3-3-长连接场景\" class=\"headerlink\" title=\"3.3. 长连接场景\"></a>3.3. 长连接场景</h3><p>在长连接的网络应用中，客户端和服务器之间会保持长时间的连接，不断地进行数据传输。在这种情况下，使用池化的<code>ByteBuf</code>可以减少每次数据传输时的内存分配开销，提高连接的稳定性和性能。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>为什么Netty宁可自己实现ByteBuf也不愿意使用<code>ByteBuffer</code>呢？虽然没有机会直接询问作者，但是从源码入手可以明显感受到，jdk自带的<code>ByteBuffer</code>在使用上存在诸多不便，比如没有池化，回收条件苛刻等。netty作为网络框架需要更高效和便捷的工具，为此不得不额外增加大量设计。</p>\n<p>对了，还有<code>ByteBuf</code>的容量是否可变的争论。从接口定义来看，是可变的。细纠实现，非池化的<code>ByteBuf</code>会创建新的数组并且复制数据，池化的<code>ByteBuf</code>仅会改变内部的计数器，没有其他副作用。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>面试遇到个题目，“为什么Netty宁可自己实现ByteBuf也不愿意使用ByteBuffer”<br>正常说来就是引用计数好回收和大小可变，可是面试官提出不同的看法，热烈讨论一番之后我们谁也不能说服谁。<br>虽然面试黄了但总结不能少，不能及时拿出成体系的论据证明自己的观点，还是平时还是过于怠惰。</p>\n</blockquote>\n<h2 id=\"1-接口差异\"><a href=\"#1-接口差异\" class=\"headerlink\" title=\"1. 接口差异\"></a>1. 接口差异</h2><p>先看二者的接口差异，找到netty到底比jdk自带的ByteBuffer多做了哪些事情</p>\n<h3 id=\"1-1-实例化\"><a href=\"#1-1-实例化\" class=\"headerlink\" title=\"1.1. 实例化\"></a>1.1. 实例化</h3><p><code>ByteBuffer</code>主要通过静态方法进行内存分配，有堆内和对外两种模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.nio.ByteBuffer;<br><br><span class=\"hljs-comment\">// 分配堆内缓冲区</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">heapBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);<br><span class=\"hljs-comment\">// 分配堆外缓冲区</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">directBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocateDirect(<span class=\"hljs-number\">1024</span>);<br></code></pre></td></tr></table></figure>\n\n<p><code>ByteBuf</code>主要通过<code>Unpooled</code>工具类创建，也可以使用<code>PooledByteBufAllocator</code>在池化的内存空间中创建<code>ByteBuf</code>，避开系统反复开辟和回收的开销。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> io.netty.buffer.ByteBuf;<br><span class=\"hljs-keyword\">import</span> io.netty.buffer.Unpooled;<br><span class=\"hljs-keyword\">import</span> io.netty.buffer.PooledByteBufAllocator;<br><br><span class=\"hljs-comment\">// 创建非池化的堆内存 ByteBuf</span><br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">heapByteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">1024</span>);<br><span class=\"hljs-comment\">// 创建非池化的直接内存 ByteBuf</span><br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">directByteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.directBuffer(<span class=\"hljs-number\">1024</span>);<br><br><span class=\"hljs-comment\">// 获取池化的 ByteBuf 分配器</span><br><span class=\"hljs-type\">PooledByteBufAllocator</span> <span class=\"hljs-variable\">allocator</span> <span class=\"hljs-operator\">=</span> PooledByteBufAllocator.DEFAULT;<br><span class=\"hljs-comment\">// 分配一个池化的 ByteBuf 实例</span><br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> allocator.buffer(<span class=\"hljs-number\">1024</span>);<br><span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-comment\">// 使用 ByteBuf</span><br>    byteBuf.writeByte(<span class=\"hljs-number\">1</span>);<br>    System.out.println(<span class=\"hljs-string\">&quot;ByteBuf 写入成功&quot;</span>);<br>&#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    <span class=\"hljs-comment\">// 释放 ByteBuf</span><br>    byteBuf.release();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从对象创建角度来看，两者区别不大。Netty额外提供了池化的内存分配工具。</p>\n<h3 id=\"1-2-读写操作\"><a href=\"#1-2-读写操作\" class=\"headerlink\" title=\"1.2. 读写操作\"></a>1.2. 读写操作</h3><p><code>ByteBuffer</code>需要手动调用<code>filp()</code>方法从写模式切换到读模式，调用<code>clear()</code>或<code>compact()</code>方法从读模式切换到写模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);<br>buffer.put((<span class=\"hljs-type\">byte</span>) <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 写操作</span><br>buffer.flip(); <span class=\"hljs-comment\">// 切换到读模式</span><br><span class=\"hljs-type\">byte</span> <span class=\"hljs-variable\">value</span> <span class=\"hljs-operator\">=</span> buffer.get(); <span class=\"hljs-comment\">// 读操作</span><br>buffer.clear(); <span class=\"hljs-comment\">// 切换回写模式</span><br></code></pre></td></tr></table></figure>\n\n<p><code>ByteBuf</code>读写模式分离，有独立的读索引和写索引，不需要切换模式，操作更简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">10</span>);<br>byteBuf.writeByte(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 写操作</span><br><span class=\"hljs-type\">byte</span> <span class=\"hljs-variable\">readValue</span> <span class=\"hljs-operator\">=</span> byteBuf.readByte(); <span class=\"hljs-comment\">// 读操作</span><br></code></pre></td></tr></table></figure>\n\n<p>从读写方面来看，<code>ByteBuffer</code>操作繁琐，由于只有一个索引，读和写需要调用<code>filp()</code>或者<code>clear()</code>切换，编写代码容易出错。</p>\n<h3 id=\"1-3-容量管理\"><a href=\"#1-3-容量管理\" class=\"headerlink\" title=\"1.3. 容量管理\"></a>1.3. 容量管理</h3><p><code>ByteBuffer</code>容量固定，一旦分配不能动态扩展，需要创建新的<code>ByteBuffer</code>实例然后手动复制数据至新的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">original</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);<br><span class=\"hljs-comment\">// 如果需要更大容量，需要重新分配</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">newBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">20</span>);<br>original.flip();<br>newBuffer.put(original);<br></code></pre></td></tr></table></figure>\n\n<p><code>ByteBuf</code>容量可以通过<code>ensureWritable(int minWritableBytes)</code>方法保证有足够空间写入数据，如果不够，会自动扩展不需要手动复制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">10</span>);<br>byteBuf.ensureWritable(<span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">// 确保有 20 字节的可写空间</span><br></code></pre></td></tr></table></figure>\n\n<p>这里比较有意思的是<code>ByteBuf</code>根据实现会提供不同的行为，主要看<code>capacity()</code>的具体实现。比如<code>UnpooledDirectByteBuf</code>在实际扩容时依然进行了复制，但是<code>PooledByteBuf</code>由于使用池化资源，仅移动了计数器。可以看到，<code>ByteBuf</code>通过暴露的接口可以方便的调整大小而不用手动复制，比起<code>ByteBuffer</code>使用更为便捷。</p>\n<h3 id=\"1-4-垃圾回收\"><a href=\"#1-4-垃圾回收\" class=\"headerlink\" title=\"1.4. 垃圾回收\"></a>1.4. 垃圾回收</h3><p><code>ByteBuffer</code>依赖垃圾回收，堆外的直接内存需要手动调用<code>java.lang.ref.Cleaner</code>进行释放(cleaner并不堆外暴露清除直接内存的方法)，或者等待ByteBuffer不再被引用后在某个时段被GC回收。</p>\n<p><code>ByteBuf</code>使用引用计数来管理内存，通过<code>retain()</code>方法来增加引用计数，<code>release()</code>方法减少引用计数。当计数为0时，会自动释放。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">10</span>);<br>byteBuf.retain(); <span class=\"hljs-comment\">// 增加引用计数</span><br>byteBuf.release(); <span class=\"hljs-comment\">// 减少引用计数</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-切片与复制\"><a href=\"#1-5-切片与复制\" class=\"headerlink\" title=\"1.5. 切片与复制\"></a>1.5. 切片与复制</h3><p><code>ByteBuffer</code>通过<code>slice()</code>方法创建的切片与原缓冲区共享底层数据，修改切片会影响原缓冲区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);<br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">slice</span> <span class=\"hljs-operator\">=</span> buffer.slice();<br>slice.put((<span class=\"hljs-type\">byte</span>) <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 会影响原缓冲区</span><br></code></pre></td></tr></table></figure>\n\n<p><code>ByteBuf</code>的切片和复制更灵活，<code>slice()</code>方法创建的切片同样共享底层数据，但<code>duplicate()</code>方法创建的副本也共享底层数据，而<code>copy()</code>方法创建的是独立的副本，修改副本不会影响原<code>ByteBuf</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">byteBuf</span> <span class=\"hljs-operator\">=</span> Unpooled.buffer(<span class=\"hljs-number\">10</span>);<br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">slice</span> <span class=\"hljs-operator\">=</span> byteBuf.slice();<br><span class=\"hljs-type\">ByteBuf</span> <span class=\"hljs-variable\">copy</span> <span class=\"hljs-operator\">=</span> byteBuf.copy();<br>slice.setByte(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 会影响原 ByteBuf</span><br>copy.setByte(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 不会影响原 ByteBuf</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-网络编程场景对比\"><a href=\"#2-网络编程场景对比\" class=\"headerlink\" title=\"2. 网络编程场景对比\"></a>2. 网络编程场景对比</h2><h3 id=\"2-1-频繁数据读写\"><a href=\"#2-1-频繁数据读写\" class=\"headerlink\" title=\"2.1. 频繁数据读写\"></a>2.1. 频繁数据读写</h3><h4 id=\"2-1-1-场景描述\"><a href=\"#2-1-1-场景描述\" class=\"headerlink\" title=\"2.1.1. 场景描述\"></a>2.1.1. 场景描述</h4><p>在网络编程中，服务器需要不断接收客户端发送的数据并进行处理，同时也需要向客户端发送响应数据，数据的读写操作非常频繁。</p>\n<h4 id=\"2-1-2-ByteBuffer的潜在风险\"><a href=\"#2-1-2-ByteBuffer的潜在风险\" class=\"headerlink\" title=\"2.1.2. ByteBuffer的潜在风险\"></a>2.1.2. <code>ByteBuffer</code>的潜在风险</h4><p>使用<code>ByteBuffer</code>需要确认当前读写模式，如果处于读模式，忘记调用filp()就会抛出异常。在业务复杂的情况下，容易出现难以察觉的编码失误，出错风险增加。</p>\n<h4 id=\"2-1-3-ByteBuf的好处\"><a href=\"#2-1-3-ByteBuf的好处\" class=\"headerlink\" title=\"2.1.3. ByteBuf的好处\"></a>2.1.3. <code>ByteBuf</code>的好处</h4><p>采用读写分离的索引，不需要手动切换读写模式，代码更加简洁，减少了出错的可能性。</p>\n<h3 id=\"2-2-数据量不确定的情况\"><a href=\"#2-2-数据量不确定的情况\" class=\"headerlink\" title=\"2.2. 数据量不确定的情况\"></a>2.2. 数据量不确定的情况</h3><h4 id=\"2-2-1-场景描述\"><a href=\"#2-2-1-场景描述\" class=\"headerlink\" title=\"2.2.1. 场景描述\"></a>2.2.1. 场景描述</h4><p>网络传输中，待接收的数据量往往不确定。例如在文件上传场景中，客户端上传的文件大小就不确定。再比如接收一段分成多个chunk发送的长报文，比如GB28181的设备目录，协议仅提供条目总数信息，并不能给出每个条目占用多大空间。此时需要动态处理不同大小的数据。</p>\n<h4 id=\"2-2-2-ByteBuffer的问题\"><a href=\"#2-2-2-ByteBuffer的问题\" class=\"headerlink\" title=\"2.2.2. ByteBuffer的问题\"></a>2.2.2. <code>ByteBuffer</code>的问题</h4><p><code>ByteBuffer</code>的容量固定，一旦分配就无法动态扩展，如果数据量超过一开始开辟的大小，需要手动创建新的<code>ByteBuffer</code>对象并复制数据，这会增加内存开销和代码复杂度。</p>\n<h4 id=\"2-2-3-ByteBuf的好处\"><a href=\"#2-2-3-ByteBuf的好处\" class=\"headerlink\" title=\"2.2.3. ByteBuf的好处\"></a>2.2.3. <code>ByteBuf</code>的好处</h4><p><code>ByteBuf</code>可以通过<code>ensureWritable(int minWritableBytes)</code>方法动态扩展容量，当数据量超过当前容量时，会自动进行扩容，无需手动处理。尤其池化的<code>ByteBuf</code>没有创建新对象和数据复制的开销。</p>\n<h3 id=\"2-3-高并发场景下的内存管理\"><a href=\"#2-3-高并发场景下的内存管理\" class=\"headerlink\" title=\"2.3. 高并发场景下的内存管理\"></a>2.3. 高并发场景下的内存管理</h3><h4 id=\"2-3-1-场景描述\"><a href=\"#2-3-1-场景描述\" class=\"headerlink\" title=\"2.3.1. 场景描述\"></a>2.3.1. 场景描述</h4><p>在高并发的网络编程中，会有大量的连接同时进行数据传输，每个连接都需要分配一定的内存来处理数据。如果内存管理不当，会导致内存泄漏或内存溢出。</p>\n<h4 id=\"2-3-2-ByteBuffer的潜在风险\"><a href=\"#2-3-2-ByteBuffer的潜在风险\" class=\"headerlink\" title=\"2.3.2. ByteBuffer的潜在风险\"></a>2.3.2. <code>ByteBuffer</code>的潜在风险</h4><p><code>ByteBuffer</code>的内存管理依赖于<code>Java</code>的垃圾回收机制，对于堆外内存如果不等待GC，还需要手动调用<code>Cleaner</code>进行释放。在高并发场景下，频繁的创建和销毁<code>ByteBuffer</code>会给垃圾回收带来很大压力，影响系统性能。</p>\n<h4 id=\"2-3-3-ByteBuf的优势\"><a href=\"#2-3-3-ByteBuf的优势\" class=\"headerlink\" title=\"2.3.3. ByteBuf的优势\"></a>2.3.3. <code>ByteBuf</code>的优势</h4><p><code>ByteBuf</code>采用引用计数机制，通过<code>retain()</code>和<code>release()</code>方法来管理内存。当一个<code>ByteBuf</code>不再使用时，只要其引用计数为0，就会立即释放内存，避免了垃圾回收的压力。在Netty中，还提供了池化的 <code>ByteBuf</code>分配器，可以复用<code>ByteBuf</code>实例，减少内存分配和释放的开销。</p>\n<h2 id=\"3-Netty-何时使用池化的ByteBuf\"><a href=\"#3-Netty-何时使用池化的ByteBuf\" class=\"headerlink\" title=\"3. Netty 何时使用池化的ByteBuf\"></a>3. Netty 何时使用池化的<code>ByteBuf</code></h2><h3 id=\"3-1-高并发场景\"><a href=\"#3-1-高并发场景\" class=\"headerlink\" title=\"3.1. 高并发场景\"></a>3.1. 高并发场景</h3><p>在高并发的网络编程环境中，大量的连接会频繁地进行数据读写操作。每次创建和销毁<code>ByteBuf</code>会带来显著的内存分配和回收开销，这可能会成为系统性能的瓶颈。池化的<code>ByteBuf</code>可以通过复用已有的<code>ByteBuf</code>实例，减少内存分配和垃圾回收的压力，从而提高系统的性能和响应速度。<br>例如，在一个基于Netty构建的高并发服务器中，每秒可能会处理数千甚至数万个请求，每个请求都需要分配一定的内存来处理数据。使用池化的<code>ByteBuf</code>可以避免频繁的内存分配和回收操作，使得系统能够更高效地处理大量请求。</p>\n<h3 id=\"3-2-内存资源紧张的场景\"><a href=\"#3-2-内存资源紧张的场景\" class=\"headerlink\" title=\"3.2. 内存资源紧张的场景\"></a>3.2. 内存资源紧张的场景</h3><p>当系统的内存资源有限时，池化的<code>ByteBuf</code>可以更好地管理内存使用。通过复用<code>ByteBuf</code>实例，减少了内存碎片的产生，提高了内存的利用率。这对于一些资源受限的设备（如嵌入式系统）或者在云计算环境中需要严格控制内存使用的场景尤为重要。</p>\n<h3 id=\"3-3-长连接场景\"><a href=\"#3-3-长连接场景\" class=\"headerlink\" title=\"3.3. 长连接场景\"></a>3.3. 长连接场景</h3><p>在长连接的网络应用中，客户端和服务器之间会保持长时间的连接，不断地进行数据传输。在这种情况下，使用池化的<code>ByteBuf</code>可以减少每次数据传输时的内存分配开销，提高连接的稳定性和性能。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>为什么Netty宁可自己实现ByteBuf也不愿意使用<code>ByteBuffer</code>呢？虽然没有机会直接询问作者，但是从源码入手可以明显感受到，jdk自带的<code>ByteBuffer</code>在使用上存在诸多不便，比如没有池化，回收条件苛刻等。netty作为网络框架需要更高效和便捷的工具，为此不得不额外增加大量设计。</p>\n<p>对了，还有<code>ByteBuf</code>的容量是否可变的争论。从接口定义来看，是可变的。细纠实现，非池化的<code>ByteBuf</code>会创建新的数组并且复制数据，池化的<code>ByteBuf</code>仅会改变内部的计数器，没有其他副作用。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clj7jcuu20002jno05smogabl","tag_id":"clj7jcuu30003jno0feuhb40k","_id":"clj7jcuu50006jno0bb4a2n9u"},{"post_id":"clj7jcuu20002jno05smogabl","tag_id":"clj7jcuu40004jno03n7m6umy","_id":"clj7jcuu50007jno0b3np8f4p"},{"post_id":"clj7jcuu20002jno05smogabl","tag_id":"clj7jcuu40005jno0abgq4ci5","_id":"clj7jcuu50008jno0gpjufpza"},{"post_id":"clx9h4k2r0000cotg82mm0679","tag_id":"clx9h4k2t0003cotggfuw1k1n","_id":"clx9h4k2w000ccotge97j5tds"},{"post_id":"clx9h4k2r0000cotg82mm0679","tag_id":"clx9h4k2v0006cotg451gfyxl","_id":"clx9h4k2w000dcotg5c1sf6wk"},{"post_id":"clx9h4k2r0000cotg82mm0679","tag_id":"clx9h4k2w0009cotgbekk6xuo","_id":"clx9h4k2x000fcotg49vp1c81"},{"post_id":"clx9h4k2r0000cotg82mm0679","tag_id":"clx9h4k2w000acotg25fffqeu","_id":"clx9h4k2x000gcotg68tj0h8e"},{"post_id":"clx9h4k2s0002cotg6fjb9yx7","tag_id":"clx9h4k2w000bcotg32yy7xdz","_id":"clx9h4k2x000jcotgc63t0wa2"},{"post_id":"clx9h4k2s0002cotg6fjb9yx7","tag_id":"clx9h4k2x000ecotg8tmrhlzt","_id":"clx9h4k2x000kcotg9lt86p94"},{"post_id":"clx9h4k2s0002cotg6fjb9yx7","tag_id":"clx9h4k2x000hcotgh63236hu","_id":"clx9h4k2x000mcotg3bw7738z"},{"post_id":"clx9h4k2u0004cotgdgf0e3sr","tag_id":"clx9h4k2x000icotgbci2dbdr","_id":"clx9h4k2x000pcotg3lp85b2i"},{"post_id":"clx9h4k2u0004cotgdgf0e3sr","tag_id":"clx9h4k2x000lcotgc2026at4","_id":"clx9h4k2x000qcotgbv5653qf"},{"post_id":"clx9h4k2u0004cotgdgf0e3sr","tag_id":"clx9h4k2x000ncotgbdv12ozr","_id":"clx9h4k2x000scotg8tjca6jk"},{"post_id":"clx9h4k2v0005cotg2n4ge1yi","tag_id":"clx9h4k2x000ocotgay1y6w3d","_id":"clx9h4k2y000wcotgbqsqhgly"},{"post_id":"clx9h4k2v0005cotg2n4ge1yi","tag_id":"clx9h4k2x000rcotg9091arkx","_id":"clx9h4k2y000xcotg1eawfw41"},{"post_id":"clx9h4k2v0005cotg2n4ge1yi","tag_id":"clx9h4k2y000tcotge7oyezw6","_id":"clx9h4k2z000zcotgbc3d8h9y"},{"post_id":"clx9h4k2v0005cotg2n4ge1yi","tag_id":"clx9h4k2y000ucotg5ky2ble5","_id":"clx9h4k2z0010cotggpuz52yb"},{"post_id":"clx9h4k2v0007cotg3uazhqx2","tag_id":"clx9h4k2t0003cotggfuw1k1n","_id":"clx9h4k2z0012cotgas7acg4c"},{"post_id":"clx9h4k2v0007cotg3uazhqx2","tag_id":"clx9h4k2v0006cotg451gfyxl","_id":"clx9h4k2z0013cotg497k7j54"},{"post_id":"clx9h4k2v0007cotg3uazhqx2","tag_id":"clx9h4k2w0009cotgbekk6xuo","_id":"clx9h4k2z0015cotg8ebrgibk"},{"post_id":"clx9h4k2v0007cotg3uazhqx2","tag_id":"clx9h4k2w000acotg25fffqeu","_id":"clx9h4k2z0016cotgf82b7i0w"},{"post_id":"clx9h4k2w0008cotgda0c48pj","tag_id":"clj7jcuu40005jno0abgq4ci5","_id":"clx9h4k2z0018cotg9pz88xte"},{"post_id":"clx9h4k2w0008cotgda0c48pj","tag_id":"clx9h4k2z0014cotgfpdmfnbh","_id":"clx9h4k2z0019cotge4b1ctbv"},{"post_id":"clxru55c30000ektg7c3l9fom","tag_id":"clxru55c60001ektg5eojdiut","_id":"clxru55c80003ektga9r7f3dx"},{"post_id":"clxru55c30000ektg7c3l9fom","tag_id":"clj7jcuu40005jno0abgq4ci5","_id":"clxru55c80004ektg6ytbfrvf"},{"post_id":"clxru55c30000ektg7c3l9fom","tag_id":"clx9h4k2z0014cotgfpdmfnbh","_id":"clxru55c80005ektg8jwo6q31"},{"post_id":"clxru55c30000ektg7c3l9fom","tag_id":"clxru55c80002ektg7ui21nvl","_id":"clxru55c80006ektg5mrj7wqs"},{"post_id":"clx9h4k2w0008cotgda0c48pj","tag_id":"clxru55c60001ektg5eojdiut","_id":"clxru55cd000aektgbpj81wa1"},{"post_id":"clxru55cb0007ektg2lbh22cq","tag_id":"clxru55cc0009ektg9qjq4kc0","_id":"clxru55ce000cektghdb15re0"},{"post_id":"clxru55cb0008ektg07d811go","tag_id":"clxru55cc0009ektg9qjq4kc0","_id":"clxru55ce000dektgb7rw4j8g"},{"post_id":"cm7q3a39h0000totg9d0t9qli","tag_id":"cm7q3a39k0001totg9k2n7o44","_id":"cm7q3a39m0004totg8f7ch7d4"},{"post_id":"cm7q3a39h0000totg9d0t9qli","tag_id":"cm7q3a39m0002totg8lee8sna","_id":"cm7q3a39m0005totg9cjh22rh"},{"post_id":"cm7q3a39h0000totg9d0t9qli","tag_id":"cm7q3a39m0003totg5dytelh8","_id":"cm7q3a39m0006totg199kb2h5"},{"post_id":"cm7q3a39h0000totg9d0t9qli","tag_id":"cm7our2f50003awtgbui375wy","_id":"cm7q3a39m0007totg57vbcphf"},{"post_id":"cm7q3a39m0008totga71o1ih0","tag_id":"cm7our2f30001awtgftpf5wxe","_id":"cm7q3a39n0009totg0lchajow"},{"post_id":"cm7q3a39m0008totga71o1ih0","tag_id":"cm7our2f50002awtgakpuew3n","_id":"cm7q3a39n000atotgg0br7gli"},{"post_id":"cm7q3a39m0008totga71o1ih0","tag_id":"cm7our2f50003awtgbui375wy","_id":"cm7q3a39n000btotgg8i2aiu7"}],"Tag":[{"name":"字符串优化","_id":"clj7jcuu30003jno0feuhb40k"},{"name":"内存优化","_id":"clj7jcuu40004jno03n7m6umy"},{"name":"Java","_id":"clj7jcuu40005jno0abgq4ci5"},{"name":"go","_id":"clx9h4k2t0003cotggfuw1k1n"},{"name":"home-center","_id":"clx9h4k2v0006cotg451gfyxl"},{"name":"go-downloader","_id":"clx9h4k2w0009cotgbekk6xuo"},{"name":"编程日志","_id":"clx9h4k2w000acotg25fffqeu"},{"name":"GC","_id":"clx9h4k2w000bcotg32yy7xdz"},{"name":"学习笔记","_id":"clx9h4k2x000ecotg8tmrhlzt"},{"name":"垃圾回收的算法与实现","_id":"clx9h4k2x000hcotgh63236hu"},{"name":"读书笔记","_id":"clx9h4k2x000icotgbci2dbdr"},{"name":"程序设计","_id":"clx9h4k2x000lcotgc2026at4"},{"name":"Unix编程艺术","_id":"clx9h4k2x000ncotgbdv12ozr"},{"name":"js","_id":"clx9h4k2x000ocotgay1y6w3d"},{"name":"react","_id":"clx9h4k2x000rcotg9091arkx"},{"name":"状态管理","_id":"clx9h4k2y000tcotge7oyezw6"},{"name":"前端","_id":"clx9h4k2y000ucotg5ky2ble5"},{"name":"每日一篇","_id":"clx9h4k2z0011cotgfrwt3prs"},{"name":"源码分析","_id":"clx9h4k2z0014cotgfpdmfnbh"},{"name":"每周一篇","_id":"clxru55c60001ektg5eojdiut"},{"name":"spring boot","_id":"clxru55c80002ektg7ui21nvl"},{"name":"设计模式","_id":"clxru55cc0009ektg9qjq4kc0"},{"name":"netty","_id":"cm7our2f30001awtgftpf5wxe"},{"name":"网络编程","_id":"cm7our2f50002awtgakpuew3n"},{"name":"面试","_id":"cm7our2f50003awtgbui375wy"},{"name":"飞常准","_id":"cm7our2f50004awtgbr3vhj98"},{"name":"高性能","_id":"cm7q3a39k0001totg9k2n7o44"},{"name":"高并发","_id":"cm7q3a39m0002totg8lee8sna"},{"name":"DIY自己做","_id":"cm7q3a39m0003totg5dytelh8"}]}}